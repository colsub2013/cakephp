                                          NOTAS EN CAKEPHP
                                          ================

PROYECTO EN GIT
===============

Registración en https://github.com/users
mmcontini08
mmcontini08@gmail.com
Sally.2013

https://github.com/colsub2013/cakephp.git

touch README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/colsub2013/cakephp.git
git push -u origin master

git remote add origin https://github.com/colsub2013/cakephp.git
git push -u origin master

--------------------------------------------------------------------------------
ERROR
=====
Error: Call to a member function setFlash() on a non-object 

Solución: Se da porque en el AppController extendido no se seteó la variable 
de sesión:

var $components = array('Session');

--------------------------------------------------------------------------------

ERROR DE TIMEZONE
=================
Warning (2): strtotime(): It is not safe to rely on the system's timezone settings. 
You are *required* to use the date.timezone setting or the date_default_timezone_set() 
function. In case you used any of those methods and you are still getting this warning, 
you most likely misspelled the timezone identifier. We selected 'America/Sao_Paulo' 
for '-3.0/no DST' instead [CORE\Cake\Cache\CacheEngine.php, line 60]

Solución: descomentar la siguiente línea en app/Config/core.php:

/**
 * Uncomment this line and correct your server timezone to fix
 * any date & time related errors.
 */
	date_default_timezone_set('UTC');

--------------------------------------------------------------------------------
CÓDIGO PARA LA CAPA MODELO
==========================
Para una tabla llamada Posts, Los archivos de clase van en /app/Model, y el 
archivo creado se almacenará en /app/Model/Post.php. El archivo será algo así 
como:

class Post extends AppModel {
  ...
}

De aquí las convenciones de nombre serán:

. Nombre de Tabla: Posts
. Nombre de clase controlador: PostsController
................................................................................

CÓDIGO PARA LA CAPA CONTROLADOR
===============================
Aquí es donde se aloja la lógica de negocio de la aplicación. Siguiendo el ej.,
se crea el archivo /app/Controller/PostsController.php, con la forma:

class PostsController extends AppController {
  public $helpers = array(’Html’, ’Form’);
}

Ej.: Cuando los usuarios peticionan www.example.com/posts/index (que es lo mismo
que www.example.com/posts/), esperan ver una lista de posts. El código para esto:

class PostsController extends AppController {
  public $helpers = array('Html', 'Form');
  public function index() {
    $this->set('posts', $this->Post->find('all'));
  }
}

Definiendo la función index() en nuestro PostsController, los usuarios pueden
acceder a la lógica allí peticionando www.example.com/posts/index.

La única instrucción en la acción usa set() para pasar datos desde el controlador
a la vista. La línea setea la variable vista llamada 'posts' igual al valor de
retorno del método find(’all’) del modelo Post.

................................................................................

CÓDIGO PARA LA CAPA DE VISTA
============================
Mayormente se compone de HTML mezclado PHP, pero puede terminar siendo XML, CSV 
ó aún datos binarios. 

Un layout es un código de presentación que está envuelto alrededor de una vista.
Puede definir múltiples layouts, e intercambiar entre ellos.

Pasar datos a la vista lucirá como:
// print
Array
(
  [0] => Array
    (
      [Post] => Array
        (
          [id] => 1
          [title] => The title
          [body] => This is the post body.
          [created] => 2008-02-13 18:34:55
          [modified] =>
        )
    )
  [1] => Array
    (
      [Post] => Array
        (
          [id] => 2
          [title] => A title once again
          [body] => And the post body follows.
          [created] => 2008-02-13 18:34:56
          [modified] =>
        )
    )
  [2] => Array
    (
      [Post] => Array
        (
          [id] => 3
          [title] => Title strikes back
          [body] => This is really exciting! Not.
          [created] => 2008-02-13 18:34:57
          [modified] =>
        )
    )
)

Los archivos de vista se almacenan en /app/View (aquí /app/View/Posts/index.ctp) 
Formateo de datos en una tabla:

<!-- File: /app/View/Posts/index.ctp -->
<h1>Blog posts</h1>
<table>
  <tr>
    <th>Id</th>
    <th>Title</th>
    <th>Body</th>
    <th>Created</th>
  </tr>
  <!-- Here is where we loop through our $posts array, printing out post info -->
  <?php foreach ($posts as $post): ?> <!-- Esta es la variable que se 'post' fijada por set() en el controlador -->
  <tr>
    <td>
      <?php echo $post['Post']['id']; ?>
    </td>
    <td>
      <?php echo $this->Html->link($post['Post']['title'],
      array('controller' => 'posts', 'action' => 'view', $post['Post']['id'])); ?>  <!-- link() es un método del helper HtmlHelper  -->
    </td>
    <td>
      <?php echo $post['Post']['body']; ?>
    </td>
    <td>
      <?php echo $post['Post']['created']; ?>
    </td>
  </tr>
  <?php endforeach; ?>
  <?php unset($post); ?>
</table>

El objeto $this->Html es una instancia de la clase de CakePHP HtmlHelper (CakePHP
viene con un set de helpers de vista), salida de formulario, JavaScript y Ajax.
En el helper visto el método link() generará un enlace HTML con un título dado
(el 1er argumento) y la URL (el 2do argumento).

Al especificar URLs en en CakePHP, se recomienda usar formato de array (lo que
permite usar la capacidad de enrutamiento inverso). Puede especificar URLs 
relativas para la base de la aplicación en la forma /controller/action/param1/param2. 

Aquí ya puede apuntar el navegador a http://www.example.com/posts/index. Debería
ver su vista, formateada correctamente con enlistamiento y título de los posteos. 

Si ha clickeado en uno de los enlaces que creamos en esta vista (que enlaza un 
título de posteo a una URL /posts/view/some_id), se verá que la vista no se
definió. Se los creará en el PostsController:  

class PostsController extends AppController {
  
  public $helpers = array(’Html’, ’Form’);
  
  public function index() {
    $this->set(’posts’, $this->Post->find(’all’));
  }

  public function view($id = null) {
    if (!$id) {
      throw new NotFoundException(__(’Invalid post’));
    }
    $post = $this->Post->findById($id);
    if (!$post) {
      throw new NotFoundException(__(’Invalid post’));
    }
    $this->set(’post’, $post);
  }

}

Se usó findById() en vez de find('all') ya que se busca info de un sólo posteo.

La acción de view toma como parámetro la ID del posteo que queremos ver. Este 
parámetro se maneja a la acción a través de la URL peticionada. Si un usuario
peticiona /posts/view/3, se pasa como $id el valor '3'. 

También hacemos un chequeo de error para asegurar que un usuario está en realidad
accediendo a un registro. Si un usuario peticiona /posts/view, se arrojará un
NotFoundException y se dejará que el manejo de error de CakePHP tome lugar.

También hubo otro manejo de error para asegurarse que el registro que ha accedido
un usuario existe.

La vista para la nueva acción de 'view' en /app/View/Posts/view.ctp: 

<!-- File: /app/View/Posts/view.ctp -->
<h1><?php echo h($post['Post']['title']); ?></h1>
<p><small>Created: <?php echo $post['Post']['created']; ?></small></p>
<p><?php echo h($post['Post']['body']); ?></p>
................................................................................

AGREGAR POSTEOS
===============
Para agregar posteos nuevos se crea una acción add() en el PostsController: 

class PostsController extends AppController {
  public $helpers = array(’Html’, ’Form’, ’Session’);
  public $components = array(’Session’);
  
  public function index() {
    $this->set(’posts’, $this->Post->find(’all’));
  }

  public function view($id) {
    if (!$id) {
      throw new NotFoundException(__(’Invalid post’));
    }
    $post = $this->Post->findById($id);
    if (!$post) {
      throw new NotFoundException(__(’Invalid post’));
    }
    $this->set(’post’, $post);
  }

  public function add() {
    if ($this->request->is(’post’)) {
      $this->Post->create();
      if ($this->Post->save($this->request->data)) {
        $this->Session->setFlash(__(’Your post has been saved.’));
        return $this->redirect(array(’action’ => ’index’));
      }
      $this->Session->setFlash(__(’Unable to add your post.’));
    }
  }

}

Nota: $this->request->is() toma como argumento el método de petición
(get, put, post, delete) ó al algún identificador de petición (Ajax). Ej.:
$this->request->is('book') no retornará true si datos tipo book fueron posteados.

Nota: Necesita incluir el SessionComponent - y SessionHelper - en cualquier
controlador donde uno lo usará. Si es necesario, incluirlo en su AppController.    

Lo que hace la acción add(): si el método HTTP de la petición fue POST, este 
intenta guardar los datos usando el modelo POST. Si por alguna razón este no
lo almacena, sólo renderiza la vista. Esto nos da chances de mostrar errores
de validación de usuario ú otras advertencias.

Cada petición CakePHP incluye un objeto CakeRequest que es accesible usando
$this->request. El objeto de petición puede usarse para controlar el flujo de la 
aplicación. Aquí se usa CakeRequest::is() para chequear que la petición es una
petición POST HTTP. 

Cuando un usuario usa un formulario para datos POST a su aplicación, esa info
está disponible en $this->request->data. Puede usar pr() ó debug() para imprimirlo
si quiere ver como luce.  

Se usa SessionComponent::setFlash() para setear un mensaje a una variable de 
sesión para ser mostrada en la página después de la redirección. En el layout
se tiene a SessionHelper::flash que exhibe el mensaje y limpia la variable de 
sesión correspondiente. 

La función Controller::redirect redirige a otra URL. El parámetro 
array(’action’ => ’index’) traduce a posteos / URL (la acción índice de los
controlador de posts). Con la función Router::url() para ver los formatos
que que puede especificar una URL para varias funciones CakePHP. 

Llamar al método save() chequeará por errores de validación y aborta el
almacenamiento si ocurre algo.

Creamos al método create() primero para resetear el estado del modelo para 
guardar información nueva. Esto no crea un registro en la db, pero limpia 
Model::$id y setea Model::$data basado en los valores por defecto de su campo DB.

................................................................................

VALIDACIÓN DE DATOS
===================
Para esto necesita en sus vistas FormHelper de CakePHP. El FormHelper está
disponible por defecto para todas las vistas en $this->Form.  

La vista para agregar:

<!-- File: /app/View/Posts/add.ctp -->
<h1>Add Post</h1>
<?php
  echo $this->Form->create(’Post’);
  echo $this->Form->input(’title’);
  echo $this->Form->input(’body’, array(’rows’ => ’3’));
  echo $this->Form->end(’Save Post’);
?>

Se usa a FormHelper para generar la etiqueta de apertura para un formulario HTML.
El HTML generado por $this->Form->create(): 

<form id="PostAddForm" method="post" action="/posts/add"> 

Si se llama a create() sin parámetros, se asume que se construye un formulario
que se envía vía POST a la acción de controlador add() actual (ó la acción 
edit() cuando el id está incluido en los datos de formulario).

Se usa el método $this->Form->input() para crear elementos de formulario del
mismo nombre. El 1er parámetro le dice a CakePHP a que campo corresponde,
y el 2do le permite configurar opciones adicionales (aquí el número de filas
para el textarea). input() producirá elementos de formulario diferentes basados
en el campo de modelo especificado. 

La llamada $this->Form->end() genera un botón de envío y finaliza el formulario.
Si se suministró un String como 1er parámetro para end(), el FormHelper produce
un botón de envío nombrado acorde junto con la etiqueta de cierre de formulario.

Se actualiza la vista /app/View/Posts/index.ctp para incluir un enlace 'Add Post'
nuevo. Antes de <table>, agregar la línea:  

<?php echo $this->Html->link(
    'Add Post',
    array('controller' => 'posts', 'action' => 'add')
  ); 
?>

Las reglas de validación se definen en el modelo. Ajustemos el modelo Post:

class Post extends AppModel {
  public $validate = array(
    ’title’ => array(
      ’rule’ => ’notEmpty’
    ),
    ’body’ => array(
      ’rule’ => ’notEmpty’
    )
  );
}

El array $validate le dice a CakePHP como validar sus datos al llamar al método
save(). Aquí se especificaron que ambos 'title' y 'body' no estén vacíos. La 
validación de CakePHP viene con varias reglas pre-cargadas (números de tarjeta
de crédito, direcciones de e-mail, etc.) y flexibilidad para agregar sus
propias reglas de validación.   

................................................................................

EDITAR POSTEOS
==============
La acción edit() del PostsController luciría como:

  public function edit($id = null) {
    if (!$id) {
      throw new NotFoundException(__('Invalid post'));
    }
    $post = $this->Post->findById($id);
    if (!$post) {
      throw new NotFoundException(__('Invalid post'));
    }
    if ($this->request->is(array('post', 'put'))) {
      $this->Post->id = $id;
      if ($this->Post->save($this->request->data)) {
        $this->Session->setFlash(__('Your post has been updated.'));
        return $this->redirect(array('action' => 'index'));
      }
      $this->Session->setFlash(__('Unable to update your post.'));
    }
    if (!$this->request->data) {
      $this->request->data = $post;
    }
  }

Esta acción primero asegura que el usuario ha intentado acceder a un registro
existente. Si ellos no han pasado un parámetro $id, ó el posteo no existe,
se arrojará un NotFoundException para el ErrorHandler de CakePHP.  

Luego la acción chequea si la petición es POST ó PUT. Si lo es, se usan los 
datos POST para actualizar nuestro registro POST, ó volver y mostrar los errores
de validación de usuario.

Si no hay datos seteados para $this->request->data, lo seteamos al post recobrado
previamente.

La vista edit lucirá como:

<!-- File: /app/View/Posts/edit.ctp -->
<h1>Edit Post</h1> 
<?php
  echo $this->Form->create(’Post’);
  echo $this->Form->input(’title’);
  echo $this->Form->input(’body’, array(’rows’ => ’3’));
  echo $this->Form->input(’id’, array(’type’ => ’hidden’));
  echo $this->Form->end(’Save Post’);
?>

Esta vista produce la edición del formulario (con los valores populados), junto
con los mensajes de error de validación necesarios. 

CakePHP asumirá que uno está editando un modelo si está presente el campo 'id'
en el array de datos. Si no hay presente ninguna id, CakePHP asumirá que uno 
está insertando un modelo nuevo al llamarse a save(). 

Se actualiza la vista index para editar posteos específicos:

You can now update your index view with links to edit specific posts:

<!-- File: /app/View/Posts/index.ctp (edit links added) -->
<h1>Blog posts</h1>
  <p><?php echo $this->Html->link("Add Post", array(’action’ => ’add’)); ?></p>
  <table>
    <tr>
      <th>Id</th>
      <th>Title</th>
      <th>Action</th>
      <th>Created</th>
    </tr>
    <!-- Here’s where we loop through our $posts array, printing out post info -->
    <?php foreach ($posts as $post): ?>
    <tr>
      <td><?php echo $post[’Post’][’id’]; ?></td>
      <td>
        <?php
          echo $this->Html->link(
            $post[’Post’][’title’],
            array(’action’ => ’view’, $post[’Post’][’id’])
          );
        ?>
      </td>
      <td>
        <?php
          echo $this->Html->link(
            ’Edit’,
            array(’action’ => ’edit’, $post[’Post’][’id’])
          );
        ?>
      </td>
      <td>
        <?php echo $post[’Post’][’created’]; ?>
      </td>
    </tr>
    <?php endforeach; ?>
</table>
................................................................................
BORRAR POSTEOS
==============
Se comienza con una acción delete() en el PostsController:

public function delete($id) {
  if ($this->request->is('get')) {
    throw new MethodNotAllowedException();
  }
  if ($this->Post->delete($id)) {
    $this->Session->setFlash(__('The post with id: %s has been deleted.', h($id)));
    return $this->redirect(array('action' => 'index'));
  }
}

Esta lógica borra el posteo especificado por $id, y usa $this->Session->setFlash()
para mostrar al usuario un mensaje de confirmación después de redireccionarlos
a /posts. Si el usuario intenta borrar usando una petición GET, se arroja una 
excepción. Las excepciones no capturadas son capturadas por el manejador de 
excepciones de CakePHP, y se muestra una página de error. Hay varias 
excepciones prefabricadas  que pueden usarse para indicar los variados errores
HTTP que su aplicación puede necesitar generar.

Ya que sólo estamos ejecutando alguna lógica y redireccionando, esta acción no
tiene vista. Se deberá actualizar la vista index con los enlaces que le permiten
a los usuarios borrar posteos, sin embargo:

<!-- File: /app/View/Posts/index.ctp -->
<h1>Blog posts</h1>
<p><?php echo $this->Html->link(’Add Post’, array(’action’ => ’add’)); ?></p>
<table>
  <tr>
    <th>Id</th>
    <th>Title</th>
    <th>Actions</th>   
    <th>Created</th>
  </tr>
  <!-- Here’s where we loop through our $posts array, printing out post info -->
  <?php foreach ($posts as $post): ?>
  <tr>
    <td><?php echo $post[’Post’][’id’]; ?></td>
    <td>
      <?php
        echo $this->Html->link(
        $post[’Post’][’title’],
        array(’action’ => ’view’, $post[’Post’][’id’])
        );
      ?>
    </td>
    <td>
      <?php
        echo $this->Form->postLink(
        ’Delete’,
        array(’action’ => ’delete’, $post[’Post’][’id’]),
        array(’confirm’ => ’Are you sure?’)
        );
      ?>
      <?php
        echo $this->Html->link(
        ’Edit’, array(’action’ => ’edit’, $post[’Post’][’id’])
        );
      ?>
    </td>
    <td>
      <?php echo $post[’Post’][’created’]; ?>
    </td>
  </tr>
  <?php endforeach; ?>
</table>

Usar postLink() creará un enlace que usa JavaScript para hacer una petición POST 
para borrar nuestro posteo. Borrar contenido usando peticiones GET es riesgoso,
ya que crawlers web pueden borrar accidentalmente toda la info.

Nota: este código view también usa el FormHelper para preguntar al usuario con
un diálogo de confirmación antes de que ellos intenten borrar el posteo.
................................................................................

RUTAS
=====
Por defecto, CakePHP responde a una petición para la raíz de su sitio
(ej., http://www.example.com) usando sus PagesController, renderizando una 
view llamada 'home'. En vez de eso se reemplazará esto con nuestro PostsController
creando una regla de enrutamiento.

El enrutamiento de CakePHP está en /app/Config/routes.php. Querrá comentar la
línea que define la ruta raíz por defecto. Esto luce como:

Router::connect(
  ’/’,
  array(’controller’ => ’pages’, ’action’ => ’display’, ’home’)
);

Esta línea conecta la URL '/' con la página home por defecto de CakePHP. Queremos
conectarla con nuestro propio controlador, así reemplazar esa línea con:

Router::connect(’/’, array(’controller’ => ’posts’, ’action’ => ’index’));

Esto debería conectar a usuarios que peticionan '/' a la acción index() de nuestro
PostsController.

Nota: CakePHP también usa 'enrutamiento inverso'. Si, con la ruta definida arriba,
uno pasa array(’controller’ => ’posts’, ’action’ => ’index’) a una función que
espera un array, la URL resultante usada será '/'. Con esto sus rutas definen
donde va la URL, y también asegura que los enlaces apunten al mismo lugar.

--------------------------------------------------------------------------------
MODIFICACIONES PARA HACER FUNCIONAR EL URL REWRITING
====================================================
...
LoadModule rewrite_module modules/mod_rewrite.so
...

<Directory "C:/Program Files/Apache Software Foundation/Apache2.2/htdocs">
    #
    # Possible values for the Options directive are "None", "All",
    # or any combination of:
    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews
    #
    # Note that "MultiViews" must be named *explicitly* --- "Options All"
    # doesn't give it to you.
    #
    # The Options directive is both complicated and important.  Please see
    # http://httpd.apache.org/docs/2.2/mod/core.html#options
    # for more information.
    #
    Options Indexes FollowSymLinks

    #
    # AllowOverride controls what directives may be placed in .htaccess files.
    # It can be "All", "None", or any combination of the keywords:
    #   Options FileInfo AuthConfig Limit
    #
    AllowOverride All

    #
    # Controls who can get stuff from this server.
    #
    # Order allow,deny
    Allow from all

</Directory>
................................................................................

CONVENCIONES DE CONTROLADOR
===========================
Los nombres de clase de Controlador son plurales, camel-case y finalizan con
Controller. Ej.: PeopleController y LatestArticlesController.

El 1er método que uno escribe para un controlador puede ser index(). Cuando una
petición especifica un controlador pero no una acción, el comportamiento por 
defecto de CakePHP es ejecutar index() de ese controlador. Ej.:

. http://www.example.com/apples/ mapea a una llamada en index() del ApplesController
. http://www.example.com/apples/view/ mapea a una llamada en view() del ApplesController

Puede también cambiar la visibilidad de métodos controlador en CakePHP prefijando
los nombres de método controlador con guiones. Si un método controlador ha sido
prefijado con guiones, el método no será accesible directamente desde la web
pero si lo será para uso interno. Ej.:

class NewsController extends AppController {
  public function latest() {
    $this->_findNewArticles();
  }
  
  protected function _findNewArticles() {
    // Logic to find latest news articles
  }
}

Así:
. http://www.example.com/news/latest/ : será accesible de forma usual al usuario.
. http://www.example.com/news/_findNewArticles/ : se obtiene un error, ya que 
método está precedido con un guión bajo. 

Los métodos no-públicos no pueden ser accedidos. 

Consideraciones de URL para nombres de Controlador
--------------------------------------------------
Los controladores de palabra única pueden mapearse a una ruta de URL simple en
minúsculas. Ej.: ApplesController (que estaría definida en el archivo 'ApplesController.php')
se accede desde http://example.com/apples.

Los controladores de palabra múltiple pueden ser 'inflingidas' de cualquier forma
que equivalga al nombre del controlador:

• /redApples
• /RedApples
• /Red_apples
• /red_apples

Todos resolverán al índice del controlador RedApples. Pero la convención es que 
sus URLs estén en minúsculas y con guión bajo, así /red_apples/go_pick es la 
forma correcta de acceder a la acción RedApplesController::go_pick. 

Convenciones de archivo y nombre de clase
-----------------------------------------
Por ej.: para una clase MyNiftyClass, en CakePHP el archivo debería nombrarse
MyNiftyClass.php. Demás ej. para nombres de aplicación en CakePHP:

. La clase Controlador KissesAndHugsController debería hallarse en un archivo
  llamado KissesAndHugsController.php
   
. La clase Componente MyHandyComponent debería hallarse en un archivo MyHandyComponent

. La clase Modelo OptionValue debería hallarse en un archivo OptionValue.php

. La clase Comportamiento EspeciallyFunkableBehavior debería hallarse en un 
  archivo EspeciallyFunkableBehavior.php
  
. La clase Vista SuperSimpleView debería hallarse en un archivo SuperSimpleView.php

. La clase Helper BestEverHelper debería hallarse en un archivo BestEverHelper.php

Cada archivo debería ubicarse en la carpeta apropiada en /app.

Convenciones de Modelo y Base de Datos
--------------------------------------
Los nombres de clase Modelo son únicos y camel-case. Ej.: Person, BigPerson, y ReallyBigPerson. 

Los nombres de tabla correspondientes a modelos CakePHP son plurales y con guión bajo.
Las tablas subyacentes para los modelos mencionados arriba son people, big_people, and really_big_people,
respectivamente.

Puede usar la librería de Utilidad Inflector para chequear palabras singular/plural.

Los nombres de Campo con 2 ó más palabras van con guión bajo: first_name.

Las claves foráneas en relaciones hasMany, belongsTo ó hasOne son reconocidas por
defecto como el nombre único de la tabla relacionada seguido de _id. Así si un
Baker hasMany Cake, la tabla cakes se referirá a la tabla bakers vía una clave
foránea. Para una tabla como category_types cuyo nombre contiene varias palabras,
la clave foránea sería category_type_id.

Unir tablas, usado en relaciones entre modelos hasAndBelongsToMany (HABTM), 
deberían nombrarse después de las tablas modelo que unirán, arregladas en 
orden alfabético (apples_zebras en vez de zebras_apples).

Todas las tablas con las que interactúan los modelos CakePHP (con la excepción de
la unión de tablas) requieren una clave primaria singular para identificar de 
forma unívoca cada fila. Para modelar una tabla que no tiene ya una clave primaria
de campo único, la convención de CakePHP es que la clave primaria de campo único
se agregó a la tabla. Debe agregar una clave primaria de campo único si quiere
usar ese modelo de tabla.

CakePHP no soporta claves primarias compuestas. Si quiere manipular directamente
sus datos de unión de tabla, usar directamente llamadas de query ó agregue
una clave primaria para actuar sobre esa como un modelo normal. Ej.:

CREATE TABLE posts_tags ( id INT(10) NOT NULL AUTO_INCREMENT, post_id INT(10)
NOT NULL, tag_id INT(10) NOT NULL, PRIMARY KEY(id));

En vez de usar una clave auto-increment como clave primaria, puede también usar
char(36). CakePHP usará un UUID (String::uuid) único de 36 caracteres cada vez que
almacene un registro nuevo usando el método Model::save.

Convenciones de Vista
---------------------
Los archivos de plantilla de Vista son nombrados después que las funciones controlador
que exhiben, en forma con guión bajo. La función getReady() de la clase PeopleController
buscará una plantilla de vista en /app/View/People/get_ready.ctp.

El patrón básico es /app/View/Controller/underscored_function_name.ctp.

Ej. final:

• Tabla en DB: 'people'
• Clase Modelo: 'Person', hallada en /app/Model/Person.php
• Clase Controlador: 'PeopleController', hallada en /app/Controller/PeopleController.php
• Plantilla de Vista, hallada en /app/View/People/index.ctp

Con estas convenciones, CakePHP sabe que una petición a http://example.com/people/
mapea a una llamada en la función index() del PeopleController, donde el modelo
Person está disponible automáticamente (y ligado automáticamente a la tabla 
'People' en la DB), y renderiza a un archivo.   
................................................................................
ESTRUCTURA DE CARPETAS DE CAKEPHP
---------------------------------
• app
• lib
• vendors
• plugins
• .htaccess
• index.php
• README

Las carpetas principales:

• La carpeta app es donde se ubicarán los archivos de su aplicación.
• La carpeta lib es donde se almacena el núcleo de CakePHP. No editar archivos
  ni modificarlos en esta carpeta. En vez de eso modifique las extensiones
  Application.
• La carpeta vendors es donde se colocan librerías PHP de tercera parte que 
  necesita usar en sus aplicaciones de CakePHP.

Carpeta App
-----------

.Config: Contiene archivos de configuración. Ej.: detalles de conexión a Db, 
bootstrapping, archivos de configuración del núcleo, etc.
 
.Console: Contiene comandos y tareas de consola para su aplicación. Este
directorio puede también contener un directorio Templates para personalizar
la salida.

.Controller: Contiene sus controladores de aplicación y sus componentes.

.Lib: Contiene librerías que no vienen con 3ras partes ó vendedores externos.
Esto le permite separar sus librerías de organización internas de librerías
de vendedor.

.Locale: Almacena archivos de String para internacionalización.

.Model: Contiene modelos, comportamientos y datasources de su aplicación.

.Plugin: Contiene paquetes de plugin.

.Test: Contiene todos los test cases y test fixtures de su aplicación. El 
directorio Test/Case debería reflejar su aplicación y contener 1 ó más test 
cases por clase en su aplicación. 

.tmp: Es donde CakePHP almacena datos temporales. Usualmente se usa para 
almacenar descripciones de modelo, logs y a veces info de sesión. Fijarse de
que esta carpeta exista y sea escribible. En modo debug, CakePHP le 
advertirá si esta carpeta no es escribible ó está ausente.

.Vendor: Es para cualquiera de las clases ó librerías de 3ra parte. Hacerlo 
facilita el acceso usando la función App::import('vendor', 'name').

.View: Contiene archivos de presentación: elementos, páginas de error, helpers,
layouts, y archivos de vista.

.webroot: En una puesta a producción, esta carpeta debería servir como la raíz
de documentos para su aplicación. Las carpetas aquí alojan hojas de estilo CSS,
imágenes, y archivos Javascript.
................................................................................
Estructura CakePHP
------------------
Extensiones Application
-----------------------
Los controladores, helpers y modelos tienen c/u una clase padre que puede usar
para definir cambios a nivel de aplicación. AppController (/app/Controller/AppController.php), 
AppHelper (/app/View/Helper/AppHelper.php) y AppModel (/app/Model/AppModel.php) 
son lugares para poner métodos que uno quiere compartir entre todos los 
controladores, helpers y modelos.

Las definiciones de Ruta le dicen a CakePHP como mapear URLs a acciones controlador.
El comportamiento por defecto asume que la URL /controller/action/var1/var2 mapea
a Controller::action($var1, $var2), pero puede usar rutas para personalizar URLs
y como ellas son interpretadas por su aplicación.

Un plugin es un paquete de modelos, controladores y vistas que cumplen un propósito
específico que puede abarcar múltiples aplicaciones.  

Extensiones Controller ('Componentes')
--------------------------------------
Un Componente es una clase que auxilia en lógica de controlador. Si tiene alguna
lógica que quiere compartir entre controladores (ó aplicaciones), un componente
es usualmente provechoso. Ej.: la clase núcleo EmailComponent facilita crear y
enviar mails. En vez de escribir un método controlador en un único controlador
que realiza esta lógica, puede empaquetar la lógica tal que esta pueda 
compartirse.

Los controladores también sientan con callbacks, los que puede necesitar para 
insertar alguna lógica entre las operaciones núcleo de CakePHP. Callbacks 
disponibles:

• afterFilter(): Ejecutado después de toda la lógica de control, incluyendo la
  renderización de la vista
• beforeFilter(): Ejecutado antes que cualquier lógica de acción de controlador
• beforeRender(): Ejecutado después de la lógica de controlador, pero antes que
  la vista sea renderizada
  
Extensiones Model ('Behaviour')
-------------------------------------
Los comportamientos agregan una funcionalidad común entre modelos. Ej.: si 
almacena datos de usuario en una estructura de árbol, puede especificar su 
modelo User como si se comportara como un árbol, y ganar libre funcionalidad
para quitar, agregar, y desplazar nodos en su estructura de árbol subyacente.

Los modelos son también soportados por otra clase llamada un DataSource, el que
es una abstracción que habilita a modelos a manipular tipos diferentes de 
de datos consistentes. Mientras que la fuente principal de datos en una aplicación
CakePHP es con frecuencia una DB, puede escribir DataSources adicionales que le
permiten a sus modelos representar alimentaciones RSS, archivos CSV, entradas
LDAP, ó eventos iCal. Los DataSources le permiten asociar registros desde 
fuentes diferentes: en vez de ser limitados por joins SQL, los DataSources le
permiten decirle a su modelos LDAP que este está asociado con varios eventos
iCal.

Los modelos también tienen callbacks:

• beforeFind()
• afterFind()
• beforeValidate()
• afterValidate()
• beforeSave()
• afterSave()
• beforeDelete()
• afterDelete()

Extensiones View ('Helpers')
----------------------------
Un helper es una clase que auxilia la lógica de vista. Los helpers permiten que
la lógica de presentación sea accedida y compartida entre vistas. Uno de los
helpers núcleo, JsHelper, hace a las peticiones AJAX dentro de vistas más fáciles
y vienen con soporte para jQuery (por defecto), Prototype y Mootools.

La mayoría de las aplicaciones tienen piezas de código de vista que son usadas
repetidamente. CakePHP facilita la reutilización de código de vista con layouts y
elementos. Por defecto, cada vista renderizada por un controlador se ubica dentro
de un layout. Los elementos son usados cuando pequeños fragmentos de contenido
necesitan reutilizarse en vistas múltiples.
--------------------------------------------------------------------------------
Permisos
--------
CakePHP usa el directorio app/tmp para por ej. descripciones del Modelo, vista
de caché e información de sesión.

El directorio app/tmp y todos sus subdirectorios en su instalación CakePHP deben
ser escribibles por el servidor web.

Puesta en marcha (Setup)
----------------
Los 3 tipos de instalación principales para CakePHP:

• Development: fácil de llevar, URLs para la aplicación incluyen el nombre de 
directorio de instalación de CakePHP, y la seguridad es menor.

• Production: Requiere configurar el document root del servidor web, limpiar URLs, 
muy seguro.
 
• Advanced: le permite ubicar directorios CakePHP claves en diferentes partes del
sistema de archivos, posiblemente compartiendo una carpeta de librería núcleo única
de CakePHP entre cualquiera de las aplicaciones CakePHP.

Development
-----------
Se asume como document root a /var/www/html (donde se aloja el paquete CakePHP
descomprimido). El sistema de archivos queda:

/var/www/html/
  cake_2_0/
    app/
    lib/
    plugins/
    vendors/
    .htaccess
    index.php
    README

Configurado correctamente el servidor web, la aplicación CakePHP quedará:
http://www.example.com/cake_2_0/.


Usar un Checkout CakePHP para aplicaciones múltiples
----------------------------------------------------
Al desarrollar varias aplicaciones, tiene sentido tenerlas compartidas con el 
mismo checkout de núcleo CakePHP. Una forma de hacerlo es usar el include_path
de PHP. Para arrancar, clonar CakePHP en un directorio.

Esto clonará CakePHP en su directorio /home/mark/projects. Luego tendrá que 
modificar php.ini. Hallado el archivo .ini correcto, modificar la configuración
include_path para incluir /home/mark/projects/cakephp/lib. Ej.:

include_path = .:/home/mark/projects/cakephp/lib:/usr/local/php/lib/php

Después de reiniciar su servidor web, debería ver los cambios reflejados en phpinfo().

Nota: Si está en Windows, separar las rutas de inclusión con ; en vez de :

Ahora sus aplicaciones deberían hallar automáticamente a CakePHP.

Production
----------
Este método le permite que un dominio entero actúe como una aplicación CakePHP
única. Se instalará CakePHP donde sea en su sistema de archivos y se lo hará
disponible en http://www.example.com. Esta instalación puede requerir los
permisos para cambiar el DocumentRoot en servidores web Apache.  

Desempaquetar los contenidos del archivo CakePHP en un directorio (por ej. 
/cake_install). Su puesta en marcha de producción se verá en el sistema de archivos:

/cake_install/
  app/
  webroot/ (this directory is set as the ‘‘DocumentRoot‘‘ directive)
  lib/
  plugins/
  vendors/
  .htaccess
  index.php
  README

Los desarrolladores que usan Apache deberían fijar la directiva DocumentRoot para
el dominio a: 

DocumentRoot /cake_install/app/webroot

Si su servidor web está configurado correctamente, hallaría su aplicación CakePHP
accesible en http://www.example.com.
--------------------------------------------------------------------------------
Reescritura de URL
------------------
Apache y mod_rewrite (y .htaccess)
----------------------------------
Mientras CakePHP está construido para trabajar con mod_rewrite fuera de caja
usualmente lo hace.

Primero mirar en httpd.conf. 

1. Asegurarse que un reescritura (override) de .htaccess está permitida y que 
AllowOverride se fija a All para el DocumentRoot correcto. Vería algo similar a:

# Each directory to which Apache has access can be configured with respect
# to which services and features are allowed and/or disabled in that
# directory (and its subdirectories).
#
# First, we configure the "default" to be a very restrictive set of
# features.
#
<Directory />
  Options FollowSymLinks
  AllowOverride All
  # Order deny,allow
  # Deny from all
</Directory>

2. Asegurarse de cargar mod_rewrite correctamente. Debería ver:

LoadModule rewrite_module libexec/apache2/mod_rewrite.so

Para esto hay que reiniciar el servidor web.

Verificar que sus archivos .htaccess están en los directorios correctos.

3. El directorio raíz de CakePHP (debe ser copiado a su documento; redirecciona
todo a su aplicación CakePHP):

<IfModule mod_rewrite.c>
  RewriteEngine on
  RewriteRule ^ $ app/webroot/ [L]
  RewriteRule (.*) app/webroot/ $ 1 [L]
</IfModule>

El directorio app de CakePHP (sería copiado al directorio principal de su aplicación):

<IfModule mod_rewrite.c>
  RewriteEngine on
  RewriteRule ^ $ webroot/ [L]
  RewriteRule (.*) webroot/ $ 1 [L]
</IfModule>

El directorio webroot de CakePHP (será copiado a su raíz de la aplicación web):

<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteRule ^(.*) $ index.php [QSA,L]
</IfModule>

Si su sitio CakePHP aún tiene problemas con mod_rewrite, puede querer modificar
la configuración para Hosts Virtuales. Asegurarse que AllowOverride None se 
cambie a AllowOverride All:  

<Directory />
  Options FollowSymLinks
  AllowOverride All
</Directory>
<Directory /var/www>
  Options Indexes FollowSymLinks MultiViews
  AllowOverride All
  Order Allow,Deny
  Allow from all
</Directory>

Si uno está instalando CakePHP en un directorio de usuario (http://example.com/~username/cakephp/),
ó cualquier otra estructura de URL que ya usa mod_rewrite, necesitará agregar 
sentencias RewriteBase a los archivos .htaccess que usa CakePHP 
(/.htaccess, /app/.htaccess, /app/webroot/.htaccess).

Esto puede agregarse a la misma sección con la directiva RewriteEngine, por ej.,
su archivo webroot .htaccess luciría:

<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /path/to/cake/app
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteRule ^(.*) $ index.php [QSA,L]
</IfModule>

4. (Opcional) Para mejorar la puesta en marcha de producción, debería evitar
asuntos inválidos de ser parseados por CakePHP. Modificar su .htaccess webroot a:

<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /path/to/cake/app
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_URI} !^/(app/webroot/)?(img|css|js)/(.*) $
  RewriteRule ^(.*) $ index.php [QSA,L]
</IfModule>

Lo de arriba evita que asuntos incorrectos sean enviados a index.php y en vez de
eso exhiban la página 404 del servidor web.

Puede también crear una página 404 coincidente, ó usar el 404 de CakePHP incorporado
agregando una directiva ErrorDocument:

ErrorDocument 404 /404-not-found
................................................................................

Encender todo
-------------
Si tiene errores relacionados a timezone desde PHP descomentar una línea en 
app/Config/core.php:

/**
* Uncomment this line and correct your server timezone to fix
* any date & time related errors.
*/
date_default_timezone_set(’UTC’);

--------------------------------------------------------------------------------
Ciclo de petición CakePHP
-------------------------
Ver "imagenes_notas/ciclo_peticion_cakephp.png"

El ciclo de petición típico de CakePHP arranca con un usuario que peticiona una
página ó recurso en su aplicación. Esta petición es primero procesada por un 
dispatcher que seleccionará el objeto controlador correcto para manejar esto.

Una vez que la petición llega al controlador, este se comunicará con la capa
Modelo para procesar cualquier extracción de datos ó - operación de guardado 
que puede necesitarse. Terminada esta comunicación, el controlador procederá a
delegar al objeto vista correcto la tarea de generar la salida resultante de los
datos provistos por el modelo.

Generada esta salida, esta se renderiza inmediatamente al usuario. 

--------------------------------------------------------------------------------
CONTROLADORES
=============
Un controlador suele usarse para gestiona la lógica alrededor de un modelo único.
Ej.: si uno construye un sitio para una panadería (bakery) online, uno puede tener
un RecipesController que gestione sus recetas y un IngredientsController que 
gestione sus ingredientes. Se pueden tener también controladores que funcionen con
más de un modelo. En CakePHP, un controlador se nombra después del modelo primario
que maneja.

Sus controladores de aplicación extienden la clase AppController, que extiende
la clase Controller núcleo. La clase AppController puede definirse en  
/app/Controller/AppController.php y este debería contener métodos que son 
compartidos entre todos los controladores de su aplicación.

Los controladores proveen un número de métodos que manejan peticiones. Estas son
llamadas acciones. Por defecto, cada método público en un controlador es una
acción, y es accesible desde una URL. Una acción es responsable de interpretar
la petición y crear la respuesta. Usualmente las respuestas están en la forma
de vista renderizada, pero también hay otros modos de crear respuestas.
................................................................................

El App Controller
-----------------
La clase AppController es la clase padre de todos sus controladores de aplicación.
AppController mismo extiende la clase Controller incluída en la librería núcleo
de CakePHP. AppController está definia en /app/Controller/AppController.php como
sigue:  

class AppController extends Controller {
}

Los atributos y métodos Controller creados en su AppController estarán disponibles
para todos sus controladores de la aplicación. 

Mientras que las reglas de herencia orientadas a objeto normales aplican, CakePHP
hace trabajo adicional cuando se vienen atributos controlador especiales. Para los 
componentes y helpers usados por un controlador, los arrays de valor AppController
son mergeados con arreglos de clase controlador hijos. Los valores en la clase
hijo siempre redefinirán aquellos en AppController.  

Nota: CakePHP mergea las siguientes variables desde el AppController en sus controladores
de aplicación:

• $components
• $helpers
• $uses

Hay que agregar los helpers de formulario y Html por defecto si uno define la
propiedad $helpers en su AppController.

También llamar a los callbacks de AppController dentro de los callbacks controlador
hijos para mejorar los resultados:

public function beforeFilter() {
  parent::beforeFilter();
}

Parámetros de request
---------------------
Cuando es hecha una petición a una aplicación CakePHP, las clases Router y Dispatcher
de CakePHP usan la configuración de Enrutamiento para hallar y crear el controlador
correcto. Los datos de petición son encapsulados en un objeto request. CakePHP 
pone toda la información de request importante en la propiedad $this->request.

Acciones Controller
-------------------
Las acciones Controller son 

Controller actions are responsible for converting the request parameters into a response for the browser/user
making the request. CakePHP uses conventions to automate this process and remove some boilerplate code
you would otherwise need to write.

By convention, CakePHP renders a view with an inflected version of the action name. Returning to our online
bakery example, our RecipesController might contain the view(), share(), and search() actions.
The controller would be found in /app/Controller/RecipesController.php and contain:

# /app/Controller/RecipesController.php
class RecipesController extends AppController {
  public function view($id) {
    //action logic goes here..
  }
  
  public function share($customerId, $recipeId) {
    //action logic goes here.. 
  }
  
  public function search($query) {
    //action logic goes here..
  }
}


SEGUIR CAP5 (52)  
    
--------------------------------------------------------------------------------

CONFIGURACIÓN DE APACHE HTTP SERVER POR DEFECTO  
===============================================
Win32 (Apache httpd 2.2):

ServerRoot              ::      "C:/Program Files/Apache Software Foundation/Apache2.2"
Config File             ::      "C:/Program Files/Apache Software Foundation/Apache2.2/conf/httpd.conf"
DocumentRoot            ::      "C:/Program Files/Apache Software Foundation/Apache2.2/htdocs"
ErrorLog                ::      "C:/Program Files/Apache Software Foundation/Apache2.2/logs/error.log"
AccessLog               ::      "C:/Program Files/Apache Software Foundation/Apache2.2/logs/access.log"
cgi-bin                 ::      "C:/Program Files/Apache Software Foundation/Apache2.2/cgi-bin/"
binaries (apachectl)    ::      "C:/Program Files/Apache Software Foundation/Apache2.2/bin"

--------------------------------------------------------------------------------
CONFIGURACION DE DB (cakephp-master/app/Config)
===================
class DATABASE_CONFIG {

	public $default = array(
		'datasource' => 'Database/Mysql',
		'persistent' => false,
		'host' => 'localhost',
    'port' => '3306',
		'login' => 'root',
		'password' => '',
		'database' => 'nombredb',
		'prefix' => '',
		//'encoding' => 'utf8',
	);

	public $test = array(
		'datasource' => 'Database/Mysql',
		'persistent' => false,
		'host' => 'localhost',
    'port' => '3306',
		'login' => 'user',
		'password' => 'password',
		'database' => 'test_database_name',
		'prefix' => '',
		//'encoding' => 'utf8',
	);
}


--------------------------------------------------------------------------------
CONFIGURAR HASHES
=================

Notice (1024): Please change the value of 'Security.salt' in APP/Config/core.php to a salt value specific to your application. 
[CORE\Cake\Utility\Debugger.php, line 845]

Antes
	Configure::write('Security.salt', 'DYhG93b0qyJfIxfs2guVoUubWwvniR2G0FgaC9mi');

Ahora
  Configure::write('Security.salt', 'DYhG93b0qyJfIxfs2guVoUubWwvniR2G0FgaMaxi');  

Notice (1024): Please change the value of 'Security.cipherSeed' in APP/Config/core.php to a numeric (digits only) 
seed value specific to your application. [CORE\Cake\Utility\Debugger.php, line 849]

Antes
  Configure::write('Security.cipherSeed', '76859309657453542496749683645');

Ahora
  Configure::write('Security.cipherSeed', '76859309657453542496708011978');    
--------------------------------------------------------------------------------

PLUGIN DEBUGKIT
===============
Clone/Copy the files in this directory into app/Plugin/DebugKit

This can be done with the git submodule command

git submodule add https://github.com/cakephp/debug_kit.git app/Plugin/DebugKit

    Ensure the plugin is loaded in app/Config/bootstrap.php by calling CakePlugin::load('DebugKit');
    Include the toolbar component in your app/Controller/AppController.php:

class AppController extends Controller {
         public $components = array('DebugKit.Toolbar');
}

    Set Configure::write('debug', 1); in app/Config/core.php.
    Make sure to remove the 'sql_dump' element from your layout (usually app/View/Layouts/default.ctp if you want to experience the awesome that is the debug kit SQL log.

Using Composer

Ensure require is present in composer.json. This will install the plugin into Plugin/DebugKit:

{
    "require": {
        "cakephp/debug_kit": "2.2.*"
    }
}

--------------------------------------------------------------------------------  
