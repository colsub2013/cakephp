VISTAS
======
Las vistas son responsables de generar la salida específica requerida para la
petición. Posibles formas:

. HTML
. XML
. JSON
. Archivos de streaming
. Descarga de PDF

CakePHP viene con algunas clases de View incorporadas para manejar los escenarios
de renderización más comunes:

. Para crear web services XML ó JSON puede usar vistas XML ó JSON
. Para servir archivos protegidos, ó archivos generados dinámicamente, puede usar
  Sending files
. Para crear vistas con temas múltiples, puede usar Themes 

Plantillas de Vista
-------------------
Por defecto los archivos de vista de CakePHP están escritos en PHP plano y tienen
extensión .ctp (Plantilla CakePHP). Estos archivos contienen toda la lógica de
presentación necesaria para obtener los datos que este recibió del controlador
en un formato que está listo para la audiencia a la que uno sirve.

Un archivo de vista se almacena en /app/View/, en una subcarpeta nombrada después
del controlador que usa el archivo. Tiene un nombre de archivo correspondiente
a su acción. Ej.: el archivo de vista para la acción 'view()' del controlador de
'Products' se encontraría normalmente en /app/View/Products/view.ctp. 

La capa de vista en CakePHP puede hacerse de un número de partes diferentes:

. Vistas (Views): las Views son parte de la página que es única a la acción que
se está corriendo. Forman la carne de la respuesta de su aplicación.

. Elements: pequeños fragmentos de código de vista reutilizables. Los elementos
son usualmente renderizados dentro de vistas.

. Layouts: archivos de vista que contienen código de presentación que envuelve
varias interfaces en su aplicación. La mayoría de las vistas son renderizadas
dentro de un layout.

. helpers: estas clases encapsulan lógica de vista que es necesaria en varios 
lugares en la capa de vista. Estos pueden ayudar a construir formularios, construir
funcionalidad AJAX, datos de paginación del modelo, ó servir alimentaciones RSS.
  
Extender Vistas
---------------
Las extensiones de Vista le permite envolver una vista en otra. Ej.: su aplicación
tiene una barra lateral que necesita cambiar dependiendo de la vista específica
siendo renderizada. Extender un archivo de vista común, puede evitar repetir
el marcado común para su barra lateral, y sólo definir las partes que cambian:

// app/View/Common/view.ctp
<h1><?php echo $this->fetch(’title’); ?></h1>
<?php echo $this->fetch(’content’); ?>

<div class="actions">
  <h3>Related actions</h3>
  <ul>
    <?php echo $this->fetch(’sidebar’); ?>
  </ul>
</div>

El archivo de vista de arriba podría usarse como una vista padre. Esta espera que
la vista que extiende definirá los bloques de título y barra lateral. El
bloque de contenido contendrá todo el contenido no capturado de la vista que se
extiende. Asumiendo que nuestro archivo de vista tiene una variable $post con los
datos sobre nuestro post, la vista luciría:

<?php
  // app/View/Posts/view.ctp
  $this->extend(’/Common/view’);
  $this->assign(’title’, $post);
  $this->start(’sidebar’);
?>
<li>
  <?php
    echo $this->Html->link(
      ’edit’, array(
        ’action’ => ’edit’,
        $post[’Post’][’id’]
      )
    ); 
  ?>
</li>
<?php $this->end(); ?>
// The remaining content will be available as the ’content’ block
// in the parent view.
<?php echo h($post[’Post’][’body’]);

La vista post de arriba muestra como uno puede extender una vista, y popular un
set de bloques. Cualquier contenido ya no definido en un bloque definido será
capturado y puesto en un bloque especial nombrado 'content'. Cuando una vista
contiene una llamada a extend(), la ejecución continúa hasta el fondo del 
archivo de vista actual. Una vez que este está completo, la vista extendida 
será renderizada. Llamar a extend() más de una vez en un archivo de vista 
redefinirá la vista padre que se procesará luego:

$this->extend(’/Common/view’);
$this->extend(’/Common/index’);

El resultado de arriba resultará en /Common/index.ctp siendo renderizado como 
la vista padre a la vista actual.

Puede anidar vistas extendidas tantas veces como necesite. Cada vista puede 
extender otra vista si se desea. Cada vista padre obtendrá el contenido 
de la vista previa así como el bloque content.

Nota: Debería evitar usar 'content' como un nombre de bloque en su aplicación.
CakePHP lo usa para contenido sin capturar en vistas extendidas.

Usar bloques de vista
---------------------
Los bloques de vista reemplazan $scripts_for_layout y proveen una API flexible
que le permite definir ranuras ó bloques en sus vistas/layouts que serán definidas
en algún lado. Ej.: los bloques son ideales para implementar cosas como barras
laterales, ó regiones para cargar bienes (assets) en el fondo / cima del layout.
Los bloques pueden ser definidos de 2 modos: ya sea como un bloque de captura,
ó por asignación directa. Los métodos start(), append() y end() le permiten 
trabajar con bloques de captura:

// create the sidebar block.
$this->start(’sidebar’);
echo $this->element(’sidebar/recent_topics’);
echo $this->element(’sidebar/recent_comments’);
$this->end();

// Append into the sidebar later on.
$this->append(’sidebar’);
echo $this->element(’sidebar/popular_topics’);
$this->end();

Puede también anexar dentro de un bloque usando start() en múltiples ocasiones.
assign() puede ser usado para limpiar (clear) ó sobreescribir un bloque a la vez:

// Clear the previous content from the sidebar block.
$this->assign(’sidebar’, ’’);

En 2.3, se agregaron métodos nuevos para trabajar con bloques. El método prepend()
se agregó al contenido prepend() para un bloque existente:

// Prepend to sidebar
$this->prepend(’sidebar’, ’this content goes on top of sidebar’);

El método startIfEmpty() puede usarse para iniciar un bloque sólo si este está
vacío ó indefinido. Si el bloque ya existe, el contenido capturado será 
descartado. Esto es útil cuando quiere definir condicionalmente el contenido por
defecto para un bloque si este no existe realmente:
 
// In a view file.
// Create a navbar block
$this->startIfEmpty(’navbar’);
echo $this->element(’navbar’);
echo $this->element(’notifications’);
$this->end();

// In a parent view/layout
<?php $this->startIfEmpty(’navbar’); ?>
<p>If the block is not defined by now - show this instead</p>
<?php $this->end(); ?>
// Somewhere later in the parent view/layout
echo $this->fetch(’navbar’);

En el ej. de arriba, el bloque navbar solo contendrá el contenido agregado en 
la 1er sección. Ya que el bloque fue definido en la vista hijo, el contenido por
defecto con <p> será descartado.

Nota: Debería evitar usar content como un nombre de bloque. Este es usado 
por CakePHP internamente para vistas extendidas, y contenido de vista en el layout.

Exhibir bloques
...............
Puede exhibir bloques con el método fetch(), el cual da salida a un bloque, retornando
'' si un bloque no existe:

echo $this->fetch(’sidebar’);

Puede también usar fetch para mostrar contenido condicionalmente que que debería
rodear un bloque si este existe. Esto es útil en layouts, ó vistas extendidas
donde uno quiere mostrar encabezados ú otro marcado de forma condicional:

// in app/View/Layouts/default.ctp
<?php if ($this->fetch(’menu’)): ?>
  <div class="menu">
    <h3>Menu options</h3>
    <?php echo $this->fetch(’menu’); ?>
  </div>
<?php endif; ?>

Como en 2.3.0, puede también proveer un valor por defecto para un bloque si este
no tienen ningún contenido. Esto le permite agregar contenido de posición 
(placeholder) para estados vacíos. Puede proveer un valor por defecto usando
el 2do argumento:

<div class="shopping-cart">
  <h3>Your Cart</h3>
  <?php echo $this->fetch(’cart’, ’Your cart is empty’); ?>
</div>

El argumento $default se agregó en 2.3.

Using blocks for script and CSS files
-------------------------------------
Los bloques reemplazan la variable de layout $scripts_for_layout deprecada. En
vez de eso debería usar bloques. El HtmlHelper se une en bloques de vista, y sus
métodos script(), css(), y meta() pueden cada uno actualizar un bloque con el 
mismo nombre cuando se usa con la opción inline = false:

<?php
  // in your view file
  $this->Html->script(’carousel’, array(’inline’ => false));
  $this->Html->css(’carousel’, null, array(’inline’ => false));
?>
// In your layout file.
<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <?php echo $this->fetch(’script’); ?>
    <?php echo $this->fetch(’css’); ?>
  </head>
  // rest of the layout follows

El HtmlHelper también le permite controlar a que bloque van los scripts y CSS:

// in your view
$this->Html->script(’carousel’, array(’block’ => ’scriptBottom’));

// in your layout
echo $this->fetch(’scriptBottom’);

Layouts
.......
Un layout contiene código de presentación que se envuelve alrededor de una vista.
Todo lo que querría ver en todas sus vistas debería ponerse en el layout.

El layout por defecto de CakePHP se ubica en /app/View/Layouts/default.ctp. Si
quiere cambiar completamente como se ve su aplicación, empezar con esto, ya que
el código de vista renderizado por controlador se ubica dentro del layout por 
defecto cuando la página es renderizada.

Otros archivos de layout debería ubicarse en /app/View/Layouts. Al crear un layout,
necesita decirle a CakePHP donde poner la salida de sus vistas. Para hacerlo,
asegurarse de que su layout incluya un lugar para $this->fetch(’content’). Ej.
de como debería lucir un layout por defecto:

<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <!-- Include external files and scripts here (See HTML helper for more info.) -->
    <?php
      echo $this->fetch(’meta’);
      echo $this->fetch(’css’);
      echo $this->fetch(’script’);
    ?>
  </head>
  <body>
  <!-- If you’d like some sort of menu to show up on all of your views, include it here -->
    <div id="header">
      <div id="menu">...</div>
    </div>
    <!-- Here’s where I want my views to be displayed -->
    <?php echo $this->fetch(’content’); ?>
    <!-- Add a footer to each displayed page -->
    <div id="footer">...</div>
  </body>
</html>

Nota: fetch(’content’) es un reemplazo para $content_for_layout y las líneas
fetch(’meta’), fetch(’css’) y fetch(’script’) son contenidas en la variable
$scripts_for_layout.

Los bloques script, css y meta contienen cualquier contenido definido en las 
vistas usando el helper HTML incorporado. Útil para incluir archivos CSS y 
Javascript desde vistas.

Nota: Al usar HtmlHelper::css() ó HtmlHelper::script() en archivos de vista,
especificar 'false' para la opción 'inline' para poner la fuente HTML en un 
bloque con el mismo nombre.   

El bloque 'content' contiene los contenidos de la vista renderizada.

$title_for_layout contiene el título de página. Esta variable es generada 
automáticamente, pero uno puede redefinirla fijándola en su controlador / vista.

Fijar el título para el layout es más fácil hacerlo en el controlador, fijando
la variable $title_for_layout:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
  }
}


SEGUIR(91)