VISTAS
======
Las vistas son responsables de generar la salida específica requerida para la
petición. Posibles formas:

. HTML
. XML
. JSON
. Archivos de streaming
. Descarga de PDF

CakePHP viene con algunas clases de View incorporadas para manejar los escenarios
de renderización más comunes:

. Para crear web services XML ó JSON puede usar vistas XML ó JSON
. Para servir archivos protegidos, ó archivos generados dinámicamente, puede usar
  Sending files
. Para crear vistas con temas múltiples, puede usar Themes 

Plantillas de Vista
-------------------
Por defecto los archivos de vista de CakePHP están escritos en PHP plano y tienen
extensión .ctp (Plantilla CakePHP). Estos archivos contienen toda la lógica de
presentación necesaria para obtener los datos que este recibió del controlador
en un formato que está listo para la audiencia a la que uno sirve.

Un archivo de vista se almacena en /app/View/, en una subcarpeta nombrada después
del controlador que usa el archivo. Tiene un nombre de archivo correspondiente
a su acción. Ej.: el archivo de vista para la acción 'view()' del controlador de
'Products' se encontraría normalmente en /app/View/Products/view.ctp. 

La capa de vista en CakePHP puede hacerse de un número de partes diferentes:

. Vistas (Views): las Views son parte de la página que es única a la acción que
se está corriendo. Forman la carne de la respuesta de su aplicación.

. Elements: pequeños fragmentos de código de vista reutilizables. Los elementos
son usualmente renderizados dentro de vistas.

. Layouts: archivos de vista que contienen código de presentación que envuelve
varias interfaces en su aplicación. La mayoría de las vistas son renderizadas
dentro de un layout.

. helpers: estas clases encapsulan lógica de vista que es necesaria en varios 
lugares en la capa de vista. Estos pueden ayudar a construir formularios, construir
funcionalidad AJAX, datos de paginación del modelo, ó servir alimentaciones RSS.
  
Extender Vistas
---------------
Las extensiones de Vista le permite envolver una vista en otra. Ej.: su aplicación
tiene una barra lateral que necesita cambiar dependiendo de la vista específica
siendo renderizada. Extender un archivo de vista común, puede evitar repetir
el marcado común para su barra lateral, y sólo definir las partes que cambian:

// app/View/Common/view.ctp
<h1><?php echo $this->fetch(’title’); ?></h1>
<?php echo $this->fetch(’content’); ?>

<div class="actions">
  <h3>Related actions</h3>
  <ul>
    <?php echo $this->fetch(’sidebar’); ?>
  </ul>
</div>

El archivo de vista de arriba podría usarse como una vista padre. Esta espera que
la vista que extiende definirá los bloques de título y barra lateral. El
bloque de contenido contendrá todo el contenido no capturado de la vista que se
extiende. Asumiendo que nuestro archivo de vista tiene una variable $post con los
datos sobre nuestro post, la vista luciría:

<?php
  // app/View/Posts/view.ctp
  $this->extend(’/Common/view’);
  $this->assign(’title’, $post);
  $this->start(’sidebar’);
?>
<li>
  <?php
    echo $this->Html->link(
      ’edit’, array(
        ’action’ => ’edit’,
        $post[’Post’][’id’]
      )
    ); 
  ?>
</li>
<?php $this->end(); ?>
// The remaining content will be available as the ’content’ block
// in the parent view.
<?php echo h($post[’Post’][’body’]);

La vista post de arriba muestra como uno puede extender una vista, y popular un
set de bloques. Cualquier contenido ya no definido en un bloque definido será
capturado y puesto en un bloque especial nombrado 'content'. Cuando una vista
contiene una llamada a extend(), la ejecución continúa hasta el fondo del 
archivo de vista actual. Una vez que este está completo, la vista extendida 
será renderizada. Llamar a extend() más de una vez en un archivo de vista 
redefinirá la vista padre que se procesará luego:

$this->extend(’/Common/view’);
$this->extend(’/Common/index’);

El resultado de arriba resultará en /Common/index.ctp siendo renderizado como 
la vista padre a la vista actual.

Puede anidar vistas extendidas tantas veces como necesite. Cada vista puede 
extender otra vista si se desea. Cada vista padre obtendrá el contenido 
de la vista previa así como el bloque content.

Nota: Debería evitar usar 'content' como un nombre de bloque en su aplicación.
CakePHP lo usa para contenido sin capturar en vistas extendidas.

Usar bloques de vista
---------------------
Los bloques de vista reemplazan $scripts_for_layout y proveen una API flexible
que le permite definir ranuras ó bloques en sus vistas/layouts que serán definidas
en algún lado. Ej.: los bloques son ideales para implementar cosas como barras
laterales, ó regiones para cargar bienes (assets) en el fondo / cima del layout.
Los bloques pueden ser definidos de 2 modos: ya sea como un bloque de captura,
ó por asignación directa. Los métodos start(), append() y end() le permiten 
trabajar con bloques de captura:

// create the sidebar block.
$this->start(’sidebar’);
echo $this->element(’sidebar/recent_topics’);
echo $this->element(’sidebar/recent_comments’);
$this->end();

// Append into the sidebar later on.
$this->append(’sidebar’);
echo $this->element(’sidebar/popular_topics’);
$this->end();

Puede también anexar dentro de un bloque usando start() en múltiples ocasiones.
assign() puede ser usado para limpiar (clear) ó sobreescribir un bloque a la vez:

// Clear the previous content from the sidebar block.
$this->assign(’sidebar’, ’’);

En 2.3, se agregaron métodos nuevos para trabajar con bloques. El método prepend()
se agregó al contenido prepend() para un bloque existente:

// Prepend to sidebar
$this->prepend(’sidebar’, ’this content goes on top of sidebar’);

El método startIfEmpty() puede usarse para iniciar un bloque sólo si este está
vacío ó indefinido. Si el bloque ya existe, el contenido capturado será 
descartado. Esto es útil cuando quiere definir condicionalmente el contenido por
defecto para un bloque si este no existe realmente:
 
// In a view file.
// Create a navbar block
$this->startIfEmpty(’navbar’);
echo $this->element(’navbar’);
echo $this->element(’notifications’);
$this->end();

// In a parent view/layout
<?php $this->startIfEmpty(’navbar’); ?>
<p>If the block is not defined by now - show this instead</p>
<?php $this->end(); ?>
// Somewhere later in the parent view/layout
echo $this->fetch(’navbar’);

En el ej. de arriba, el bloque navbar solo contendrá el contenido agregado en 
la 1er sección. Ya que el bloque fue definido en la vista hijo, el contenido por
defecto con <p> será descartado.

Nota: Debería evitar usar content como un nombre de bloque. Este es usado 
por CakePHP internamente para vistas extendidas, y contenido de vista en el layout.

Exhibir bloques
...............
Puede exhibir bloques con el método fetch(), el cual da salida a un bloque, retornando
'' si un bloque no existe:

echo $this->fetch(’sidebar’);

Puede también usar fetch para mostrar contenido condicionalmente que que debería
rodear un bloque si este existe. Esto es útil en layouts, ó vistas extendidas
donde uno quiere mostrar encabezados ú otro marcado de forma condicional:

// in app/View/Layouts/default.ctp
<?php if ($this->fetch(’menu’)): ?>
  <div class="menu">
    <h3>Menu options</h3>
    <?php echo $this->fetch(’menu’); ?>
  </div>
<?php endif; ?>

Como en 2.3.0, puede también proveer un valor por defecto para un bloque si este
no tienen ningún contenido. Esto le permite agregar contenido de posición 
(placeholder) para estados vacíos. Puede proveer un valor por defecto usando
el 2do argumento:

<div class="shopping-cart">
  <h3>Your Cart</h3>
  <?php echo $this->fetch(’cart’, ’Your cart is empty’); ?>
</div>

El argumento $default se agregó en 2.3.

Using blocks for script and CSS files
-------------------------------------
Los bloques reemplazan la variable de layout $scripts_for_layout deprecada. En
vez de eso debería usar bloques. El HtmlHelper se une en bloques de vista, y sus
métodos script(), css(), y meta() pueden cada uno actualizar un bloque con el 
mismo nombre cuando se usa con la opción inline = false:

<?php
  // in your view file
  $this->Html->script(’carousel’, array(’inline’ => false));
  $this->Html->css(’carousel’, null, array(’inline’ => false));
?>
// In your layout file.
<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <?php echo $this->fetch(’script’); ?>
    <?php echo $this->fetch(’css’); ?>
  </head>
  // rest of the layout follows

El HtmlHelper también le permite controlar a que bloque van los scripts y CSS:

// in your view
$this->Html->script(’carousel’, array(’block’ => ’scriptBottom’));

// in your layout
echo $this->fetch(’scriptBottom’);

Layouts
.......
Un layout contiene código de presentación que se envuelve alrededor de una vista.
Todo lo que querría ver en todas sus vistas debería ponerse en el layout.

El layout por defecto de CakePHP se ubica en /app/View/Layouts/default.ctp. Si
quiere cambiar completamente como se ve su aplicación, empezar con esto, ya que
el código de vista renderizado por controlador se ubica dentro del layout por 
defecto cuando la página es renderizada.

Otros archivos de layout debería ubicarse en /app/View/Layouts. Al crear un layout,
necesita decirle a CakePHP donde poner la salida de sus vistas. Para hacerlo,
asegurarse de que su layout incluya un lugar para $this->fetch(’content’). Ej.
de como debería lucir un layout por defecto:

<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <!-- Include external files and scripts here (See HTML helper for more info.) -->
    <?php
      echo $this->fetch(’meta’);
      echo $this->fetch(’css’);
      echo $this->fetch(’script’);
    ?>
  </head>
  <body>
  <!-- If you’d like some sort of menu to show up on all of your views, include it here -->
    <div id="header">
      <div id="menu">...</div>
    </div>
    <!-- Here’s where I want my views to be displayed -->
    <?php echo $this->fetch(’content’); ?>
    <!-- Add a footer to each displayed page -->
    <div id="footer">...</div>
  </body>
</html>

Nota: fetch(’content’) es un reemplazo para $content_for_layout y las líneas
fetch(’meta’), fetch(’css’) y fetch(’script’) son contenidas en la variable
$scripts_for_layout.

Los bloques script, css y meta contienen cualquier contenido definido en las 
vistas usando el helper HTML incorporado. Útil para incluir archivos CSS y 
Javascript desde vistas.

Nota: Al usar HtmlHelper::css() ó HtmlHelper::script() en archivos de vista,
especificar 'false' para la opción 'inline' para poner la fuente HTML en un 
bloque con el mismo nombre.   

El bloque 'content' contiene los contenidos de la vista renderizada.

$title_for_layout contiene el título de página. Esta variable es generada 
automáticamente, pero uno puede redefinirla fijándola en su controlador / vista.

Fijar el título para el layout es más fácil hacerlo en el controlador, fijando
la variable $title_for_layout:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
  }
}

Puede también fijar la variable title_for_layout desde dentro del archivo de vista:

$this->set(’title_for_layout’, $titleContent);

Puede crear varios layouts como quiera: sólo ubíquelos en el directorio app/View/Layouts,
e intercambiar entre ellos dentro de sus acciones controlador usando la propiedad
$layout de la vista:

// from a controller
public function admin_view() {
  // stuff
  $this->layout = ’admin’;
}

// from a view file
$this->layout = ’loggedin’;

Ej.: si una sección de mi sitio incluyó un espacio para banner de avisos (ad), puedo
crear un layout nuevo con el menor espacio de publicidad y especificarlo como el
layout para todas las acciones de controlador usando algo como:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
    $this->layout = ’default_small_ad’;
  }

  public function view_image() {
    $this->layout = ’image’;
    //output user image
  }
}

CakePHP tiene 2 layouts núcleo característicos (junto al layout por defecto de
CakePHP) que uno puede usar:

. ‘ajax’: útil para elaboración de respuestas AJAX - es un layout vacío (la
  mayoría de las llamadas AJAX sólo requieren un pequeño marcado en el retorno.
  en vez de una interfaz completamente renderizada).  

. ‘flash’: se usa para mensajes mostrados por el método Controller::flash().

Los otros 3 layouts, xml, js y rss existen en el núcleo para servir contenido 
que no es text/html.

Usar layouts desde plugins
..........................
Si quiere usar un layout que existe en un plugin, puede usar sintaxis de plugin.
Ej.: para usar el layout de contenido desde el plugin Contacts:

class UsersController extends AppController {
  public function view_active() {
    $this->layout = ’Contacts.contact’;
  }
}

Elementos
---------
Algunas aplicaciones tienen pequeños bloques de código de presentación que 
necesitan repetirse de página a página, a veces en lugares diferentes del layout.
CakePHP puede ayudarle a repetir partes de su página web que necesitan reusarse.
Estas partes reutilizables son llamadas 'Elementos'. Avisos, cajas de ayuda,
controles de navegación, menús extra, formularios de login, y callouts son 
con frecuencia implementados en CakePHP como elementos. Los 'Elementos' pueden
usarse para hacer una vista más legible, poniendo el renderizado de repetir 
elementos en su propio archivo. Estos pueden también ayudarlo a reutilizar
fragmentos de contenido en su aplicación.

Los 'Elementos' viven en la carpeta /app/View/Elements/, y tienen la extensión de
archivo .ctp. Son salida usando el método element de la vista:

echo $this->element(’helpbox’);

Pasar variables dentro de un Elemento
.....................................
Puede pasar datos a un elemento a través del 2do argumento del elemento:

echo $this->element(’helpbox’, array(
  "helptext" => "Oh, this text is very helpful."
));

Dentro del archivo elemento, todas las variables pasadas están disponibles como 
miembros del array de parámetro (del mismo modo que Controller::set() en el 
controlador funciona con los archivos de vista). En el ej. de arriba, el archivo
/app/View/Elements/helpbox.ctp puede usar la variable $helptext:

// inside app/View/Elements/helpbox.ctp
echo $helptext; //outputs "Oh, this text is very helpful."

El método View::element() también soporta opciones para el elemento. Las opciones
soportadas son ‘cache’ y ‘callbacks’. Ej.:

echo $this->element(’helpbox’, 
  array(
    "helptext" => "This is passed to the element as $helptext",
    "foobar" => "This is passed to the element as $foobar",
  ),
  array(
    // uses the "long_view" cache configuration
    "cache" => "long_view",
    // set to true to have before/afterRender called for the element
    "callbacks" => true
  )
);

El cacheo de elemento es facilitado a través de la clase Cache. Puede configurar
elementos para ser almacenados en cualquier configuración de Cache que ha 
establecido. Esto le da flexibilidad para decidir donde y por cuanto los elementos
son almacenados. Para cachear versiones diferentes del mismo elemento en una
aplicación, proveer un valor de clave de cache único usando el formato:

$this->element(’helpbox’, array(), array(
  "cache" => array(’config’ => ’short’, ’key’ => ’unique value’)
  )
);

You can take full advantage of elements by using requestAction(), which fetches view variables from
a controller action and returns them as an array. This enables your elements to perform in true MVC style.
Create a controller action that prepares the view variables for your elements, then call requestAction()
inside the second parameter of element() to feed the element the view variables from your controller.

To do this, in your controller add something like the following for the Post example:

class PostsController extends AppController {
  // ...
  public function index() {
    $posts = $this->paginate();
    if ($this->request->is(’requested’)) {
      return $posts;
    } else {
      $this->set(’posts’, $posts);
    }
  }
}

And then in the element we can access the paginated posts model. To get the latest five posts in an ordered
list, we would do something like the following:

<h2>Latest Posts</h2>
<?php
  $posts = $this->requestAction(
    ’posts/index/sort:created/direction:asc/limit:5’
  );
?>
<ol>
<?php foreach ($posts as $post): ?>
<li><?php echo $post[’Post’][’title’]; ?></li>
<?php endforeach; ?>
</ol>

Cachear elementos
.................
Puede tomar ventaja del cacheo de vista de CakePHP si suministra un parámetro de
caché. Si se lo fija a true, cacheará el elemento en la configuración Cache por
'defecto'. Sino, puede setear que configuración de cache debería usarse. Ej. de
cachear un elemento:

echo $this->element(’helpbox’, array(), array(’cache’ => true));

Si renderiza el mismo elemento más de una vez en una vista y tiene el cacheo 
habilitado, fijar el parámetro 'key' a un nombre diferente cada vez. Esto evitará
que cada llamada sucesiva sobreescriba el resultado cacheado de la llamada del
element() previo. Ej.:

echo $this->element(
  ’helpbox’,
  array(’var’ => $var),
  array(’cache’ => array(’key’ => ’first_use’, ’config’ => ’view_long’)
);

echo $this->element(
  ’helpbox’,
  array(’var’ => $differenVar),
  array(’cache’ => array(’key’ => ’second_use’, ’config’ => ’view_long’)
);

Lo de arriba asegurará que ambos resultados element son cacheados de forma
separada. Si quiere que todos los cacheos de elemento usen la misma configuración
de caché, puede evitar alguna repetición fijando View::$elementCache a la 
configuración de caché que quiere usar. CakePHP usará esta configuración 
cuando no se de nada. 

Peticionar elementos desde un plugin
....................................

2.0
...
Para cargar un elemento desde un plugin, usar la opción plugin:

echo $this->element(’helpbox’, array(), array(’plugin’ => ’Contacts’));

2.1
...
Si uno está usando un plugin y desea usar elementos desde dentro del plugin, 
use la sintaxis familiar de plugin. Si la vista está siendo renderizada desde un
controlador / acción plugin, el nombre del plugin será prefijado automáticamente
sobre todos los elementos utilizados, a menos que otro nombre de plugin esté
presente. Si el elemento no existe en el plugin, este mirará en la carpeta 
principal APP:

echo $this->element(’Contacts.helpbox’);

Si su vista es una parte de un plugin, puede omitir el nombre de plugin. Ej.:
si uno está en el ContactsController del plugin Contacts, lo siguiente:

echo $this->element(’helpbox’);
// and
echo $this->element(’Contacts.helpbox’);

es equivalente y resultará en el mismo elemento siendo renderizado.

Cambio en v.2.1: la opción $options[plugin] fue deprecada y se agregó soporte
para Plugin.element.

Crear sus propias clases de vista
---------------------------------
Puede necesitar crear clases de vista personalizadas para habilitar tipos nuevos
de vistas de datos, ó agregar lógica personalizada de renderización de vista 
adicional a su aplicación. Convenciones de clases de vista:

• Los archivos de clase View deberían ponerse en App/View. Ej.: App/View/PdfView.php
• Las clases View deberían tener el sufijo 'View'. Ej.: PdfView.
• Al referenciar nombres de clase de vista debería omitir el sufijo View. Ej.:
  $this->viewClass = ’Pdf’;.

Uno también querrá extender View para asegurarse que las cosas funcionen:

// in App/View/PdfView.php
App::uses(’View’, ’View’);
class PdfView extends View {
  public function render($view = null, $layout = null) {
    // custom logic here.
  }
}

Reemplazar el método 'render' le deja tomar control completo sobre como su 
contenido es renderizado.

API View 
--------
Clase View
..........
Los métodos View son accesibles en todas las vistas, elementos y archivos de 
layout. Para llamar a cualquier método view usar $this->method():

View::set(string $var, mixed $value)
Las Views tienen un método set() que es análogo al set() hallado en objetos Controller.
Usar set() desde su archivo vista agregará las variables al layout y elementos 
que serán posteriormente renderizados.  

En su archivo vista puede hacer:

$this->set(’activeMenuButton’, ’posts’);

En su layout, la variable $activeMenuButton estará disponible y contiene el valor
'posts'.

View::get(string $var, $default = null)
Obtener el valor de una viewVar con el nombre $var.

Puede proveer un valor por defecto en caso que la variable ya no esté fijada.
Cambiado en v.2.5: el argumento $default fue agregado en 2.5.

View::getVar(string $var)
Obtiene el valor del viewVar con el nombre $var.
Deprecado desde v.2.3: usar View::get(). 

View::getVars()
Obtiene una lista de todas las variables de vista disponibles en el ámbito
de renderización actual. Retorna un array de nombre de variables.

View::element(string $elementPath, array $data, array $options = array())
Renderiza un elemento ó vista parcial. 

View::uuid(string $object, mixed $url)
Genera un ID DOM único no aleatorio para un objeto, basado en el tipo de objeto
y URL. Este método se usa con frecuencia por helpers que necesitan generar 
ID's de DOM únicos para elementos como el JsHelper:

$uuid = $this->uuid(
  ’form’,
  array(’controller’ => ’posts’, ’action’ => ’index’)
);
//$uuid contains ’form0425fe3bad’

View::addScript(string $name, string $content)
Agrega contenido al buffer de scripts interno. Este buffer es hecho disponible
en el layout como $scripts_for_layout. Este método es útil al crear helpers
que necesitan agregar javascript ó css directamente al layout. Los scripts
agregados desde el layout y elementos en el layout no serán agregados a 
$scripts_for_layout. Este método se usa con frecuencia desde dentro de helpers,
como helpers JsHelper y HtmlHelper. Deprecado en v.2.1. 

View::blocks()
Obtiene los nombres de todos los bloques definidos como un array.

View::start($name)
Comienzan un bloque de captura para un bloque de vista. 
Nuevo en v.2.1.

View::end()
Finaliza el bloque de captura más abierto en la parte superior.
Nuevo en v.2.1.

View::append($name, $content)
Agregado al bloque con $name. 
Nuevo en v.2.1.

View::prepend($name, $content)
Anteponer al bloque con $name. 
Nuevo en v.2.3.

View::startIfEmpty($name)
Inicia un bloque si este está vacío. Todo el contenido en el bloque será capturado
y descartado si el bloque ya está definido.
Nuevo en v.2.3.

View::assign($name, $content)
Asigna el valor de un bloque. Esto sobreescribirá cualquier contenido existente.
Nuevo en v.2.1.

View::fetch($name, $default = ‘’)
Extrae el valor de un bloque. Si un bloque está vacío ó indefinido, se retornará ''.
Nuevo en v.2.1.

View::extend($name)
Extiende el view/element/layout actual con el nombrado (en argumento). 
Nuevo en v.2.1.

property View::$layout
Fija al layout la vista actual que será contenida (wrapped in).

property View::$elementCache
La configuración de caché usada para elementos de caché. Fijar esta propiedad
cambiará la configuración por defecto usada para elementos de caché. Este 
valor por defecto puede ser redefinido usando la opción 'cache' en el método
element.

property View::$request
Una instancia de CakeRequest. Usar esta instancia para acceder a información sobre
la petición actual.

property View::$output
Contiene el último contenido renderizado desde una vista, ya sea el archivo de
vista, ó el contenido de layout. Deprecado en v.2.1: Usar 
$view->Blocks->get(’content’); en lugar de eso.

property View::$Blocks
Una instancia de ViewBlock. Usada para proveer funcionalidad de bloque de vista
en la renderización de la vista.
New in version 2.1.

Más sobre vistas
----------------

Temas (Themes)
..............
Puede tomar ventaja de temas, haciendo fácil intercambiar el look and feel de 
su página rápido y fácil.

Para usar temas, especificar el nombre de tema en su controlador:

class ExampleController extends AppController {
  public $theme = ’Example’;
}

Cambiado en v.2.1: las versiones anteriores a 2.1 requirieron fijar 
$this->viewClass = ’Theme’. 2.1 quita este requerimiento como ya que la 
clase View normal soporta themes.

Puede también fijar ó cambiar el nombre de theme dentro de una acción ó dentro
las funciones de callback beforeFilter ó beforeRender:

$this->theme = ’AnotherExample’;

Los archivos de vista necesitan estar en la carpeta /app/View/Themed/. Dentro de
la carpeta themed, crear una carpeta usando el mismo nombre que su nombre de 
theme. Ej.: el theme de arriba debería ser hallado en /app/View/Themed/AnotherExample.
CakePHP espera nombres de theme en camel case. Mas allá de eso, la estructura
de carpeta dentro de /app/View/Themed/Example/ es exactamente la misma que
/app/View/.  

Ej.: el archivo de vista para una acción de edit de un controlador Posts debería
residir en /app/View/Themed/Example/Posts/edit.ctp. Los archivos de layout 
deberían residir en /app/View/Themed/Example/Layouts/.

Si un archivo de vista no puede hallarse en theme, CakePHP intentará ubicar el
archivo de vista en la carpeta /app/View/. Así, puede crear archivos de vista
maestros y redefinirlos en una base caso por caso dentro de su carpeta theme.

Haberes (assets) de Theme
.........................
Los themes pueden contener haberes estáticos así como archivos de vista. Un theme
puede incluir cualquiera de los haberes necesarios en su directorio webroot. Esto
le permite un empaquetado y distribución de themes sencillo. En desarrollo, las
peticiones para los haberes de theme serán manejadas por el Dispatcher. Para
mejorar la performance en producción, se recomienda symlink ó copiar haberes de
theme en en el webroot de la aplicación.  

Para usar el webroot theme nuevo crear directorios como:

app/View/Themed/<themeName>/webroot<path_to_file>

en su theme. El Dispatcher lo manejará hallando los haberes de theme correctos
en sus rutas de vista.

Todos los helpers incorporados de CakePHP son conscientes de themes y crearán
las rutas correctas de forma automática. Como los archivos de vista, si un 
archivo no está en la carpeta theme, será por defecto en la carpeta principal webroot:

//When in a theme with the name of ’purple_cupcake’
$this->Html->css(’main.css’);

//creates a path like
/theme/purple_cupcake/css/main.css

//and links to
app/View/Themed/PurpleCupcake/webroot/css/main.css

Increasing performance of plugin and theme assets

It’s a well known fact that serving assets through PHP is guaranteed to be slower than serving those assets
without invoking PHP. And while the core team has taken steps to make plugin and theme asset serving
as fast as possible, there may be situations where more performance is required. In these situations it’s
recommended that you either symlink or copy out plugin/theme assets to directories in app/webroot
with paths matching those used by CakePHP.

• app/Plugin/DebugKit/webroot/js/my_file.js se vuelve app/webroot/debug_kit/js/my_file.js

• app/View/Themed/Navy/webroot/css/navy.css se vuelve app/webroot/themed/Navy/css/navy.css

Media Views
-----------

clase MediaView
...............
Deprecado en v.2.3: Usar en vez de eso 'Enviar Archivos'.

Media views le permite enviar archivos binarios al usuario. Ej.: puede desear
tener un directorio de archivos fuera de webroot para evitar a los usuarios
de enlazarlos directamente. Puede usar el Media view para extraer (pull) el 
archivo desde dentro de una carpeta /app/, permitiéndole realizar autenticación
antes de entregar el archivo al usuario.

Para usar el Media view, necesita decirle a su controlador de usar la clase
MediaView en vez de la clase View por defecto. Después de eso, sólo pasar 
parámetros adicionales para especificar donde está ubicado su archivo:

class ExampleController extends AppController {
  public function download() {
    $this->viewClass = ’Media’;
    // Download app/outside_webroot_dir/example.zip
    $params = array(
      ’id’ => ’example.zip’,
      ’name’ => ’example’,
      ’download’ => true,
      ’extension’ => ’zip’,
      ’path’ => APP . ’outside_webroot_dir’ . DS
    );
    $this->set($params);
  }
}

Ej. de renderizar un archivo cuyo mime type no está incluido en el array $mimeType
de MediaView. Estamos también usando una ruta relativa que estará por defecto 
en su carpeta app/webroot:

public function download() {
  $this->viewClass = ’Media’;
  // Render app/webroot/files/example.docx
  $params = array(
    ’id’ => ’example.docx’,
    ’name’ => ’example’,
    ’extension’ => ’docx’,
    ’mimeType’ => array(
      ’docx’ => ’application/vnd.openxmlformats-officedocument’ .
      ’.wordprocessingml.document’
    ),
    ’path’ => ’files’ . DS
  );
  $this->set($params);
}

Parámetros ajustables (settables)
---------------------------------
id La ID es el nombre de archivo ya que este reside en el servidor de archivo 
   incluyendo la extensión de archivo

name El nombre le permite especificar un nombre de archivo alternativo para ser
     enviado al usuario. Especificar el nombre sin la extensión de archivo
     
download Un valor boolean que indica si los headers deberían ser fijados a 
         forzar la descarga
         
extension La extensión de archivo. Este es emparejado contra una lista interna de
          mime types aceptables. Si el mime type especificado no está en la lista
          (ó enviado en el array de parámetro mimeType), el archivo no será
          descargado
                    
path El nombre de carpeta, incluyendo el separador de directorio final. La ruta
     debería ser absoluta pero puede ser relativa a la carpeta app/webroot
      

mimeType Un array con mime types adicionales a ser mergeados con la lista interna
         MediaView de mime types aceptables

cache Un valor boolean ó Integer - si se fija a true le permitirá a los navegadores
      cachear el archivo (por defecto en false si no está seteado); de otro modo
      fijar este al número de segundos en el futuro para cuando la caché 
      debería expirar

Vistas JSON y XML
=================
Nuevo en CakePHP 2.1 hay 2 nuevas clases de vista. XmlView y JsonView le dejan
crear respuestas XML y JSON fácilmente, e integrarlas con el RequestHandlerComponent.  

Habilitando RequestHandlerComponent en su aplicación, y habilitando soporte 
para las extensiones xml y json, puede impulsar las clases de vista nuevas 
automáticamente. XmlView y JsonView serán referidas como vistas de datos para 
el resto de esta página.

Hay 2 formas que puede generar vistas de datos. La 1ra es usar la clave _serialize,
y la 2da es crear archivos de vista normales.

Habilitar vistas de datos en su aplicación
------------------------------------------
Antes de que pueda usar las clases vista de datos, necesita cierta configuración:

1. Habilitar las extensiones json y/ó xml con Router::parseExtensions(). Esto
   habilitará a Router manejar extensiones múltiples

2. Agregar el RequestHandlerComponent a su lista de componentes de su controlador.
   Esto habilitará conmutación de la clase de vista sobre content types de forma
   automática. Puede también configurar el componente con la configuración    
   viewClassMap, para mapear tipos a sus clases personalizadas y/ó mapear otros
   tipos de datos
   
Nuevo en v.2.3: el método RequestHandlerComponent::viewClassMap() ha sido agregado
a tipos de mapeo para viewClasses. La configuración viewClassMap no funcionará
en versiones anteriores.

Después de agregar Router::parseExtensions(’json’); a su archivo de rutas, 
CakePHP conmutará automáticamente clases de vista cuando una petición es hecha 
con la extensión .json, ó el Accept header es application/json.

Usar vistas de datos con la clave serialize
-------------------------------------------
La clave _serialize es una variable de vista especial que indica que otras 
variable(s) de vista deberían ser serializadas al usar una vista de datos.
Esto le deja saltar definir archivos de vista para sus acciones controlador si
no necesita hacer cualquier formateo personalizado antes de que sus datos
sean convertidos en json/xml.

Si necesita hacer cualquier formateo ó manipulación de sus variables de vista
antes de generar la respuesta, debería usar archivos de vista. El valor de 
_serialize puede ser ya sea un string ó un array de variables de vista a 
serializar:
 
class PostsController extends AppController {
  public $components = array(’RequestHandler’);
  public function index() {
    $this->set(’posts’, $this->paginate());
    $this->set(’_serialize’, array(’posts’));
  }
}

Uno puede también definir _serialize como un array de variables de vista a combinar:

class PostsController extends AppController {
  public $components = array(’RequestHandler’);
  public function index() {
    // some code that created $posts and $comments
    $this->set(compact(’posts’, ’comments’));
    $this->set(’_serialize’, array(’posts’, ’comments’));
  }
}

Definir _serialize como un array tiene el beneficio agregado de anexar automáticamente
un elemento de <response> de nivel superior al usar XmlView. Si uno usa un valor
string para _serialize y XmlView, asegurarse que su variable de vista tiene un
elemento de nivel superior único. Sin un elemento de nivel superior único el Xml
fallará en generarse.

Usar una vista de datos con archivos de vista
---------------------------------------------
Uno debería usar archivos de vista si necesita hacer alguna manipulación de su 
contenido de vista antes de crear la salida final. Por ej. si tuvimos posts, 
que tenía un archivo conteniendo el HTML generado, probablemente querríamos
omitir eso desde una respuesta JSON. Esta es una situación donde un archivo de
vista sería útil:

// Controller code
class PostsController extends AppController {
  public function index() {
    $this->set(compact(’posts’, ’comments’));
  } 
}

// View code - app/View/Posts/json/index.ctp
foreach ($posts as &$post) {
  unset($post[’Post’][’generated_html’]);
}
echo json_encode(compact(’posts’, ’comments’));

Nota: Las clases de vista de datos no soportan layouts. Ellas asumen que el archivo
de vista producirá (output) el contenido serializado.

Clase XmlView
.............
Una clase de vista para generar datos de vista Xml. Por defecto al usar _serialize 
el XmlView envolverá sus variables de vista serializadas con un nodo <response>.
Puede fijar un nombre personalizado para este nodo usando la variable de vista
_rootNode. Nuevo en v.2.3: se agregó la característica _rootNode.

Clase JsonView
..............
Una clase de vista para generar datos de vista JSON. 

Response JSONP 
--------------
Nuevo en v.2.4.

Al usar JsonView puede usar la variable de vista especial _jsonp para habilitar
retornar una respuesta JSONP. Fijarla a true hace a la clase de vista chequear si
el parámetro query string nombrado 'callback' está fijado y si lo está envolver
la respuesta json en el nombre de función provisto. Si uno quiere usar un 
nombre de parámetro query string personalizado en vez de 'callback' fijar _jsonp
al nombre requerido en vez de true.

Helpers
-------
Los Helpers son clases como-componente para la capa de presentación de su 
aplicación.

CakePHP emite un número de helpers para ayudan en la creación de la vista. Ayudan
en crear marcado bien formado (incluyendo formularios), auxilio en texto 
de formato, tiempos y números, y pueden aún acelerar la funcionalidad AJAX.

CacheHelper
-----------
class CacheHelper(View $view, array $settings = array())
........................................................
El Cache helper ayuda en cachear layouts y vistas enteros, ahorrando tiempo
en recobrar datos repetitivos. El caching de View en CakePHP almacena layouts y
vistas parseados temporalmente como archivos PHP + HTML simples. Cache Helper
funciona bastante diferente que otros helpers. Este no tiene métodos que son
llamados directamente. En vez de eso, una vista es marcada con etiquetas de 
cache que indican que bloques de contenido no deberían ser cacheados. El 
CacheHelper usa luego callbacks helper para procesar el archivo y salida para
generar el archivo de cache.

Peticionada una URL, CakePHP chequea para ver si el string de petición ya ha
sido cacheado. Si lo tiene, el resto del proceso de dispatching de URL es 
salteado. Cualquiera de los bloque nocache son procesados normalmente y la vista
es servida. Esto crea grandes ahorros en tiempo de procesamiento para cada 
petición a una URL cacheada a medida que es ejecutado el código mínimo. Si 
CakePHP no halla una vista cached, ó la caché ha expirado para la URL peticinada
esta continúa para procesar la petición normalmente.

Usar el Helper
--------------
Pasos a tomar antes de usar CacheHelper: en su APP/Config/core.php descomentar 
la llamada a escritura Configure para Cache.check. Esto le dirá a CakePHP que
chequee, y genere archivos de cache de vista al manejar peticiones.

Una vez que ha descomentado la línea Cache.check necesitará agregar el helper a 
su array $helpers del controlador:

class PostsController extends AppController {
  public $helpers = array(’Cache’);
}

Uno también necesitará agregar el CacheDispatcher a sus filtros de dispatcher en
su boostrap:

Configure::write(’Dispatcher.filters’, array(
  ’CacheDispatcher’
));

Nuevo en v.2.3: Si tiene una configuración con múltiples dominios ó lenguajes uno
puede usar Configure::write(‘Cache.viewPrefix’, ‘YOURPREFIX’); para almacenar
los archivos cache de vista prefijados.

Las opciones de configuración adicionales de CacheHelper tienen algunas opciones
de configuración adicionales que puede usar para sintonizar y ajustar su 
comportamiento. Esto es hecho a través de la variable $cacheAction en sus 
controladores. $cacheAction debería ser fijado a un array que contiene las 
acciones que quiere cacheadas, y la duración en segundos en que quiere esas 
vistas cacheadas. El valor de tiempo puede ser expresado en un formato strtotime()
('1 hour' ó '3 minutes').
  
Usando el ej. de un ArticlesController, que recibe un montón de tráfico que 
necesita ser cacheado:

public $cacheAction = array(
  ’view’ => 36000,
  ’index’ => 48000
);

Esto cacheará la acción de vista 10 horas, y la acción de index 13 horas. Haciendo
a $cacheAction un valor amigable con strtotime() puede cachear cada acción en el
controlador:

public $cacheAction = "1 hour";

Puede también habilitar callbacks controlador/componente para vistas cacheadas
creadas con CacheHelper. Para hacerlo debe usar el formato array para $cacheAction
y crear un array como el siguiente:

public $cacheAction = array(
  ’view’ => array(’callbacks’ => true, ’duration’ => 21600),
  ’add’ => array(’callbacks’ => true, ’duration’ => 36000),
  ’index’ => array(’callbacks’ => true, ’duration’ => 48000)
);

Fijar callbacks => true le dice a CacheHelper que uno busca que los archivos 
generados creen los componentes y modelos para el controlador. Adicionalmente, 
disparar el componente initialize, beforeFilter del controlador, y callbacks
de startup de componente.

Nota: Fijar callbacks => true derrota en parte al propósito de cacheo. Esta es
también la razón de que está inhabilitado por defecto.

Marcar Non-Cached Content en Views
----------------------------------
Hay veces que no no quiere que la vista entera sea cacheada. Ej.: ciertas partes
de la página pueden lucir diferente si un usuario es actualmente logueado ó 
navegando su sitio como invitado.

Para indicar los bloques de contenido que no van a cachearse, envolverlos en 
<!--nocache--> <!--/nocache--> como:

<!--nocache-->
<?php if ($this->Session->check(’User.name’)): ?>
  Welcome, <?php echo h($this->Session->read(’User.name’)); ?>.
<?php else: ?>
  <?php echo $this->Html->link(’Login’, ’users/login’); ?>
<?php endif; ?>
<!--/nocache-->

Nota: no puede usar etiquetas 'nocache' en elementos. Ya que no hay callbacks
alrededor de elementos, ellos no pueden ser cacheados.

Cacheada una acción, el método controlador para la acción no será llamado. Cuando
es creado un archivo de cache, el objeto request, y las variables de vista son
serializadas con serialize() de PHP.

Advertencia: Si tiene variables de vista que contienen contenido no serializable
como objetos SimpleXML, manejos de recurso, ó cierres (closures) uno puede no ser
capaz de usar caching de vista.

Limpiar (clearing) la Cache
---------------------------
CakePHP limpiará una vista cacheada si un modelo usando en la vista cached es
modificado. Ej.: si una vista cacheada usa datos desde el modelo Post, y ha 
habido una consulta INSERT, UPDATE ó DELETE hecha a un Post, la cache para esa
vista es limpiado, y es generado contenido nuevo en la siguiente petición.

Nota: Esta limpieza de cache automática requiere que el nombre de controlador /
modelo sea parte de la URL. Si ha usado enrutamiento para cambiar sus URL's esta
característica no funcionará.

Si necesita limpiar la cache manualmente, puede hacerlo llamando a Cache::clear().
Esto limpiará todos los datos cacheados, excluyendo archivos de vista cacheados.
Si necesita borrar los archivos de vista cacheados, usar clearCache().

FormHelper
----------
clase FormHelper(View $view, array $settings = array())
.......................................................
FormHelper hace la mayoría del levantamiento pesado en la creación del formulario.
FormHelper se enfoca en crear formularios rápidamente, en un modo que tendrá
validación streamline, re-populación y layout. FormHelper hará casi todo lo 
usando convenciones, ó puede especificar métodos para obtener sólo lo que necesita.

Crear Formularios
-----------------
El 1er método que usar para tomar ventaja del FormHelper es create(). Este método
produce la apertura de una etiqueta 'form'.

FormHelper::create(string $model = null, array $options = array())
..................................................................
Todos los parámetros son opcionales. Si create() es llamado sin parámetros 
suministrados, este asume que uno está construyendo un formulario que se envía
al controlador actual, vía la URL actual. El método por defecto para envío de
formulario es POST. El elemento 'form' es también retornado con un ID de DOM.
El ID es generado usando el nombre del modelo, y el nombre de la acción controlador,
en camel case. Si fuese a llamar a create() dentro de una vista UsersController,
se vería algo como la siguiente salida en la vista renderizada:

<form id="UserAddForm" method="post" action="/users/add">

Nota: Puede también pasar false para $model. Esto ubicará sus datos de formulario
en el array: $this->request->data (en vez de en el sub-array: 
$this->request->data[’Model’]). Esto es útil para formularios cortos que pueden
no representar nada en su DB.

El método create() no permite personalizar mucho más usando los parámetros,
sin embargo. Primero, puede especificar un nombre de modelo. Especificando un 
modelo para un formulario, uno está creando aquel contexto del formulario. Todos
los campos se asumen a pertenecer a este modelo (a menos que se especifique otro),
y todos los modelos referenciados son asumidos a ser asociados con este. Si no
especifica un modelo, este asume que uno está usando el modelo por defecto para el
controlador actual:

// If you are on /recipes/add
echo $this->Form->create(’Recipe’);

Produce:

<form id="RecipeAddForm" method="post" action="/recipes/add">

Esto hará un POST de los datos de formulario para la acción add() de RecipesController.
Pero, puede también usar la misma lógica para crear la edición de un formulario.
FormHelper usa la propiedad $this->request->data para detectar automáticamente
si crear un formulario de 'Agregar' ó 'Editar'. Si $this->request->data contiene
un elemento array nombrado después del modelo de formulario, y ese array contiene
un valor no vacío de la clave primaria del modelo, FormHelper creará un formulario
de 'Editar' para ese registro. Ej.: si navegamos a http://site.com/recipes/edit/5,
obtendríamos lo siguiente:

// Controller/RecipesController.php:
public function edit($id = null) {
  if (empty($this->request->data)) {
    $this->request->data = $this->Recipe->findById($id);
  } else {
    // Save logic goes here
  }
}

// View/Recipes/edit.ctp:
// Since $this->request->data[’Recipe’][’id’] = 5,
// we will get an edit form
<?php echo $this->Form->create(’Recipe’); ?>

Salida:

<form id="RecipeEditForm" method="post" action="/recipes/edit/5">
<input type="hidden" name="_method" value="PUT" />

Nota: Dado que este es un formulario de edición, es generado un campo input hidden
para redefinir el método HTTP por defecto.

Al crear formularios para modelos en plugins, siempre debería usar sintaxis de 
plugin al crear un formulario. Esto asegurará que el formulario es generado
correctamente:

echo $this->Form->create(’ContactManager.Contact’);

El array $options es donde ocurre la mayoría de la configuración del formulario.
Este array especial puede contener un número de pares clave-valor diferentes
que afectan el modo que la etiqueta 'form' es generada.

Cambiado en v.2.0: La URL por defecto para todos los formularios, es ahora la 
URL actual incluyendo los parámetros query string, nombrado y pasado. Puede 
redefinir este valor por defecto suministrando $options[’url’] en el 2do 
parámetro de $this->Form->create().

Opciones para create(): Hay un número de opciones para create(): 
......................

• $options[’type’] 
  ////////////////
Clave que se usa para especificar el tipo de formulario a ser creado. 
Valores válidos incluyen ‘post’, ‘get’, ‘file’, ‘put’ y ‘delete’. 

Suministrar ya sea 'post' ó 'get' cambia el método de envío del fomulario de 
forma acorde:

echo $this->Form->create(’User’, array(’type’ => ’get’));

Produce:

<form id="UserAddForm" method="get" action="/users/add">

Especificar 'file' cambia el método de envío del formulario a 'post', e incluye
un tipo de encriptación de 'multipart/form-data' en la etiqueta 'form'. Esto está
para ser usado si hay cualquiera de los elementos file dentro del formulario. La
ausencia del atributo enctype apropiado originará que la subida de archivos no
funcione:

echo $this->Form->create(’User’, array(’type’ => ’file’));

Salida:

<form id="UserAddForm" enctype="multipart/form-data" method="post" action="/users/add">

Al usar 'put' ó 'delete', su formulario será funcionalmente equivalente a un 
formulario 'post', pero cuando es enviado, el método de petición HTTP será 
redefinido con 'PUT' or 'DELETE', respectivamente. Esto le permite a CakePHP 
emular el soporte REST apropiado en navegadores web.

• $options[’action’] 
  //////////////////
La clave 'action' le permite apuntar el formulario a una acción específica en su
controlador actual. Ej.: si uno querría apuntar el formulario a la acción login()
del controlador actual, uno debería suministrar un arrray $options como el que
sigue:

echo $this->Form->create(’User’, array(’action’ => ’login’));

Salida:

<form id="UserLoginForm" method="post" action="/users/login">

• $options[’url’] 
  ///////////////
Si la acción de formulario deseada no está en el controlador actual, puede 
especificar una URL para la acción de formulario usando la clave 'url' del array
$options. La URL suministrada puede ser relativa a su aplicación CakePHP:

echo $this->Form->create(null, array(
  ’url’ => array(’controller’ => ’recipes’, ’action’ => ’add’)
));

Produce:

<form method="post" action="/recipes/add">

ó puede apuntar a un dominio externo:

echo $this->Form->create(null, array(
  ’url’ => ’http://www.google.com/search’,
  ’type’ => ’get’
));

Produce:

<form method="get" action="http://www.google.com/search">

También chequear el método HtmlHelper::url() para más ejemplos de diferentes
tipos de URL's.

• $options[’default’]
  ///////////////////
Si 'default' ha sido fijado a boolean false, la acción de submit del formulario
es cambiada tal que presionar el botón 'Submit' no envía el formulario. Si el 
formulario se presume enviar vía AJAX, fijar 'default' a false suprime el 
comportamiento por defecto del formulario así uno puede agarrar los datos y 
enviarlos vía AJAX en su lugar.

• $options[’inputDefaults’] 
  /////////////////////////
Puede declarar un set de opciones por defecto para input() con la clave
inputDefaults para personalizar su creación de input por defecto:

echo $this->Form->create(’User’, 
  array(
    ’inputDefaults’ => array(
      ’label’ => false,
      ’div’ => false
    )
  )
);

Todas las entradas creadas desde ese punto hacia adelante heredan las opciones
declaradas en inputDefaults. Puede redefinir defaultOptions declarando la opción
en la llamada a input():

echo $this->Form->input(’password’); // No div, no label
// has a label element
echo $this->Form->input(
  ’username’,
  array(’label’ => ’Username’)
);

Cerrar el Formulario
--------------------
FormHelper::end($options = null, $secureAttributes = array())
.............................................................
FormHelper incluye un método end() que completa el formulario. Con frecuencia, 
end() sólo produce una etiqueta 'form' de cierre, pero usar end() también 
permite a FormHelper insertar elementos form hidden necesarios que requiere 
SecurityComponent:

<?php echo $this->Form->create(); ?>
<!-- Form elements go here -->
<?php echo $this->Form->end(); ?>

Si un string es suministrado como el 1er parámetro para end(), FormHelper produce
un botón de submit nombrado de acuerdo con la etiqueta de cierre del formulario:

<?php echo $this->Form->end(’Finish’); ?>

Producirá:

<div class="submit">
  <input type="submit" value="Finish" />
</div>
</form>

Puede especificar ajustes de detalle pasando un array a end():

$options = array(
  ’label’ => ’Update’,
  ’div’ => array(
    ’class’ => ’glass-pill’,
  )
);
echo $this->Form->end($options);

Producirá:

<div class="glass-pill"><input type="submit" value="Update" name="Update">
</div>

Nota: Si está usando SecurityComponent en su aplicación debería siempre finalizar
sus formularios con end().

El parámetro $secureAttributes fue agregado en v.2.5.

Crear elementos de formulario
-----------------------------
Hay varios modos de crear inputs de formulario con el FormHelper. Se arrancará
mirando a input(). Este método inspeccionará automáticamente el campo modelo que
ha sido suministrado para crear un input apropiado para ese campo. Internamente
input() se delega a otros métodos en FormHelper.

FormHelper::input(string $fieldName, array $options = array())
..............................................................
Crea los siguientes elementos dado un Model.field particular:

• Envolver div
• Elemento label
• Elemento(s) input
• Elemento error con mensaje si es aplicable

El tipo de input creado depende del tipo de dato de la columna:

Tipo de Columna: Campo de formulario resultante
:::::::::::::::

String (char, varchar, etc.): Texto
:::::::::::::::::::::::::::

Boolean, tinyint(1): Checkbox
:::::::::::::::::::

text: textarea
::::

text, with name of password, passwd, or psword: password
::::::::::::::::::::::::::::::::::::::::::::::

text, with name of email: email
::::::::::::::::::::::::

text, with name of tel, telephone, or phone: teléfono
:::::::::::::::::::::::::::::::::::::::::::

date: selecciones de día, mes y año
::::

datetime, timestamp: día, mes, año, hora, minuto, y selección de meridiano tiempo, hora, minuto y selección de meridiano 
:::::::::::::::::::

binary: archivo
::::::

La opción $options le permite personalizar como trabaja input(), y controlar
finamente que es generado. El div envolvente tendrá un nombre de clase requerido
anexado si las reglas de validación para el campo del Model no especifica
allowEmpty => true. Una limitación de este comportamiento es que el modelo del
campo debe haber sido cargado durante su petición. O ser directamente asociado
al modelo suministrado a create().

Nuevo en v.2.5: El tipo binario ahora mapea a un input file.

Desde v.2.3 el atributo 'required' de HTML5 también será añadido al input basado
en reglas de validación. Puede fijar explícitamente la clave requerida en el array
options para redefinirlo para un campo. Para saltear validación de navegador 
disparando el formulario entero uno puede fijar la opción ’formnovalidate’ => true
para el botón input que uno genera usando FormHelper::submit() ó fijar ’novalidate’ => true 
en opciones para FormHelper::create().    
 
Ej.: se asume que su modelo User incluye campos para un nombre de usuario (varchar),
password (varchar), aprobado (datetime) y cita (text). Puede usar el método input()
del FormHelper para crear inputs apropiados para estos campos de formulario:

echo $this->Form->create();
echo $this->Form->input(’username’); //text
echo $this->Form->input(’password’); //password
echo $this->Form->input(’approved’); //day, month, year, hour, minute,
//meridian
echo $this->Form->input(’quote’); //textarea
echo $this->Form->end(’Add’);

Ej. mas extensivo mostrando algunas opciones para un campo date:

echo $this->Form->input(’birth_dt’, 
  array(
    ’label’ => ’Date of birth’,
    ’dateFormat’ => ’DMY’,
    ’minYear’ => date(’Y’) - 70,
    ’maxYear’ => date(’Y’) - 18,
  )
);

Junto a las opciones específicas para input() hallado abajo, puede especificar
cualquier opción para el tipo input y cualquier atributo HTML (por ej. onfocus).

Se asume que User hasAndBelongsToMany Group. En su controlador, fijar una 
variable plural en camelCase (group -> groups en este caso, ó 
ExtraFunkyModel -> extraFunkyModels) con las opciones de selección. En la acción
controlador uno pondría lo siguiente:

$this->set(’groups’, $this->User->Group->find(’list’));

Y en la vista puede ser creada una selección múltiple con este código:

echo $this->Form->input(’Group’);

Si quiere crear un campo de selección mientras usa una Relación belongsTo - ó
hasOne, puede agregar lo siguiente a su controlador Users (asumiendo que 
User belongsTo Group):

$this->set(’groups’, $this->User->Group->find(’list’));

Más tarde, agregar los siguiente a su vista de formulario:

echo $this->Form->input(’group_id’);

Si su nombre de modelo consiste de 2 ó más palabras, ej., “UserGroup”, al pasar
los datos usando set() uno debería nombrar sus datos en formato pluralizado y 
camelCase como sigue:

$this->set(’userGroups’, $this->UserGroup->find(’list’));
// or
$this->set(
  ’reallyInappropriateModelNames’,
  $this->ReallyInappropriateModelName->find(’list’)
);

Nota: Evitar usar FormHelper::input() para generar botones de submit. Usar en
vez de eso FormHelper::submit().

FormHelper::inputs(mixed $fields = null, array $blacklist = null, $options = array())
.....................................................................................
Genera un set de inputs para $fields. Si $fields es null todos los campos del 
modelo actual, excepto para aquellos definidos en $blacklist, serán usados.

Adicionalmente a la salida de campos controlador, $fields puede ser usado para 
controlar renderización de legend y fieldset con las claves fieldset y legend.
$this->Form->inputs(array(’legend’ => ’My legend’)); generaría un set input con 
un legend personalizado. Puede personalizar inputs individuales también a través
de $fields:
 
echo $this->Form->inputs(
  array(
    ’name’ => array(’label’ => ’custom label’)
  )
);

Adicionalmente al control fields, inputs() le permite usar algunas opciones 
adicionales:

•fieldset: Se fija a false para inhabilitar el fieldset. Suministrado un string
 este será usado como el nombre de clase para el elemento fieldset
  
•legend: Se fija a false para inhabilitar el legend para el set input generado.
O suministrar un string para personalizar el texto del legend

Convenciones de nombramiento del campo 
......................................
Siempre que uno especifique un nombre de campo con los métodos form helper, este
usará automáticamente el nombre de modelo actual para construir un input con un 
formato como el que sigue:

<input type="text" id="ModelnameFieldname" name="data[Modelname][fieldname]">

Esto le permite omitir el nombre de modelo al generar inputs para el modelo para
el que fue creado el formulario. Puede crear inputs para modelos asociados, 
ó modelos arbitrarios pasando Modelname.fieldname como el 1er parámetro:

echo $this->Form->input(’Modelname.fieldname’);

Si necesita especificar múltiples campos usando el mismo nombre de campo, así 
crear un array que puede ser almacenado en un tiro con saveAll(), usar la 
siguiente convención:

echo $this->Form->input(’Modelname.0.fieldname’);
echo $this->Form->input(’Modelname.1.fieldname’);

Salida:

<input type="text" id="Modelname0Fieldname" name="data[Modelname][0][fieldname]">
<input type="text" id="Modelname1Fieldname" name="data[Modelname][1][fieldname]">

FormHelper usa internamente varios sufijos de campo para creación de input
datetime. Si está usando campos nombrados year, month, day, hour, minute, ó meridian
y teniendo problemas (issues) al obtener el input correcto, puede fijar el atributo
name para redefinir el comportamiento por defecto:

echo $this->Form->input(’Model.year’, 
  array(
    ’type’ => ’text’,
    ’name’ => ’data[Model][year]’
  )
);

Opciones 
........
FormHelper::input() soporta varias opciones. Adicionalmente a sus propias opciones
input() acepta opciones para los tipos input generados, así como atributos HTML.
Lo siguiente cubrirá lo específico a opciones para FormHelper::input().

• $options[’type’]: Puede forzar el tipo de un input, redefinir introspección del
modelo, especificando un tipo. Adicionalmente a los tipos de campo hallados al 
Crear elementos de formulario, puede también crear ‘file’, ‘password’, y cualquier
tipo soportado por HTML5:

echo $this->Form->input(’field’, array(’type’ => ’file’));
echo $this->Form->input(’email’, array(’type’ => ’email’));

Salida:

<div class="input file">
  <label for="UserField">Field</label>
  <input type="file" name="data[User][field]" value="" id="UserField" />
</div>
<div class="input email">
  <label for="UserEmail">Email</label>
  <input type="email" name="data[User][email]" value="" id="UserEmail" />
</div>

• $options[’div’]: Usar esta opción para fijar atributos del div que contiene al
input. Usar un valor string fijará el nombre de clase del div. Un array fijará
los atributos del div a aquellos especificados por las claves/valores del array.
Alternativamente, puede fijar esta clave a false para inhabilitar las salida
del div.

Fijar el nombre de clase:

echo $this->Form->input(’User.name’, 
  array(
    ’div’ => ’class_name’
  )
);

Salida:

<div class="class_name">
  <label for="UserName">Name</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Fijar atributos múltiples:

echo $this->Form->input(’User.name’, 
  array(
    ’div’ => array(
      ’id’ => ’mainDiv’,
      ’title’ => ’Div Title’,
      ’style’ => ’display:block’
    )
  )
);

Salida:

<div class="input text" id="mainDiv" title="Div Title" style="display:block">
  <label for="UserName">Name</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Inhabilitar la salida del div:

echo $this->Form->input(’User.name’, array(’div’ => false)); ?>

Salida:

<label for="UserName">Name</label>
<input name="data[User][name]" type="text" value="" id="UserName" />

• $options[’label’]: Fijar esta clave al string que uno querría que se muestre
dentro de la etiqueta que usualmente acompaña el input:

echo $this->Form->input(’User.name’, array(
  ’label’ => ’The User Alias’
));

Salida:

<div class="input">
  <label for="UserName">The User Alias</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Alternativamente, fijar esta clave a false para inhabilitar la salida de la 
etiqueta:

echo $this->Form->input(’User.name’, array(’label’ => false));

Salida:

<div class="input">
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Fijar esto a un array para proveer opciones adicionales para el elemento label.
Si lo hace, puede usar una clave texto en el array para personalizar el texto del
label:

echo $this->Form->input(’User.name’, 
  array(
    ’label’ => array(
      ’class’ => ’thingy’,
      ’text’ => ’The User Alias’
    )
  )
);

Salida:

<div class="input">
  <label for="UserName" class="thingy">The User Alias</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

• $options[’error’]: Usar esta clave le permite redefinir los mensajes de error 
del modelo por defecto y pueden ser usados, por ej., para fijar mensajes i18n.
Este tiene un número de subopciones las cuales controlan el elemento envolvente,
envuelven el nombre de clase del elemento, y si el HTML en el mensaje de error
será escapado.

Para inhabilitar la salida de mensaje de error y clases de campo fijar la clave
error a false:

$this->Form->input(’Model.field’, array(’error’ => false));

Para inhabilitar sólo el mensaje de error, pero retener las clases de campo, 
fijar la clave errorMessage a false:

$this->Form->input(’Model.field’, array(’errorMessage’ => false));

Para modificar el tipo de elemento envolvente y su clase, usar el formato:

$this->Form->input(’Model.field’, 
  array(
    ’error’ => array(
      ’attributes’ => array(’wrap’ => ’span’, ’class’ => ’bzzz’)
    )
  )
);

Para evitar que HTML sea escapado automáticamente en la salida del mensaje de 
error, fijar la subopción escape a false:

$this->Form->input(’Model.field’, 
  array(
    ’error’ => array(
      ’attributes’ => array(’escape’ => false)
    )
  )
);

Para redefinir los mensajes de error del modelo usar un array con las claves que
coinciden con los nombres de regla de validación:

$this->Form->input(’Model.field’, 
  array(
    ’error’ => array(’tooShort’ => __(’This is not long enough’))
  )
);

Como arriba uno puede fijar el mensaje de error para cada regla de validación
que uno tiene en sus modelos. Adicionalmente puede proveer mensajes i18n para 
sus formularios.

Nuevo en v.2.3: Soporte para la opción errorMessage.

• $options[’before’], $options[’between’], $options[’separator’], y $options[’after’]

Usar estas claves si necesita inyectar algún marcado dentro de la salida del
método input():

echo $this->Form->input(’field’, 
  array(
    ’before’ => ’--before--’,
    ’after’ => ’--after--’,
    ’between’ => ’--between---’
  )
);

Salida:

<div class="input">
  --before--
  <label for="UserField">Field</label>
  --between---
  <input name="data[User][field]" type="text" value="" id="UserField" />
  --after--
</div>

Para radio inputs el atributo 'separator' puede usarse para inyectar marcado para
separar cada par input / label:

echo $this->Form->input(’field’, 
  array(
    ’before’ => ’--before--’,
    ’after’ => ’--after--’,
    ’between’ => ’--between---’,
    ’separator’ => ’--separator--’,
    ’options’ => array(’1’, ’2’)
  )
);

Salida:

<div class="input">
  --before--
  <input name="data[User][field]" type="radio" value="1" id="UserField1" />
  <label for="UserField1">1</label>
  --separator--
  <input name="data[User][field]" type="radio" value="2" id="UserField2" />
  <label for="UserField2">2</label>
  --between---
  --after--
</div>

Para elementos tipo date y datetime puede usarse el atributo 'separator' para 
cambiar el string entre elementos select. El valor por defecto es '-'.

• $options[’format’]: El ordenamiento del HTML generado por FormHelper es también
controlable. Las opciones 'format' soportan un array de strings los cuales describen
la plantilla a la que uno querría decir elemento a seguir. Las claves de array 
soportadas son: array(’before’, ’input’, ’between’, ’label’, ’after’,’error’).    

• $options[’inputDefaults’]: Si se haya a uno mismo repitiendo las mismas opciones
en múltiples llamadas input(), puede usar inputDefaults para mantener su código
seco:

echo $this->Form->create(’User’, 
  array(
    ’inputDefaults’ => array(
      ’label’ => false,
      ’div’ => false
    )   
  )
);

Todos los input creados desde ese punto heredarían las opciones declaradas en
inputDefaults. Puede redefinir el defaultOptions declarando la opción en la 
llamada input():

// No div, no label
echo $this->Form->input(’password’);

// has a label element
echo $this->Form->input(’username’, array(’label’ => ’Username’));

Para cambiar posteriormente los valores por defecto usar FormHelper::inputDefaults().

Generar tipos de inputs específicos
-----------------------------------
Adicionalmente al método input() genérico, FormHelper tiene métodos específicos
para generar un número de tipos diferentes de inputs. Estos pueden ser usados
para generar sólo el widget input mismo, y combinado con otros métodos como  
label() y error() para generar layouts de formulario completamente personalizados.

Opciones comunes 
................
Muchos de los métodos de elemento input soportan un set común de opciones. Todas
estas opciones son también soportadas por input(). Para reducir la repetición 
las opciones comunes compartidas por todos los métodos input son como siguen:

• $options[’class’]: Puede fijar el nombre de clase para un input:
 
echo $this->Form->input(’title’, array(’class’ => ’custom-class’));

• $options[’id’]: Fijar esta clave para forzar el valor de id del DOM para el 
input.

• $options[’default’]: Usado para fijar un valor por defecto para el campo input.
El valor es usado si los datos pasados al formulario no contienen un valor para
el campo (ó si no se pasó ningún dato).

Ejemplo de uso:

echo $this->Form->input(’ingredient’, array(’default’ => ’Sugar’));

Ejemplo con el campo select (se seleccionará el tamaño 'Medium' por defecto):

$sizes = array(’s’ => ’Small’, ’m’ => ’Medium’, ’l’ => ’Large’);
echo $this->Form->input(
  ’size’,
  array(’options’ => $sizes, ’default’ => ’m’)
);

Nota: No puede usar 'default' para chequear un checkbox - en vez de eso uno 
puede fijar el valor en $this->request->data en su controlador, ó fijar la
opción input checked a true.

Los campos por defecto date y datetime pueden ser fijados usando la clave 'selected'.

Cuidado al usar false para asignar un valor por defecto. Se usa un valor false
para inhabilitar/excluir opciones de un campo input, así 'default' => false no
fijará ningún valor. En vez de eso usar ’default’ => 0. 

Adicionalmente a las opciones de arriba, puede mezclar (mixin) cualquier atributo
HTML que desea usar. Cualquier nombre de opción no especial será tratado como un 
atributo HTML, y aplicado al elemento input HTML generado.

Opciones para inputs select, chechbox y radio 
.............................................
• $options[’selected’]: Usado en combinación con un input de tipo select 
(ej.: para tipos select, date, time, datetime). Fijar 'selected' al valor del
item que uno quiere seleccionar por defecto cuando el input es renderizado:

echo $this->Form->input(’close_time’, 
  array(
    ’type’ => ’time’,
    ’selected’ => ’13:30:00’
  )
);

Nota: La clave selected para inputs date y datetime pueden también ser un 
timestamp UNIX

• $options[’empty’]: Si se fija a true, fuerza al input a permanecer vacío. 

Cuando es pasado a una lista select, este crea una opción 'en blanco' (blank) 
con un valor vacío en su lista de drop down. Si quiere tener un valor vacío con
exhibido en vez de solo una opción en blanco, pasar un string a vacío:

echo $this->Form->input(’field’, 
  array(
    ’options’ => array(1, 2, 3, 4, 5),
    ’empty’ => ’(choose one)’
  )
);

Salida:

<div class="input">
  <label for="UserField">Field</label>
  <select name="data[User][field]" id="UserField">
    <option value="">(choose one)</option>
    <option value="0">1</option>
    <option value="1">2</option>
    <option value="2">3</option>
    <option value="3">4</option>
    <option value="4">5</option>
  </select>
</div>

Nota: Si uno necesita fijar el valor por defecto en un campo password a valor en
blanco (blank), usar en su lugar 'value' => ''.

Las Options pueden también ser suministradas como pares key-value.

• $options[’hiddenField’]: Para ciertos tipos input (checkboxes, radios) es creado
un input hidden tal que la clave en $this->request->data existirá aún sin un 
valor especificado:

<input type="hidden" name="data[Post][Published]" id="PostPublished_" value="0" />
<input type="checkbox" name="data[Post][Published]" value="1" id="PostPublished" />

Esto puede ser deshabilitado fijando $options[’hiddenField’] = false:

echo $this->Form->checkbox(’published’, array(’hiddenField’ => false));

Que produce:

<input type="checkbox" name="data[Post][Published]" value="1" id="PostPublished" />

Si quiere crear múltiples bloques de inputs en un formulario que están agrupados
todos juntos, debería usar este parámetro en todos los inputs excepto el primero.
Si el input hidden está en la página en múltiples lugares, solo el último grupo
de valores input será almacenado.

En este ej., serían pasados sólo los colores terciarios, y los colores primarios
serían redefinidos:

<h2>Primary Colors</h2>
<input type="hidden" name="data[Color][Color]" id="Colors_" value="0" />
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsRed" />
<label for="ColorsRed">Red</label>
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsBlue" />
<label for="ColorsBlue">Blue</label>
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsYellow" />
<label for="ColorsYellow">Yellow</label>

<h2>Tertiary Colors</h2>
<input type="hidden" name="data[Color][Color]" id="Colors_" value="0" />
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsGreen" />
<label for="ColorsGreen">Green</label>
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsPurple" />
<label for="ColorsPurple">Purple</label>
<input type="checkbox" name="data[Addon][Addon][]" value="5" id="ColorsOrange" />
<label for="ColorsOrange">Orange</label>

Inhabilitar ’hiddenField’ en el grupo del 2do input evitaría este comportamiento.
Puede fijar un valor de campo hidden diferente en vez de 0 tal como 'N':

echo $this->Form->checkbox(’published’, 
  array(
    ’value’ => ’Y’,
    ’hiddenField’ => ’N’,
  )
);

Opciones datetime
.................
• $options[’timeFormat’]: Usado para especificar el formato de los inputs select
para un set de inputs relacionados al tiempo. Valores válidos incluyen 12, 24, 
y null.  

• $options[’dateFormat’]: Usado para especificar el formato de los inputs select
para un set de inputs relacionados a date. Valores válidos incluyen cualquier
combinación de ‘D’, ‘M’ y ‘Y’ ó null. Los input serán puestos en el orden definido
por la opción dateFormat.
   
• $options[’minYear’], $options[’maxYear’]: Usado en combinación con un input
date / datetime. Define el final más bajo y/ó más alto de valores mostrados en 
el campo select de años.

• $options[’orderYear’]: Usado en combinación con un input date / datetime. Define
el orden en cual serán fijados los valores de año. Valores válidos incluyen
‘asc’, ‘desc’. El valor por defecto es ‘desc’.     

• $options[’interval’]: Esta opción especifica el número de minutos entre cada
opción en la caja 'select':

echo $this->Form->input(’Model.time’, 
  array(
    ’type’ => ’time’,
    ’interval’ => 15
  )
);

Crearía 4 opciones en el select de minuto. Uno por cada 15 minutos.

• $options[’round’]: Puede establecerse para arriba ó abajo para forzar el 
redondeo en una ú otra dirección. Está por defecto a null el cual redondea de
la mitad para arriba de acuerdo al intervalo.

Nuevo en v.2.4.

Métodos de Formulario específicos del elemento
----------------------------------------------
Todos los elementos son creados bajo un formulario para el modelo User como en
los ej.'s de arriba. Por esta razón, el código HTML generado contendrá atributos
que referencian al modelo User. Ej.: name=data[User][username], id=UserUsername.

FormHelper::label(string $fieldName, string $text, array $options)
..................................................................
Crea un elemento label. $fieldName es usado para generar el id del DOM. Si $text
es indefinido, $fieldName será usado para inclinar (inflect) el texto del label:

echo $this->Form->label(’User.name’);
echo $this->Form->label(’User.name’, ’Your username’);

Salida:

<label for="UserName">Name</label>
<label for="UserName">Your username</label>

$options puede ser ya sea un array de atributos HTML, ó un string que será usado
como un nombre de clase:

echo $this->Form->label(’User.name’, null, array(’id’ => ’user-label’));
echo $this->Form->label(’User.name’, ’Your username’, ’highlight’);

Salida:

<label for="UserName" id="user-label">Name</label>
<label for="UserName" class="highlight">Your username</label>

FormHelper::text(string $name, array $options)
..............................................
El resto de los métodos disponibles en el FormHelper son para crear elementos 
de formulario específicos. Algunos desde estos métodos también hacen uso de un
parámetro $options especial. En este caso, sin embargo, se usa primariamente 
$options para especificar atributos de etiqueta HTML (tal como el valor ó id del
DOM de un elemento en el formulario):

echo $this->Form->text(’username’, array(’class’ => ’users’));

Producirá:

<input name="data[User][username]" type="text" class="users" id="UserUsername" />

FormHelper::password(string $fieldName, array $options)
.......................................................
Crea un campo password:

echo $this->Form->password(’password’);

Producirá:

<input name="data[User][password]" value="" id="UserPassword" type="password" />

FormHelper::hidden(string $fieldName, array $options)
.....................................................
Crea un input de formulario hidden. Ej.:

echo $this->Form->hidden(’id’);

Producirá:

<input name="data[User][id]" id="UserId" type="hidden" />

Si el formulario es editado (el array $this->request->data contendrá info 
almacenada para el modelo User), el valor correspondiente al campo id será 
agregado automáticamente al HTML generado. Ej. para data[User][id] = 10:

<input name="data[User][id]" id="UserId" type="hidden" />

Cambiado en v.2.0: Los campos hidden ya no quitan más el atributo de clase. Esto
significa que si hay errores de validación en campos hidden, el nombre de clase
error-field será aplicado.

FormHelper::textarea(string $fieldName, array $options)
.......................................................
Crea un campo input textarea:

echo $this->Form->textarea(’notes’);

Producirá:

<textarea name="data[User][notes]" id="UserNotes"></textarea>

Si el formulario es editado (esto es, el array $this->request->data contendrá la 
información almacenada para el modelo User), el valor correspondiente al campo
'notes' será agregado automáticamente al HTML generado. Ej.:

<textarea name="data[User][notes]" id="UserNotes">
  This text is to be edited.
</textarea>

Nota: El tipo input textarea permite al atributo $options de 'escape' que determina
si ó no los contenidos del textarea deberían ser escapados. Por defecto a true.

echo $this->Form->textarea(’notes’, array(’escape’ => false);
// OR....
echo $this->Form->input(
  ’notes’,
  array(’type’ => ’textarea’, ’escape’ => false)
);

Opciones
........
Adicionalmente a las opciones comunes, textarea() soporta algunas opciones
específicas:

•$options[’rows’], $options[’cols’]: Estas 2 claves especifican el número de filas
y columnas:

echo $this->Form->textarea(
  ’textarea’,
  array(’rows’ => ’5’, ’cols’ => ’5’)
);

Produce:

<textarea name="data[Form][textarea]" cols="5" rows="5" id="FormTextarea"></textarea>

FormHelper::checkbox(string $fieldName, array $options)
.......................................................
Crea un elemento checkbox de formulario. Este método también genera un input form
hidden asociado para forzar el envío de datos para el campo especificado:

echo $this->Form->checkbox(’done’);

Producirá:

<input type="hidden" name="data[User][done]" value="0" id="UserDone_" />
<input type="checkbox" name="data[User][done]" value="1" id="UserDone" />

Es posible especificar el valor del checkbox usando el array $options:

echo $this->Form->checkbox(’done’, array(’value’ => 555));

Producirá:

<input type="hidden" name="data[User][done]" value="0" id="UserDone_" />
<input type="checkbox" name="data[User][done]" value="555" id="UserDone" />

Si uno no busca que el Form helper cree un input hidden:

echo $this->Form->checkbox(’done’, array(’hiddenField’ => false));

Producirá:

<input type="checkbox" name="data[User][done]" value="1" id="UserDone" />

FormHelper::radio(string $fieldName, array $options, array $attributes)
.......................................................................
Crea un set de inputs radio button.

Opciones
........
•$attributes[’value’]: Para fijar que valor debería ser seleccionado por defecto.

•$attributes[’separator’]: Para especificar HTML entre radio buttons (ej.: <br />).

•$attributes[’between’]: Especifica algún contenido a ser insertado entre la leyenda y el 1er elemento.

•$attributes[’disabled’]: Especifica esto a 'true' ó 'disabled' inhabilitará todos los radio buttons generados.

•$attributes[’legend’]: Los elementos Radio son envueltos con un label y fieldset por defecto.
 Fija $attributes[’legend’] a false para quitarlos:
  
 $options = array(’M’ => ’Male’, ’F’ => ’Female’);
 $attributes = array(’legend’ => false);
 echo $this->Form->radio(’gender’, $options, $attributes);

Producirá:

<input name="data[User][gender]" id="UserGender_" value="" type="hidden" />
<input name="data[User][gender]" id="UserGenderM" value="M" type="radio" />
<label for="UserGenderM">Male</label>
<input name="data[User][gender]" id="UserGenderF" value="F" type="radio" />
<label for="UserGenderF">Female</label>

Si por alguna razón uno no busca el input hidden, fijar $attributes[’value’] a un
valor selected ó boolean false hará solo eso.

En v.2.1: Fue agregada la opción $attributes[’disabled’].

FormHelper::select(string $fieldName, array $options, array $attributes)
........................................................................
Crea un elemento select, populado con los items en $options, con la opción 
especificada por $attributes[’value’] mostrada como seleccionada por defecto. 
Fijar la clave ‘empty’ en la variable $attributes a false apaga la opción vacío 
por defecto:

$options = array(’M’ => ’Male’, ’F’ => ’Female’);
echo $this->Form->select(’gender’, $options);

Producirá:

<select name="data[User][gender]" id="UserGender">
  <option value=""></option>
  <option value="M">Male</option>
  <option value="F">Female</option>
</select>

El tipo input select permite un atributo $option especial llamado ’escape’ que 
acepta un booleano y determina si la entidad HTML codifica los contenidos de las
opciones select. Por defecto en true:

$options = array(’M’ => ’Male’, ’F’ => ’Female’);
echo $this->Form->select(’gender’, $options, array(’escape’ => false));

•$attributes[’options’]: Esta clave le permite especificar opciones manualmente
para un input select, ó para un grupo radio. A menos que el 'type' se especifique
como 'radio', FormHelper asumirá que la salida objetivo es un input select:

echo $this->Form->select(’field’, array(1,2,3,4,5));

Produce:

<select name="data[User][field]" id="UserField">
  <option value="0">1</option>
  <option value="1">2</option>
  <option value="2">3</option>
  <option value="3">4</option>
  <option value="4">5</option>
</select>

Las opciones pueden también ser suministradas como pares clave-valor:

echo $this->Form->select(’field’, 
  array(
    ’Value 1’ => ’Label 1’,
    ’Value 2’ => ’Label 2’,
    ’Value 3’ => ’Label 3’
  )
);

Produce:

<select name="data[User][field]" id="UserField">
  <option value="Value 1">Label 1</option>
  <option value="Value 2">Label 2</option>
  <option value="Value 3">Label 3</option>
</select>

Si uno quisiese generar un select con optgroups, sólo pasar datos en formato
jerárquico. Esto funciona en checkboxes y radioboxes múltiples también, pero en
vez de optgroups envuelve elementos en fieldsets:

$options = array(
  ’Group 1’ => array(
    ’Value 1’ => ’Label 1’,
    ’Value 2’ => ’Label 2’
  ),
  ’Group 2’ => array(
    ’Value 3’ => ’Label 3’
  )
);
echo $this->Form->select(’field’, $options);

Produce:

<select name="data[User][field]" id="UserField">
  <optgroup label="Group 1">
    <option value="Value 1">Label 1</option>
    <option value="Value 2">Label 2</option>
  </optgroup>
  <optgroup label="Group 2">
    <option value="Value 3">Label 3</option>
  </optgroup>
</select>

•$attributes[’multiple’]: Si ‘multiple’ ha sido fijado a true para un input que
produce un select, el select permitirá selecciones múltiples:

echo $this->Form->select(
  ’Model.field’,
  $options,
  array(’multiple’ => true)
);

Alternativamente fijar 'multiple' a 'checkbox' para producir una lista de
checkboxes relacionados:

$options = array(
  ’Value 1’ => ’Label 1’,
  ’Value 2’ => ’Label 2’
);
echo $this->Form->select(’Model.field’, $options, 
  array(
    ’multiple’ => ’checkbox’
  )
);

Produce:

<div class="input select">
  <label for="ModelField">Field</label>
  <input name="data[Model][field]" value="" id="ModelField" type="hidden">
  <div class="checkbox">
    <input name="data[Model][field][]" value="Value 1" id="ModelField1" type="checkbox">
    <label for="ModelField1">Label 1</label>
  </div>
  <div class="checkbox">
    <input name="data[Model][field][]" value="Value 2" id="ModelField2" type="checkbox">
    <label for="ModelField2">Label 2</label>
  </div>
</div>

• $attributes[’disabled’]: Al crear checkboxes, esta opción puede fijarse a todo
  inhabilitado ó sólo a algunos checkboxes. Para fijar todos los checkboxes fijar
  disabled a true:

$options = array(
  ’Value 1’ => ’Label 1’,
  ’Value 2’ => ’Label 2’
);
echo $this->Form->select(’Model.field’, $options, 
  array(
    ’multiple’ => ’checkbox’,
    ’disabled’ => array(’Value 1’)
  )
);

Produce:

<div class="input select">
  <label for="ModelField">Field</label>
  <input name="data[Model][field]" value="" id="ModelField" type="hidden">
  <div class="checkbox">
    <input name="data[Model][field][]" disabled="disabled" value="Value 1" id="ModelField1" type="checkbox">
    <label for="ModelField1">Label 1</label>
  </div>
  <div class="checkbox">
    <input name="data[Model][field][]" value="Value 2" id="ModelField2" type="checkbox">
    <label for="ModelField2">Label 2</label>
  </div>
</div>

El soporte para arrays en $attributes[’disabled’] fue agregado en v.2.3.

FormHelper::file(string $fieldName, array $options)
...................................................
Para agregar el campo de subida de archivos a un formulario, primero debe asegurarse
que el enctype del formulario está fijo a "multipart/form-data", así arrancar 
con una función create como:

echo $this->Form->create(’Document’, array(
  ’enctype’ => ’multipart/form-data’
  )
);
// OR
echo $this->Form->create(’Document’, array(’type’ => ’file’));

Luego agregar una ú otra de las 2 líneas a su archivo de vista de formulario:

echo $this->Form->input(’Document.submittedfile’, 
  array(
    ’between’ => ’<br />’,
    ’type’ => ’file’
  )
);
// OR
echo $this->Form->file(’Document.submittedfile’);

Debido a las limitaciones del HTML mismo, no es posible poner valores por defecto
en campos input de tipo 'file'. Cada vez que el formulario es exhibido, el valor
dentro estará vacío.

Sobre envío, los archivos file proveen un array de datos expandido al script que
recibe los datos de formulario.

Para el ej. de arriba, los valores en el array de datos enviados sería organizado
como sigue, si CakePHP fue instalado en un Windows Server. ‘tmp_name’ tendrá 
una ruta diferente en un ambiente Unix:

$this->request->data[’Document’][’submittedfile’] = array(
  ’name’ => ’conference_schedule.pdf’,
  ’type’ => ’application/pdf’,
  ’tmp_name’ => ’C:/WINDOWS/TEMP/php1EE.tmp’,
  ’error’ => 0,
  ’size’ => 41737,
);

Este array es generado por PHP mismo. Validar los Uploads de abajo es un método
de validación ejemplo que uno podría definir en su modelo para validar si un
archivo ha sido subido exitosamente:

public function isUploadedFile($params) {
  $val = array_shift($params);
  if ((isset($val[’error’]) && $val[’error’] == 0) || (!empty( $val[’tmp_name’]) && $val[’tmp_name’] != ’none’)) {
    return is_uploaded_file($val[’tmp_name’]);
  }
  return false;
}

Crea un input file:

echo $this->Form->create(’User’, array(’type’ => ’file’));
echo $this->Form->file(’avatar’);

Producirá:

<form enctype="multipart/form-data" method="post" action="/users/add">
<input name="data[User][avatar]" value="" id="UserAvatar" type="file">

Nota: Usando $this->Form->file(), acordarse de fijar el encoding-type del 
formulario, fijando la opción de tipo a 'file' en $this->Form->create(). 

Crear buttons y elementos submit
--------------------------------
FormHelper::submit(string $caption, array $options)
...................................................
Crea un botón de submit con leyenda (caption) $caption. Si el $caption suministrado
es una URL para una imagen (esta contiene un caracter '.'), el botón de submit
será renderizado como una imagen.   

Este está encerrado entre etiquetas div por defecto; puede evitar esto declarando
$options[’div’] = false:

echo $this->Form->submit();

Producirá:

<div class="submit"><input value="Submit" type="submit"></div>

Puede también pasar una URL absoluta ó relativo a una imagen para el parámetro
caption en vez del texto caption:

echo $this->Form->submit(’ok.png’);

Producirá:

<div class="submit"><input type="image" src="/img/ok.png"></div>

FormHelper::button(string $title, array $options = array())
...........................................................
Crea un botón HTML con el título especificado y un tipo por defecto de 'button'.
Fijar $options[’type’] producirá 1 de los 3 tipos posibles de botones:

1.submit: El mismo que el método $this->Form->submit - (por defecto).
2.reset: Crea un botón de reset.
3.button: Crea un botón de pulsación (push) estándar.

echo $this->Form->button(’A Button’);
echo $this->Form->button(’Another Button’, array(’type’ => ’button’));
echo $this->Form->button(’Reset the Form’, array(’type’ => ’reset’));
echo $this->Form->button(’Submit Form’, array(’type’ => ’submit’));

Producirá:

<button type="submit">A Button</button>
<button type="button">Another Button</button>
<button type="reset">Reset the Form</button>
<button type="submit">Submit Form</button>

El tipo input button soporta la opción escape, que acepta un booleano y determina
si la entidad HTML codifica el $title del button. Por defecto en false:

echo $this->Form->button(’Submit Form’, 
  array(
    ’type’ => ’submit’,
    ’escape’ => true
  )
);

FormHelper::postButton(string $title, mixed $url, array $options = array ())
............................................................................
Crea una etiqueta <button> con un con un <form> circundante que envía via POST.

Este método crea un elemento <form>. Para formularios abiertos usar FormHelper::submit() ó 
FormHelper::button() para crear botones dentro de formularios abiertos.

FormHelper::postLink(string $title, mixed $url = null, array $options = array (), string $confirmMessage = false)
.................................................................................................................
Crea un enlace HTML, pero accede a la URL usando el método POST. Requiere que 
JavaScript esté habilitado en el navegador.

Este método crea un elemento <form>. Así no usar este método dentro del formulario
existente. En vez de eso debería agregar un botón de envío usando FormHelper::submit().

El método option fue agregado en v.2.3.

Crear inputs de date y time
---------------------------
FormHelper::dateTime($fieldName, $dateFormat = ‘DMY’, $timeFormat = ‘12’, $attributes = array())
................................................................................................
Crea un set de inputs select para date y time. Valores válidos para $dateformat
son 'DMY', 'MDY', 'YMD' ó 'NONE'. Valores válidos para $timeFormat son '12', '24', y null. 

Puede especificar no exhibir valores vacíos fijando "array('empty' => false)" en
el parámetro attributes. Este también pre-selecciona los campos con el datetime
actual.

FormHelper::year(string $fieldName, int $minYear, int $maxYear, array $attributes)
..................................................................................
Crea un elemento select populado con los años desde $minYear a $maxYear. Los 
atributos HTML pueden ser suministrados en $attributes. Si $attributes[’empty’]
es false, el select no incluirá la opción empty:

echo $this->Form->year(’purchased’, 2000, date(’Y’));

Producirá:

<select name="data[User][purchased][year]" id="UserPurchasedYear">
  <option value=""></option>
  <option value="2009">2009</option>
  <option value="2008">2008</option>
  <option value="2007">2007</option>
  <option value="2006">2006</option>
  <option value="2005">2005</option>
  <option value="2004">2004</option>
  <option value="2003">2003</option>
  <option value="2002">2002</option>
  <option value="2001">2001</option>
  <option value="2000">2000</option>
</select>

FormHelper::month(string $fieldName, array $attributes)
.......................................................
Crea un elemento select populado con los nombres de mes:

echo $this->Form->month(’mob’);

Producirá:

<select name="data[User][mob][month]" id="UserMobMonth">
  <option value=""></option>
  <option value="01">January</option>
  <option value="02">February</option>
  <option value="03">March</option>
  <option value="04">April</option>
  <option value="05">May</option>
  <option value="06">June</option>
  <option value="07">July</option>
  <option value="08">August</option>
  <option value="09">September</option>
  <option value="10">October</option>
  <option value="11">November</option>
  <option value="12">December</option>
</select>

Uno puede pasar su propio array de meses a ser usado fijando el atributo ‘monthNames’,
ó teniendo los meses exhibidos como números pasando false (Nota: los meses por defecto
son internacionalizados y pueden ser traducidos usando localización):

echo $this->Form->month(’mob’, array(’monthNames’ => false));

FormHelper::day(string $fieldName, array $attributes)
.....................................................
Crea un elemento select populado con los días (numéricos) del mes.

Para crear un option vacío con el texto solicitado de su elección (ej.: la 1ra
opción es 'Day'), puede suministrar el texto como el parámetro final como sigue:

echo $this->Form->day(’created’);

Producirá:

<select name="data[User][created][day]" id="UserCreatedDay">
  <option value=""></option>
  <option value="01">1</option>
  <option value="02">2</option>
  <option value="03">3</option>
  ...
  <option value="31">31</option>
</select>

FormHelper::hour(string $fieldName, boolean $format24Hours, array $attributes)
..............................................................................
Crea un elemento select populado con las horas del día.

FormHelper::minute(string $fieldName, array $attributes)
........................................................
Crea un elemento select populado con los minutos de la hora.

FormHelper::meridian(string $fieldName, array $attributes)
..........................................................
Crea un elemento select populado con ‘am’ y ‘pm’.

Exhibir y chequear errores
--------------------------
FormHelper::error(string $fieldName, mixed $text, array $options)
.................................................................
Muestra un mensaje de error de validación, especificado por $text, para el 
campo dado, en el evento que ocurra un error de validación.

Opciones:

• 'escape': boolean Sí o no respecto a que el HTML escape los contenidos del error.

• 'wrap' mixed Sí o no respecto a que el mensaje de error debiera ser envuelto en
  un div. Si es un string, será usado como la etiqueta HTML a usar.

• 'class' string El nombre de clase para el mensaje de error.

FormHelper::isFieldError(string $fieldName)
...........................................
Retorna true si el $fieldName suministrado tiene un error de validación activo:

if ($this->Form->isFieldError(’gender’)) {
  echo $this->Form->error(’gender’);
}

Nota: Al usar FormHelper::input(), los errores son renderizados por defecto.

FormHelper::tagIsInvalid()
..........................
Retorna false si el campo de formulario dado descripto por la entidad actual no
tiene errores. Sino este retorna el mensaje de validación.

Fijar valores por defecto para todos los campos
-----------------------------------------------

Nuevo en v.2.2.

Puede declarar un set de optiones por defecto para input() usando FormHelper::inputDefaults().
Cambiar las opciones por defecto le permite consolidar las opciones repetidas en una única
llamada a método:

$this->Form->inputDefaults(
  array(
    ’label’ => false,
    ’div’ => false,
    ’class’ => ’fancy’
  )
);

Todos los input creados desde ese punto hacia adelante heredarán las opciones 
declaradas en inputDefaults. Puede redefinir las opciones por defecto declarando
la opción en la llamada input():

echo $this->Form->input(’password’); // No div, no label with class ’fancy’
// has a label element same defaults
echo $this->Form->input(
  ’username’,
  array(’label’ => ’Username’)
);

Trabajar con SecurityComponent
------------------------------
Incluyendo SecurityComponent en su controlador, se beneficiará automáticamente
de las características de CSRF y tampering de formulario.

Al usar SecurityComponent, siempre debería cerrar sus formularios usando  
FormHelper::end(). Esto asegurará que sean generados los inputs especiales '_Token'.

FormHelper::unlockField($name)
..............................
Desbloquea un campo haciéndolo exento del hashing de campo de SecurityComponent.
Esto también permite que los campos sean manipulados por JavaScript. El parámetro
$name debería ser el nombre de entidad para el input:

$this->Form->unlockField(’User.id’);

FormHelper::secure(array $fields = array())
...........................................
Genera un campo hidden con un hash de seguridad basado en los campos usados en el 
formulario.

Actualizaciones 2.0
-------------------

Parámetro $selected quitado
---------------------------
El parámetro $selected fue quitado de ambos métodos en FormHelper. Todos los métodos
soportan ahora un clave $attributes[’value’] la cual debería ser usada en lugar
de $selected. Este cambio simplifica el método FormHelper, reduciendo el número
de argumentos, y reduce la duplicación que creó $selected. Los métodos efectivos:

• FormHelper::select()
• FormHelper::dateTime()
• FormHelper::year()
• FormHelper::month()
• FormHelper::day()
• FormHelper::hour()
• FormHelper::minute()
• FormHelper::meridian()

Las URLs por defecto en formularios es la acción actual
-------------------------------------------------------
La URL por defecto para todos los formularios, es ahora la URL actual incluyendo
los parámetros pasados, nombrados y querystring. Puede redefinir este comportamiento
por defecto suministrando $options[’url’] en el 2do parámetro de $this->Form->create().

FormHelper::hidden()
....................
Los campos hidden ya no quitan el atributo de clase. Esto significa que si hay 
errores de validación en campos hidden, el nombre de la clase error-field será 
aplicado.

HtmlHelper
----------
clase HtmlHelper(View $view, array $settings = array())
.......................................................
Algunos métodos HtmlHelper incluyen un parámetro $htmlAttributes, que le permiten
virar en cualquiera de los atributos extra en sus etiquetas. Algunos ejemplos 
de como usar el parámetro $htmlAttributes:

Desired attributes: <tag class="someClass" />
Array parameter: array(’class’ => ’someClass’)

Desired attributes: <tag name="foo" value="bar" />
Array parameter: array(’name’ => ’foo’, ’value’ => ’bar’)

Nota: El HtmlHelper está disponible por defecto en todas las vistas. Si está
obteniendo un error informando que no no está allí, este es usualmente debido
a su nombre perdido desde una variable controlador $helpers configurada 
manualmente.

Insertar elementos bien formateados
-----------------------------------
Con HtmlHelper se puede crear un marcado bien formado. Uno puede cachear vistas
en CakePHP para salvar algunos ciclos de CPU cuando las vistas están siendo 
renderizadas y entregadas. 

HtmlHelper::charset($charset=null)
..................................
Parámetros
..........
• $charset (string) – Set de caracteres deseado. Si es null, se usará el valor
de App.encoding.

Usado para crear una etiqueta meta especificando el caracter del documento. Por
defecto en UTF-8.

Ejemplo de uso:

echo $this->Html->charset();

Producirá:

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

Alternativamente,

echo $this->Html->charset(’ISO-8859-1’);

Producirá:

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />

HtmlHelper::css(mixed $path, array $options = array())
......................................................
Cambiado en v.2.4.

Parámetros
..........
• $path (mixed) – Ya sea un string del archivo CSS a enlazar, ó un array con
varios archivos.

• $options (array) – Un array de opciones ú atributos HTML.

Crea un link a una hoja de estilo CSS. Si la clave 'inline' se fija a false en
el parámetro $options, las etiquetas de enlace son agregadas al bloque CSS el cual
un puede imprimir dentro de la etiqueta head del documento.

Puede usar la opción block para controlar a que bloque el elemento link será
anexado. Por defecto será anexado al bloque CSS.

Si la clave 'rel' en $options es fijado a 'import' la hoja de estilos será importada.

Este método de inclusión CSS asume que el archivo CSS especificado reside dentro del 
directorio /app/webroot/css si la ruta no comienza con un ‘/’:

echo $this->Html->css(’forms’);

Producirá:

<link rel="stylesheet" type="text/css" href="/css/forms.css" />

El 1er parámetro puede ser un array para incluir archivos múltiples:

echo $this->Html->css(array(’forms’, ’tables’, ’menu’));

Producirá:

<link rel="stylesheet" type="text/css" href="/css/forms.css" />
<link rel="stylesheet" type="text/css" href="/css/tables.css" />
<link rel="stylesheet" type="text/css" href="/css/menu.css" />

Puede incluir archivos CSS desde cualquier plugin cargado usando la sintaxis plugin.
Para incluir app/Plugin/DebugKit/webroot/css/toolbar.css podría usar lo siguiente:

echo $this->Html->css(’DebugKit.toolbar.css’);

Si quiere incluir un archivo CSS que comparte un nombre con un plugin cargado 
puede hacer lo siguiente. Ej.: si uno tuvo un plugin Blog, y también quiso incluir
app/webroot/css/Blog.common.css, debería:

.. versionchanged:: 2.4

echo $this->Html->css(‘Blog.common.css’, array(‘plugin’ => false));

Para v.2.1: se agregó opción block y soporte para la sintaxis plugin.

HtmlHelper::meta(string $type, string $url = null, array $options = array())
............................................................................

Parámetros
..........
• $type (string) – La etiqueta meta que quiere.
• $url (mixed) – La url para la etiqueta meta, ya sea un string ó un array de enrutamiento.
• $options (array) – Un array de atributos html.

Este método es útil para enlazar a recursos externos como alimentaciones RSS/Atom 
y favicons. Como css(), puede especificar si a uno le gustaría ó no que esta
etiqueta aparezca como 'inline' ó 'appended' al bloque 'meta' fijando la clave
'inline' en el parámetro $attributes a false, por ej. array(’inline’ => false).

Si fija el atributo 'type' usando el parámetro $attributes, CakePHP contiene 
algunos accesos directos:

-------------------------------
| Tipo  | Valor traducido     |
-------------------------------
| html  | text/html           |
| rss   | application/rss+xml |
| atom  | application/atom+xml|
| icon  | image/x-icon        |
-------------------------------

<?php
  echo $this->Html->meta(
    ’favicon.ico’,
    ’/favicon.ico’,
    array(’type’ => ’icon’)
  );
?>

// Output (line breaks added)
<link
  href="http://example.com/favicon.ico"
  title="favicon.ico" type="image/x-icon"
  rel="alternate"
/>

<?php
  echo $this->Html->meta(
    ’Comments’,
    ’/comments/index.rss’,
    array(’type’ => ’rss’)
  );
?>

// Output (line breaks added)
<link
  href="http://example.com/comments/index.rss"
  title="Comments"
  type="application/rss+xml"
  rel="alternate"
/>

Este método también puede usarse para agregar palabras clave y descripciones meta.
Ej.:

<?php
  echo $this->Html->meta(
    ’keywords’,
    ’enter any meta keyword here’
  );
?>

// Output
<meta name="keywords" content="enter any meta keyword here" />
<?php
  echo $this->Html->meta(
    ’description’,
    ’enter any meta description here’
  );
?>

// Output
<meta name="description" content="enter any meta description here" />

Si quiere agregar una etiqueta meta personalizada el 1er parámetro debería 
fijarse a un array. Para producir una etiqueta noindex 'robots' usar el código:

echo $this->Html->meta(array(’name’ => ’robots’, ’content’ => ’noindex’));

Cambiado en v.2.1: Se agregó la opción block.

HtmlHelper::docType(string $type = ‘xhtml-strict’)
..................................................

Parámetros
..........

• $type (string) – El tipo de doctype siendo hecho.

Retorna una etiqueta doctype (X)HTML. Suministrar el doctype de acuerdo a la
siguiente tabla:

-------------------------------------
| type         | translated value   |
-------------------------------------
| html4-strict | HTML4 Strict       |
| html4-trans  | HTML4 Transitional |
| html4-frame  | HTML4 Frameset     |
| html5        | HTML5              |
| xhtml-strict | XHTML1 Strict      |
| xhtml-trans  | XHTML1 Transitional|
| xhtml-frame  | XHTML1 Frameset    |
| xhtml11      | XHTML1.1           |
-------------------------------------

echo $this->Html->docType();
// Outputs:
// <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
// "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

echo $this->Html->docType(’html5’);
// Outputs: <!DOCTYPE html>

echo $this->Html->docType(’html4-trans’);
// Outputs:
// <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
// "http://www.w3.org/TR/html4/loose.dtd">

Cambiado en v.2.1: El doctype por defecto es HTML5.

HtmlHelper::style(array $data, boolean $oneline = true)
.......................................................

Parámetros
..........
• $data (array) – Un set de claves => valor con propiedades CSS.

• $oneline (boolean) – Los contenidos deberían estar en una sola línea.

Construye definiciones de estilo CSS basados en claves y valores del array pasado
al método. Especialmente útil si su archivo CSS es dinámico:

echo $this->Html->style(
  array(
    ’background’ => ’#633’,
    ’border-bottom’ => ’1px solid #000’,
    ’padding’ => ’10px’
  )
);

Producirá:

background:#633; border-bottom:1px solid #000; padding:10px;

HtmlHelper::image(string $path, array $options = array())
.........................................................

Parámetros
..........
• $path (string) – Ruta a la imagen.
• $options (array) – Un array de atributos HTML.

Crea una etiqueta de imagen formateada. La ruta suministrada debería ser relativa a
/app/webroot/img/:

echo $this->Html->image(’cake_logo.png’, array(’alt’ => ’CakePHP’));

Producirá:

<img src="/img/cake_logo.png" alt="CakePHP" />

Para crear un enlace de imagen especificar el enlace destino usando la opción url
en $htmlAttributes.:

echo $this->Html->image("recipes/6.jpg", 
  array(
    "alt" => "Brownies",
    ’url’ => array(’controller’ => ’recipes’, ’action’ => ’view’, 6)
  )
);

Producirá:

<a href="/recipes/view/6">
  <img src="/img/recipes/6.jpg" alt="Brownies" />
</a>

Si está creando imágenes en e-mails, ó busca rutas absolutas a imágenes puede 
usar la opción fullBase:

echo $this->Html->image("logo.png", array(’fullBase’ => true));

Producirá:

<img src="http://example.com/img/logo.jpg" alt="" />

Puede incluir archivos de imagen desde cualquier plugin cargado usando la 
sintaxis plugin. Para incluir app/Plugin/DebugKit/webroot/img/icon.png podría usar:

echo $this->Html->image(’DebugKit.icon.png’);

Si quiere incluir un archivo de imagen que comparte un nombre con un plugin cargado
puede hacer lo siguiente. Ej.: si uno tuvo un plugin Blog, y también buscó incluir
app/webroot/js/Blog.icon.png, debería:

echo $this->Html->image(’Blog.icon.png’, array(’plugin’ => false));

Cambiado en v.2.1: Se agregaron opción fullBase y soporte para sintaxis plugin.

HtmlHelper::link(string $title, mixed $url = null, array $options = array(), string $confirmMessage = false)
............................................................................................................

param string $title: El texto a exhibirse como el cuerpo del enlace.

param mixed $url: Ya sea la ubicación del string, ó array de enrutamiento.

param array $options: Un array de atributos HTML.

Método de propósito general para crear enlaces HTML. Usar $options para especificar
atributos para el 'element' y si ó no $title debería ser escapado:

echo $this->Html->link(
  ’Enter’,
  ’/pages/home’,
  array(’class’ => ’button’, ’target’ => ’_blank’)
);

Producirá:

<a href="/pages/home" class="button" target="_blank">Enter</a>

Usar la opción  ’full_base’ => true para URL's absolutas:

echo $this->Html->link(
  ’Dashboard’,
  array(
    ’controller’ => ’dashboards’,
    ’action’ => ’index’,
    ’full_base’ => true
  )
);

Producirá:

<a href="http://www.yourdomain.com/dashboards/index">Dashboard</a>

Especificar $confirmMessage para exhibir un diálogo confirm() de JavaScript:

echo $this->Html->link(
  ’Delete’,
  array(’controller’ => ’recipes’, ’action’ => ’delete’, 6),
  array(),
  "Are you sure you wish to delete this recipe?"
);

Producirá:

<a href="/recipes/delete/6"
  onclick="return confirm(
    ’Are you sure you wish to delete this recipe?’
  );"
>
  Delete
</a>

Los query strings pueden también ser creados con link():

echo $this->Html->link(’View image’, array(
  ’controller’ => ’images’,
  ’action’ => ’view’,
  1,
  ’?’ => array(’height’ => 400, ’width’ => 500))
);

Producirá:

<a href="/images/view/1?height=400&width=500">View image</a>

Al usar parámetros nombrados, usar la sintaxis array e incluir nombres para TODOS
los parámetros de la URL. Usar la sintaxis string para parámetros (ej.: 
“recipes/view/6/comments:false” resultará en los caracteres ':' siendo escapados
y el enlace no funcionará como es deseado):                                     

<?php
  echo $this->Html->link(
    $this->Html->image("recipes/6.jpg", array("alt" => "Brownies")),
    array(
      ’controller’ => ’recipes’,
      ’action’ => ’view’,
      ’id’ => 6,
      ’comments’ => false
    )
  );

Producirá:

<a href="/recipes/view/id:6/comments:false">
  <img src="/img/recipes/6.jpg" alt="Brownies" />
</a>

Los caracteres especiales en $title serán convertidos a entidades HTML. Para 
inhabilitar esta conversión, fijar la opción escape a false en el array $options:

<?php
  echo $this->Html->link(
    $this->Html->image("recipes/6.jpg", array("alt" => "Brownies")),
    "recipes/view/6",
    array(’escape’ => false)
  );

Producirá:

<a href="/recipes/view/6">
  <img src="/img/recipes/6.jpg" alt="Brownies" />
</a>

Poner escape a false también inhabilitará el escape de atributos del enlace.
Como en v.2.4 puede usar la opción escapeTitle para inhabilitar sólo escapar el
título y no los atributos:

<?php
  echo $this->Html->link(
  $this->Html->image(’recipes/6.jpg’, array(’alt’ => ’Brownies’)),
  ’recipes/view/6’,
  array(’escapeTitle’ => false, ’title’ => ’hi "howdy"’)
);

Producirá:

<a href="/recipes/view/6" title="hi &quot;howdy&quot;">
  <img src="/img/recipes/6.jpg" alt="Brownies" />
</a>

Cambiado en v.2.4: Se agregó la opción escapeTitle.

HtmlHelper::media(string|array $path, array $options)
.....................................................
Parámetros
..........

• $path (string|array): Ruta al archivo de video, relativa al directorio  
   webroot/{$options[’pathPrefix’]}. O un array donde cada item en sí mismo
   puede ser un string ruta ó un array asociativo que contiene claves src y type.

• $options (array) – Array de atributos HTML, y opciones especiales.

  Opciones:

  - type: Tipo de elemento media a generar, valores válidos son “audio” ó “video”.
    Si type no es provisto se presume a media type basado en el mime type del 
    archivo.   

  – text: Texto a incluir dentro de la etiqueta video
   
  – pathPrefix: Prefijo de ruta a usar para URL's relativas, por defecto a ‘files/’
  
  – fullBase: Si se proveyó el atributo src obtendrá una dirección completa incluyendo
    nombre de dominio

Nuevo en v.2.1.

Retorna una etiqueta de audio/video formateada:

<?php echo $this->Html->media(’audio.mp3’); ?>
// Output
<audio src="/files/audio.mp3"></audio>

<?php echo $this->Html->media(’video.mp4’, 
  array(
    ’fullBase’ => true,
    ’text’ => ’Fallback text’
  )
); 
?>
// Output
<video src="http://www.somehost.com/files/video.mp4">Fallback text</video>

<?php echo $this->Html->media(
  array(
    ’video.mp4’,
    array(
      ’src’ => ’video.ogg’,
      ’type’ => "video/ogg; codecs=’theora, vorbis’"
    )
  ),
  array(’autoplay’)
); 
?>
// Output
<video autoplay="autoplay">
  <source src="/files/video.mp4" type="video/mp4"/>
  <source src="/files/video.ogg" type="video/ogg; codecs=’theora, vorbis’"/>
</video>

HtmlHelper::tag(string $tag, string $text, array $htmlAttributes)
.................................................................

Parámetros
..........

• $tag (string): El nombre de etiqueta siendo generado.
• $text (string): Los contenidos para la etiqueta.
• $options (array): Un array de atributos HTML.

Retorna texto envuelto en una etiqueta especificada. Si no se especifica texto
sólo se retornará la <tag> de apertura: 

<?php
  echo $this->Html->tag(’span’, ’Hello World.’, array(’class’ => ’welcome’));
?>
// Output
<span class="welcome">Hello World</span>

// No text specified.
<?php
  echo $this->Html->tag(’span’, null, array(’class’ => ’welcome’));
?>
// Output
<span class="welcome">

Nota: El texto no es escapado por defecto pero uno puede usar $htmlOptions[’escape’] = true
para escapar su texto. Esto reemplaza un cuarto parámetro boolean $escape = false
que estuvo disponible en versiones anteriores.

HtmlHelper::div(string $class, string $text, array $options)
............................................................
Parámetros
..........

• $class (string): El nombre de clase para el div.
• $text (string): El contenido dentro del div.
• $options (array): Un array de atributos HTML.

Usado para crear secciones envueltas por div en marcados. El 1er parámetro especifica
una clase CSS, y el 2do se usa para suministrar el texto a ser envuelto por 
etiquetas div. Si el último parámetro ha sido fijado a true, $text será impreso
con HTML escapado.

Si no se especifica texto, sólo se retornará una etiqueta div de apertura:

<?php
  echo $this->Html->div(’error’, ’Please enter your credit card number.’);
?>
// Output
<div class="error">Please enter your credit card number.</div>

HtmlHelper::para(string $class, string $text, array $options)
.............................................................
Parámetros
..........
• $class (string): El nombre de clase para el párrafo.
• $text (string): El contenido dentro del párrafo.
• $options (array): Un array de atributos HTML.

Retorna un texto envuelto en una etiqueta <p> con clase CSS. Si no se suministró
texto, sólo se retorna una etiqueta <p> de arranque:

<?php
  echo $this->Html->para(null, ’Hello World.’);
?>
// Output
<p>Hello World.</p>

HtmlHelper::script(mixed $url, mixed $options)
..............................................
Parámetros
..........
• $url (mixed): Ya sea un string para un archivo único JavaScript, ó un array de
strings para archivos múltiples.

• $options (array): Array de atributos HTML.

Incluye archivo/s de script, contenidos ya sea localmente ó como una URL remota.

Por defecto, las etiquetas de script son agregadas al documento 'inline'. Si uno
redefine esto fijando $options[’inline’] a false, las etiquetas de script serán
en su lugar agregadas al bloque script el que uno puede imprimir en cualquier
lado del documento. Si uno desea redefinir que nombre de bloque se usa, puede
hacerlo fijando $options[’block’].    

$options[’once’] controla si uno quiere ó no incluir este script una vez por
petición ó más que eso. Esto está por defecto en true.

Uno puede usar $options para fijar propiedades adicionales a la etiqueta script
generada. Si se usó un array  de etiquetas script, los atributos serán aplicados
a todas las etiquetas de script generadas.

Este método de inclusión de archivo JavaScript asume que el archivo JavaScript 
especificado reside dentro del directorio /app/webroot/js:

echo $this->Html->script(’scripts’);

Producirá:

<script type="text/javascript" href="/js/scripts.js"></script>

Puede enlazar a archivos con rutas absolutas así como a archivos de enlace que
no están en app/webroot/js:

echo $this->Html->script(’/otherdir/script_file’);

Puede también enlazar a una URL remota:

echo $this->Html->script(’http://code.jquery.com/jquery.min.js’);

Producirá:

<script type="text/javascript" href="http://code.jquery.com/jquery.min.js">
</script>

El 1er parámetro puede ser un array para incluir archivos múltiples:

echo $this->Html->script(array(’jquery’, ’wysiwyg’, ’scripts’));

Producirá:

<script type="text/javascript" href="/js/jquery.js"></script>
<script type="text/javascript" href="/js/wysiwyg.js"></script>
<script type="text/javascript" href="/js/scripts.js"></script>

Puede anexar la etiqueta script para un bloque específico usando la opción block:

echo $this->Html->script(’wysiwyg’, array(’block’ => ’scriptBottom’));

En su layout puede producir todas las etiquetas de script agregadas a ‘scriptBottom’:

echo $this->fetch(’scriptBottom’);

Puede incluir archivos de script desde cualquier plugin cargado usando la sintaxis
plugin. Para incluir app/Plugin/DebugKit/webroot/js/toolbar.js puede usar:

echo $this->Html->script(’DebugKit.toolbar.js’);

Si quiere incluir un archivo de script que comparte un nombre con un plugin cargado
puede hacer lo siguiente. Ej.: si uno tuvo un plugin Blog, y también buscó incluir
app/webroot/js/Blog.plugins.js, debería:

echo $this->Html->script(’Blog.plugins.js’, array(’plugin’ => false));

Cambiado en v.2.1: se agregó la opción block y soporte para la sintaxis plugin.

HtmlHelper::scriptBlock($code, $options = array())
..................................................
Parámetros
..........
• $code (string): El código para ir en la etiqueta script.
• $options (array): Un array de atributos HTML.

Genera un bloque de código que contiene a $code fija $options[’inline’] a false 
para tener al bloque de script que aparezca en el bloque de vista del script. 
Otras opciones definidas serán agregadas como atributos a etiquetas script. 
$this->Html->scriptBlock(’stuff’, array(’defer’ => true)); creará una etiqueta
script con el atributo defer="defer".

HtmlHelper::scriptStart($options = array())
...........................................
Parámetros
..........
• $options (array): Un array de atributos HTML a ser usados cuando es llamado
scriptEnd. Comenzar un bloque de código de buffering. Este bloque de código
capturará todas las salidas entre scriptStart() y scriptEnd() y crea una etiqueta
script. Las opciones son las mismas que scriptBlock().

HtmlHelper::scriptEnd()
.......................
Finaliza un bloque de script de buffering, retorna el elemento script generado
ó null si el bloque script fue abierto con inline = false.

Un ejemplo de usar scriptStart() y scriptEnd() sería:

$this->Html->scriptStart(array(’inline’ => false));
echo $this->Js->alert(’I am in the javascript’);
$this->Html->scriptEnd();

HtmlHelper::nestedList(array $list, array $options = array(), array $itemOptions = array(), string $tag = ‘ul’)
...............................................................................................................
Parámetros
..........
• $list (array): Set de elementos a listar.
• $options (array): Atributos HTML adicionales de la etiqueta (ol/ul) lista ó si ol/ul usa eso como etiqueta.
• $itemOptions (array): Atributos HTML adicionales de la etiqueta item de lista (LI).
• $tag (string): Tipo de etiqueta lista a usar (ol/ul).

Construye una lista anidada (UL/OL) fuera de un array asociativo:

$list = array(
  ’Languages’ => array(
    ’English’ => array(
      ’American’,
      ’Canadian’,
      ’British’,
    ),
  ’Spanish’,
  ’German’,
  )
);

echo $this->Html->nestedList($list);

Produce:

// Output (minus the whitespace)
<ul>
  <li>Languages
    <ul>
      <li>English
        <ul>
          <li>American</li>
          <li>Canadian</li>
          <li>British</li>
        </ul>
      </li>
      <li>Spanish</li>
      <li>German</li>
    </ul>
  </li>
</ul>

HtmlHelper::tableHeaders(array $names, array $trOptions = null, array $thOptions = null)
........................................................................................
Parámetros
..........
• $names (array): Un array de strings para crear encabezados de tabla.
• $trOptions (array): Un array de atributos HTML para el <tr>.
• $thOptions (array): Un array de atributos HTML para los elementos <th>.

Crea un fila de celdas header de tabla a ser ubicadas dentro de las etiquetas 
<table>:

echo $this->Html->tableHeaders(array(’Date’, ’Title’, ’Active’));

Produce:

<tr>
  <th>Date</th>
  <th>Title</th>
  <th>Active</th>
</tr>

echo $this->Html->tableHeaders(
  array(’Date’,’Title’,’Active’),
  array(’class’ => ’status’),
  array(’class’ => ’product_table’)
);

Produce:

<tr class="status">
  <th class="product_table">Date</th>
  <th class="product_table">Title</th>
  <th class="product_table">Active</th>
</tr>

Cambio en v.2.2: tableHeaders() ahora acepta atributos por celda.

Como en v.2.2 puede fijar atributos por columna, estos son usados en vez de los
valores por defecto provistos en $thOptions:

echo $this->Html->tableHeaders(
  array(
    ’id’,
    array(’Name’ => array(’class’ => ’highlight’)),
    array(’Date’ => array(’class’ => ’sortable’))
  )
);

Produce:

<tr>
  <th>id</th>
  <th class="highlight">Name</th>
  <th class="sortable">Date</th>
</tr>

HtmlHelper::tableCells(array $data, array $oddTrOptions = null, array $evenTrOptions = null, $useCount = false, $continueOddEven = true)
........................................................................................................................................
Parámetros
..........
• $data (array): Un array bidimensional con datos para las filas.
• $oddTrOptions (array): Un array de atributos HTML para los <tr>'s impares (odds).
• $evenTrOptions (array): Un array de atributos HTML para los <tr>'s pares (even).
• $useCount (boolean): Agrega la clase “column-$i”.
• $continueOddEven (boolean): Si es false, usará una variable $count no estática,
  tal que el conteo impar/par se resetea a 0 sólo para esa llamada.

Crea celdas de tabla, en filas, asignando atributos <tr> de forma diferente para
filas numeradas de forma par e impar. Envolver una celda de tabla única dentro
de un array() para atributos <td> específicos.

echo $this->Html->tableCells(
  array(
    array(’Jul 7th, 2007’, ’Best Brownies’, ’Yes’),
    array(’Jun 21st, 2007’, ’Smart Cookies’, ’Yes’),
    array(’Aug 1st, 2006’, ’Anti-Java Cake’, ’No’),
  )
);

Produce:

<tr><td>Jul 7th, 2007</td><td>Best Brownies</td><td>Yes</td></tr>
<tr><td>Jun 21st, 2007</td><td>Smart Cookies</td><td>Yes</td></tr>
<tr><td>Aug 1st, 2006</td><td>Anti-Java Cake</td><td>No</td></tr>

echo $this->Html->tableCells(
  array(
    array(
      ’Jul 7th, 2007’,
      array(
        ’Best Brownies’,
        array(’class’ => ’highlight’)
      ),
    ’Yes’),
    array(’Jun 21st, 2007’, ’Smart Cookies’, ’Yes’),
    array(
      ’Aug 1st, 2006’,
      ’Anti-Java Cake’,
      array(’No’, array(’id’ => ’special’))
    ),
  )
);

Produce:

<tr>
  <td>
    Jul 7th, 2007
  </td>
  <td class="highlight">
    Best Brownies
  </td>
  <td>
    Yes
  </td>
</tr>
<tr>
  <td>
    Jun 21st, 2007
  </td>
  <td>
    Smart Cookies
  </td>
  <td>
    Yes
  </td>
</tr>
<tr>
  <td>
    Aug 1st, 2006
  </td>
  <td>
    Anti-Java Cake
  </td>
  <td id="special">
    No
  </td>
</tr>

echo $this->Html->tableCells(
  array(
    array(’Red’, ’Apple’),
    array(’Orange’, ’Orange’),
    array(’Yellow’, ’Banana’),
  ),
  array(’class’ => ’darker’)
);

Produce:

<tr class="darker"><td>Red</td><td>Apple</td></tr>
<tr><td>Orange</td><td>Orange</td></tr>
<tr class="darker"><td>Yellow</td><td>Banana</td></tr>

HtmlHelper::url(mixed $url = NULL, boolean $full = false)
.........................................................
Parámetros
..........
• $url (mixed): Un array de enrutamiento.
• $full (mixed): Ya sea un boolean para indicar si ó no la ruta base debería ser
  incluída ó un array de opciones para Router::url().

Retorna una URL apuntando a una combinación de controlador y acción. Si $url está
vacío, este retorna el REQUEST_URI, sino este genera la URL para el controlador
y combo de acción. si 'full' es true, la URL base completa será pre-anexada al 
resultado:

echo $this->Html->url(
  array(
    "controller" => "posts",
    "action" => "view",
    "bar"
  )
);
// Output
/posts/view/bar

Algunos ej.'s de uso adicionales:

URL con parámetros nombrados:

echo $this->Html->url(
  array(
    "controller" => "posts",
    "action" => "view",
    "foo" => "bar"
  )
);
// Output
/posts/view/foo:bar

URL con extensión:

echo $this->Html->url(
  array(
    "controller" => "posts",
    "action" => "list",
    "ext" => "rss"
  )
);
// Output
/posts/list.rss

URL (arrancando con '/') con la URL base completa pre-anexada:

echo $this->Html->url(’/posts’, true);
// Output
http://somedomain.com/posts

URL con parámetros GET y ancla nombrada:

echo $this->Html->url(
  array(
    "controller" => "posts",
    "action" => "search",
    "?" => array("foo" => "bar"),
    "#" => "first"
  )
);
// Output
/posts/search?foo=bar#first

HtmlHelper::useTag(string $tag)
...............................
Retorna un bloque formateado existente de $tag:

$this->Html->useTag(
  ’form’,
  ’http://example.com’,
  array(’method’ => ’post’, ’class’ => ’myform’)
);

Produce:

<form action="http://example.com" method="post" class="myform">

Cambiar la salida de tags por HTMLHelper
----------------------------------------
HtmlHelper::loadConfig(mixed $configFile, string $path = null)
..............................................................
La etiqueta (tag) incorporada se fija para HtmlHelper son cumplidores de XHTML, sin 
embargo si uno necesita generar HTML para HTML5 necesitará crear y cargar un 
archivo de configuración de etiquetas (tags) nuevo que contiene las etiquetas 
que querría usar. Para cambiar las etiquetas usadas crear app/Config/html5_tags.php
que contiene:

$config = array(
  ’tags’ => array(
    ’css’ => ’<link rel="%s" href="%s" %s>’,
    ’style’ => ’<style%s>%s</style>’,
    ’charset’ => ’<meta charset="%s">’,
    ’javascriptblock’ => ’<script%s>%s</script>’,
    ’javascriptstart’ => ’<script>’,
    ’javascriptlink’ => ’<script src="%s"%s></script>’,
    // ...
  )
);

Puede luego cargar este set de etiqueta llamando a $this->Html->loadConfig(’html5_tags’);  

Crear rastros (trails) de breadcrumb con HtmlHelper
---------------------------------------------------
HtmlHelper::getCrumbs(string $separator = ‘&raquo;’, string $startText = false)
...............................................................................
CakePHP tiene la habilidad incorporada para crear automáticamente un rastro
breadcrumb en su aplicación. Para configurar esto, agregar algo similar a lo
siguiente en su plantilla de layout:

echo $this->Html->getCrumbs(’ > ’, ’Home’);

La opción $startText puede también aceptar un array. Este da más control sobre el
1er enlace generado:

echo $this->Html->getCrumbs(’ > ’, 
  array(
    ’text’ => $this->Html->image(’home.png’),
    ’url’ => array(’controller’ => ’pages’, ’action’ => ’display’, ’home’),
    ’escape’ => false
  )
);

Cualquiera de las claves que no son texto ó url serán pasados a link() como el
parámetro $options.

Cambiado en v.2.1: El parámetro $startText ahora acepta un array.

HtmlHelper::addCrumb(string $name, string $link = null, mixed $options = null)
..............................................................................
En su vista querrá agregar lo siguiente para inicar los rastros de breadcrumb en
cada una de las páginas:

$this->Html->addCrumb(’Users’, ’/users’);
$this->Html->addCrumb(’Add User’, array(’controller’ => ’users’, ’action’ => ’add’));

Esto agregará la salida de “Home > Users > Add User” en su layout donde fue 
agregado getCrumbs.

HtmlHelper::getCrumbList(array $options = array(), mixed $startText)
....................................................................
Parámetros
..........
• $options (array): Un array de atributos html para el elemento <ul> que contiene.
  Puede también contener las opciones ‘separator’, ‘firstClass’, ‘lastClass’ y 
  ‘escape’

• $startText (string|array): El texto ó elemento que precede la ul

Retorna breadcrumbs como una lista (x)html.

Este método usa HtmlHelper::tag() para generar lista y sus elementos. Funciona
similar a getCrumbs(), ya que este usa opciones con las cuales cada crumb fue
agregado. Puede usar el parámetro $startText para proveer el 1er enlace/texto
breadcrumb. Útil cuando uno siempre quiere incluir un enlace raíz. Esta opción
funciona igual que la opción $startText para getCrumbs().

Cambiado en v.2.1: Se agregó el parámetro $startText.

Cambiado en v.2.3: Se agregaron las opciones ‘separator’, ‘firstClass’ y ‘lastClass’.

Cambiado en v.2.5: Se agregó la opción ‘escape’.

JsHelper
--------
class JsHelper(View $view, array $settings = array())
.....................................................
Para soporte JavaScript, se creó un helper basado en Adapter, que incluye las
librerías Prototype/Scriptaculous, Mootools/Mootools-more, y jQuery/jQuery UI.  
Mientras que la API no es expansiva como el AjaxHelper anterior sentimos que la
solución basada en adaptador permite una solución más extensible dando a los 
desarrolladores el poder y flexibilidad que necesitan para afrontar sus necesidades
específicas de la aplicación.

Los motores de JavaScript forman el backbone del JsHelper nuevo. Un motor de 
JavaScript traduce un elemento JavaScript abstracto en código JavaScript concreto
específico para la librería JavaScript siendo usada. Adicionalmente crean un 
sistema extensible para que otros usen.

Usar un motor específico de JavaScript
--------------------------------------
Primero descargar su librería JavaScript preferida y ubicarla en app/webroot/js.

Luego debe incluir la librería en su página. Para incluirla en todas las páginas,
agregar esta línea a la sección <head> de app/View/Layouts/default.ctp:

echo $this->Html->script(’jquery’); // Include jQuery library

Reemplazar jquery con el nombre de su archivo librería (.js será agregado al nombre).

Por defecto los scripts están cacheados, y uno debe imprimir explícitamente la
cache. Para hacer esto al final de cada página, incluir esta línea antes de 
terminar la etiqueta </body>:

echo $this->Js->writeBuffer();  // Write cached scripts

Advertencia: Debe incluir la librería en su página e imprimir la cache para que
el helper funcione.

La selección de motor JavaScript es declarada cuando uno incluye el helper en su
controlador:

public $helpers = array(’Js’ => array(’Jquery’));

Lo de arriba usaría el motor de Jquery en las instancias de JsHelper en sus vistas.
Si uno no declara un motor específico, el motor de jQuery será usado como el 
valor por defecto.

Usar jQuery con otras librerías La librería jQuery, y virtualmente todos sus plugins
son ligados dentro del namespace jQuery. Los objetos "global" son almacenados 
también dentro del namespace de jQuery, así uno no obtendría un choque entre jQuery
y cualquier otra librería (como Prototype, MooTools, ó YUI). 

Hay una advertencia: Por defecto, jQuery usa "$" como acceso directo para "jQuery".  

Para redefinir el acceso directo "$", usar la variable jQueryObject:

$this->Js->JqueryEngine->jQueryObject = ’$j’;
echo $this->Html->scriptBlock(
  ’var $j = jQuery.noConflict();’,
  array(’inline’ => false)
);
// Tell jQuery to go into noconflict mode

Usar JsHelper dentro de customHelpers 
.....................................
Declarar JsHelper en el array $helpers en su customHelper:

public $helpers = array(’Js’);

Nota: No es posible declarar un motor JavaScript dentro de un custom helper. 
Hacer eso no tendrá efecto.

Si uno está dispuesto a usar otro motor JavaScript el que no sea por defecto,
hacer la configuración de helper en su controlador como sigue:

public $helpers = array(
  ’Js’ => array(’Prototype’),
  ’CustomHelper’
);

Advertencia: Estar seguro de declarar el JsHelper y su motor en la parte superior
del array $helpers en su controlador.

The selected JavaScript engine may disappear (replaced by the default) from the JsHelper object in your
helper, if you miss to do so and you will get code that does not fit your JavaScript library.

Crear un motor JavaScript
-------------------------
Los helpers del motor JavaScript deben tener el sufijo 'Engine'. DojoHelper no
está bien, lo correcto es DojoEngineHelper. Además, deben extender JsBaseEngineHelper 
en orden de impulsar la mayoría de la API nueva.

Uso del motor JavaScript
------------------------
JsHelper provee algunos métodos, y actúa como una fachada para el Engine helper.
Uno no debería acceder directamente al Engine helper excepto en raras ocasiones.
Usar características de fachada del JsHelper le permite impulsar las características
de encadenamiento de método y buffering incorporadas (el encadenamiento de método
sólo funciona en PHP5).

JsHelper por defecto hace un buffer de casi todo código de script generado, 
permitiendo a uno recolectar scripts a través de la vista, elementos y layout,
y producir esto es un lugar. Producir scripts buffered es hecho con $this->Js->writeBuffer();
esto retornará los contenidos de buffer en una etiqueta script. Puede inhabilitar
todo el buffering con la propiedad $bufferScripts ó fijar buffer => false en 
métodos tomando $options.

Ya que la mayoría de los métodos en JavaScript comienzan con una selección de 
elementos en el DOM, $this->Js->get() retorna un $this, permitiéndole a uno 
encadenar los métodos usando la selección. El encadenamiento de método le permite
escribir código más corto y expresivo:

$this->Js->get(’#foo’)->event(’click’, $eventCode);

Es un ej. de encadenamiento de método. El encadenamiento de método no es posible
en PHP4 y la muestra de arriba se escribiría como:

$this->Js->get(’#foo’);
$this->Js->event(’click’, $eventCode);

Opciones comunes 
................
En intentos por simplificar el desarrollo donde pueden cambiar las librerías 
JavaScript, es soportado por JsHelper un set de opciones comunes, las que serán
mapeadas a las opciones de librería específica internamente. Si no está planeando
conmutar librerías JavaScript, cada librería también soporta todas sus opciones
y callbacks nativos.

Envoltorio (wrapping) del Callback 
..................................
Por defecto todas las opciones de callback son envueltas con una función anónima
con los argumentos correctos. Puede inhabilitar este comportamiento suministrando
wrapCallbacks = false en su array de options.

Trabajar con scripts buffered
.............................
Un impedimento a implementaciones previas características tipo 'Ajax' fue el 
desparramo (scattering) de etiquetas (tags) script a través de su documento,
y la inhabilidad de hacer buffer de script agregados por elementos en el layout.
El nuevo JsHelper usado correctamente evita ambos de estos inconvenientes. Se
recomienda que uno ubique $this->Js->writeBuffer() en la parte inferior de su
archivo de layout arriba de la etiqueta </body>. Esto le permitirá a todos los
scripts generados en elementos layout ser producidos en un lugar. Los scripts
buffered son manejados de forma separada desde archivos de script incluídos.

JsHelper::writeBuffer($options = array())
.........................................
Escribe todo el JavaScript generado hasta ahora a un bloque de código ó los cachea
a un archivo y retorna un script enlazado.

Opciones
........
• inline: Se fija a true para tener salida de scripts como un bloque de script 
  inline si la cache también es true, una etiqueta link de script será generada
  (por defecto true).
  
• cache: Fijado a true para tener scripts cacheados a un archivo y enlazados
  (por defecto false).
  
• clear: Fijado a false para evitar que sea borrada la cache de script  
  (por defecto true).
  
• onDomReady: Envuelve scripts cacheados en el evento domready (por defecto true).

• safe: Si un bloque inline es generado este debería ser envuelto en <![CDATA[ ... ]]>
  (por defecto true).

Crear un archivo cache con writeBuffer() requiere que webroot/js sea escribible
al mundo y le permita a un navegador cachear recursos de script generados para
cualquier página.

JsHelper::buffer($content)
..........................
Agrega $content al buffer de script interno.

JsHelper::getBuffer($clear = true)
..................................
Obtiene los contenidos del buffer actual. Pasarlo en false para no borrar el 
buffer al mismo tiempo.

Métodos de buffering que no son buffered normalmente
----------------------------------------------------
Algunos métodos en helpers son por defecto buffered. Los motores hace buffer
de los siguientes métodos por defecto:

• event
• sortable
• drag
• drop
• slider

Adicionalmente uno puede forzar cualquier otro método en JsHelper para usar
buffering. Anexando un boolean al final de los argumentos uno puede forzar a otros
métodos para ir dentro del buffer. Ej.: el método each() no hace normalmente un
buffer:

$this->Js->each(’alert("whoa!");’, true);

Lo de arriba forzaría al método each() para usar al buffer. A la inversa si uno
busca un método que hace buffer a no buffer, puede pasar un false como el último
argumento:
 
$this->Js->event(’click’, ’alert("whoa!");’, false);

Esto forzaría la función event que normalmente hace buffer a retornar su resultado.

Otros métodos
.............
Los motores núcleo de JavaScript proveen la misma característica fija a través 
de todas las librerías, también hay un subset de opciones comunes que son traducidas
en opciones específicas de librería. Esto es hecho para proveer a usuarios finales
con una API lo más unificada posible. La siguiente lista de métodos son soportadas
por todos los Motores incluidos en el núcleo CakePHP. Siempre que uno ve listas
separadas para Options y Event Options ambos sets de parámetros son suministrados
en el array $options para el método.

JsHelper::object($data, $options = array())
...........................................
Serializa $data en JSON. Este método es un proxy para json_encode() con algunas
características extra agregadas vía el parámetro $options.

Opciones:

•prefix: String preanexado a los datos retornados.
•postfix: String anexado a los datos retornados.

Ejemplo de uso:

$json = $this->Js->object($data);

JsHelper::sortable($options = array())
......................................
Sortable genera un fragmento JavaScript para hacer un set de elementos (usualmente
una lista) ordenable por 'drag and drop' ('arrastrar y soltar'). 

Las opciones normalizadas:

Opciones
........
•containment: Contenedor para la opción move.
•handle: Selector para el elemento handle. Sólo este elemento arrancará la acción de ordenamiento (sorting).
•revert: Si ó no usar un efecto para mover a sortable en la posición final.
•opacity: Opacidad del marcador de posición (placeholder)
•distance: Distancia a que un sortable debe ser arrastrado (dragged) antes de arrancar el ordenamiento.

Opciones Event
..............
•start: Evento disparado al arrancar el ordenamiento (sorting).
•sort: Evento disparado durante el ordenamiento.
•complete: Evento disparado cuando se completa el ordenamiento.

Ejemplo de uso:

$this->Js->get(’#my-list’);
$this->Js->sortable(
  array(
    ’distance’ => 5,
    ’containment’ => ’parent’,
    ’start’ => ’onStart’,
    ’complete’ => ’onStop’,
    ’sort’ => ’onSort’,
    ’wrapCallbacks’ => false
  )
);

Asumiendo que uno estuviese usando el motor jQuery, obtendría el siguiente código
en su bloque JavaScript de código generado:

$("#myList").sortable({
  containment:"parent",
  distance:5,
  sort:onSort,
  start:onStart,
  stop:onStop
});

JsHelper::request($url, $options = array())
...........................................
Genera un fragmento JavaScript para crear una petición ‘AJAX’ ó XmlHttpRequest.

Opciones Event
..............
• complete: Callback para disparar en complete.
• success: Callback para disparar en success.
• before: Callback para disparar en inicialización de la petición.
• error: Callback para disparar en falla de la petición.

Opciones
........
• method: El método para hacer al request con los valores por defecto a GET en más
  librerías
• async: Si uno querría ó no una petición asincrónica.
• data: Datos adicionales a enviar.
• update: Id del DOM a actualizar con el contenido de la respuesta.
• type: Tipo de datos para la respuesta. 'json' y 'html' son soportados. El valor
  por defecto es html para la mayoría de las librerías.
• evalScripts: Si las etiquetas <script> deberían ser evaluadas ó no.
• dataExpression: Si debería la clave data ser tratada como un callback. Útil para
  suministrar $options[’data’] como otra expresión JavaScript.
  
Ejemplo de uso:

$this->Js->event(
  ’click’,
  $this->Js->request(
    array(’action’ => ’foo’, ’param1’),
    array(’async’ => true, ’update’ => ’#element’)
  )
);

JsHelper::get($selector)
........................
Fija la 'selección' interna a un selector CSS. La selección activa es usada en 
operaciones subsiguientes hasta que sea hecha una selección nueva:

$this->Js->get(’#element’);

JsHelper ahora referenciará a todos los otros elementos basados en la selección
de #element. Para cambiar la selección activa, llamar a get() nuevamente con un
elemento nuevo.

JsHelper::set(mixed $one, mixed $two = null)
............................................
Pasa variables en JavaScript. Le permite fijar variables que serán la salida 
cuando el buffer es extraído con JsHelper::getBuffer() ó JsHelper::writeBuffer().
La variable JavaScript usada para producir fijación de variables puede controlarse
con JsHelper::$setVariable.    

JsHelper::drag($options = array())
..................................
Hace a un elemento arrastrable.

Opciones
........
•handle: Selector para el elemento handle.
•snapGrid: La grilla de pixel que hace el chasquido (snap) de movimiento, un array(x, y)
•container: El elemento que actúa como un cuadro delimitador (bounding box) para
 el elemento arrastrable.

Opciones de Evento
..................
•start: Evento disparado cuando arranca el arrastre.
•drag: Evento disparado en cada paso del arrastre.
•stop: Evento disparado cuando se detiene el arrastre (se suelta (release) el mouse).

Ej. de uso:

$this->Js->get(’#element’);
$this->Js->drag(
  array(
    ’container’ => ’#content’,
    ’start’ => ’onStart’,
    ’drag’ => ’onDrag’,
    ’stop’ => ’onStop’,
    ’snapGrid’ => array(10, 10),
    ’wrapCallbacks’ => false
  )
);

Si estuviese usando el motor jQuery el siguiente código sería añadido al buffer:

$("#element").draggable({
  containment:"#content",
  drag:onDrag,
  grid:[10,10],
  start:onStart,
  stop:onStop
});

JsHelper::drop($options = array())
..................................
Hacer que un elemento acepte elementos draggable y actúe como una zona de alojamiento
(drop zone) para elementos arrastrados.

Opciones
........
• accept: Selector para elementos que este soltable (droppable) aceptará.
• hoverclass: Clase para agregar a soltable cuando se termina un soltable (droppable).

Opciones de Evento
..................

• drop: Evento disparado cuando un elemento es soltado en una zona de alojamiento (drop zone).
• hover: Evento disparado cuando un arrastre entra en una zona de alojamiento.
• leave: Evento disparado cuando un arrastre es quitado desde una zona de alojamiento 
  sin ser soltado.

Ej. de uso:

$this->Js->get(’#element’);
$this->Js->drop(
  array(
    ’accept’ => ’.items’,
    ’hover’ => ’onHover’,
    ’leave’ => ’onExit’,
    ’drop’ => ’onDrop’,
    ’wrapCallbacks’ => false
  )
);

Si uno hubiese estado usando el motor jQuery el siguiente código sería agregado
al buffer:

$("#element").droppable({
  accept:".items",
  drop:onDrop,
  out:onExit,
  over:onHover
});

Nota: Soltables (Droppables) en Mootools funcionan diferente de otras librerías.
Droppables son implementados como una extensión de Drag. Así en adición a hacer
a la selección get() para el elemento soltable. Uno debe también proveer una
regla selector al elemento arrastrable. Además, los soltables de Mootools heredan
todas las opciones de Drag.

JsHelper::slider($options = array())
....................................
Crea un fragmento de JavaScript que convierte un elemento en un widget ui 
deslizador (slider). 

Opciones
........
• handle: La id del elemento usado en deslizamiento.
• direction: La dirección del slider ya sea ‘vertical’ u ‘horizontal’
• min: El valor mínimo para el slider.
• max: El valor máximo para el slider.
• step: El número de pasos ó tics (ticks) que tendrá el slider.
• value: El offset inicial del slider.

Events

• change: Disparado cuando es actualizado el valor del slider.
• complete: Disparado cuando el usuario detiene el deslizamiento del manejo (handle). 

Ejemplo de uso:

$this->Js->get(’#element’);
$this->Js->slider(
  array(
    ’complete’ => ’onComplete’,
    ’change’ => ’onChange’,
    ’min’ => 0,
    ’max’ => 10,
    ’value’ => 2,
    ’direction’ => ’vertical’,
    ’wrapCallbacks’ => false
  )
);

Si uno estuviese usando el motor jQuery el código siguiente sería agregado al buffer:

$("#element").slider({
  change:onChange,
  max:10,
  min:0,
  orientation:"vertical",
  stop:onComplete,
  value:2
});

JsHelper::effect($name, $options = array())
...........................................
Crea un efecto básico. Por defecto este método no es buffered y retorna su resultado.

Nombres de efecto soportados
............................
Los siguientes efectos son soportados por todos los JsEngines:

• show: Revela un elemento.
• hide: Esconde un elemento.
• fadeIn: Destiñe (fade) un elemento.
• fadeOut: Desvanece (fade out) un elemento.
• slideIn: Desliza hacia adentro (slide in) un elemento.
• slideOut: Desliza hacia afuera (slide out) un elemento.

Opciones
........

• speed: Velocidad en la cual debería ocurrir la animación. Valores aceptados son
  ‘slow’, ‘fast’. No todos los efectos usan la opción 'speed'.
  
Ejemplo de uso
..............
Si uno estuviese usando el motor jQuery:

$this->Js->get(’#element’);
$result = $this->Js->effect(’fadeIn’);
// $result contains $("#foo").fadeIn();

JsHelper::event($type, $content, $options = array())
....................................................
Liga (bind) un evento a la selección actual. $type puede ser cualquiera de los 
eventos DOM normales ó un tipo de evento personalizado si su librería los soporta.
$content debería contener el cuerpo de la función para el callback. Los callbacks
serán envueltos con function (event) { ... } a menos que sea deshabilitado con 
$options.

Options
.......
•wrap: Si uno quiere al callback envuelto en una función anónima. (por defecto true)
•stop: Si uno quiere que el evento se detenga. (por defecto true)

Ejemplo de uso:

$this->Js->get(’#some-link’);
$this->Js->event(’click’, $this->Js->alert(’hey you!’));

Si uno estuviese usando la librería jQuery obtendría el siguiente código JavaScript:

$(’#some-link’).bind(’click’, function (event) {
  alert(’hey you!’);
  return false;
});

Puede quitar el 'return false;' pasando fijar la opción 'stop' a false: 

$this->Js->get(’#some-link’);
$this->Js->event(
  ’click’,
  $this->Js->alert(’hey you!’),
  array(’stop’ => false)
);

Si uno estuviese usando la librería jQuery debería agregar el siguiente código
JavaScript al buffer. El evento navegador por defecto es no cancelado:

$(’#some-link’).bind(’click’, function (event) {
  alert(’hey you!’);
});

JsHelper::domReady($callback)
.............................
Crea el evento especial 'DOM ready'. JsHelper::writeBuffer() envuelve automáticamente
los scripts buffered en un método domReady.

JsHelper::each($callback)
.........................
Crea un fragmento que itera sobre los elementos actualmente seleccionados, e 
inserta $callback. 

Ejemplo:

$this->Js->get(’div.message’);
$this->Js->each(’$(this).css({color: "red"});’);

Usar el motor jQuery crearía el siguiente JavaScript:

$(’div.message’).each(function () { 
  $(this).css({color: "red"}); 
});

JsHelper::alert($message)
.........................
Crea un fragmento JavaScript que contiene un fragmento alert(). Por defecto,
alert no hace buffer, y retorna el fragmento script:

$alert = $this->Js->alert(’Hey there’);

JsHelper::confirm($message)
...........................
Crea un fragmento JavaScript que contiene un fragmento confirm(). Por defecto, 
confirm no hace buffer, y retorna el fragmento script:

$alert = $this->Js->confirm(’Are you sure?’);

JsHelper::prompt($message, $default)
....................................
Crea un fragmento JavaScript que contiene un fragmento prompt(). Por defecto,
prompt no hace buffer, y retorna el fragmento script:

$prompt = $this->Js->prompt(’What is your favorite color?’, ’blue’);

JsHelper::submit($caption = null, $options = array())
.....................................................
Crea un botón input submit que habilita formularios enviados XmlHttpRequest. 
Las opciones pueden incluir ambos de esos para FormHelper::submit() y 
JsBaseEngine::request(), JsBaseEngine::event();   

El envío de formularios con este método, no puede enviar archivos. Los archivos
no se transfieren sobre XmlHttpRequest y requieren un iframe, ú otras 
configuraciones más especializadas.

Opciones
........
• url: La URL a la que quiere que envíe la petición XHR.
• confirm: Mensaje de confirmación exhibido antes de enviar la petición. Usar 
  confirm, no reemplaza ninguno de los métodos callback en el XmlHttpRequest generado.
• buffer: Inhabilita el buffering y retorna una etiqueta script en adición al enlace.
• wrapCallbacks: Se fija a false para inhabilitar envoltura de callback automática.

Ejemplo de uso:

echo $this->Js->submit(’Save’, array(’update’ => ’#content’));

Creará un botón de envío con un evento onclick anexado. El evento click será buffered
por defecto:

echo $this->Js->submit(’Save’, 
  array(
    ’update’ => ’#content’,
    ’div’ => false,
    ’type’ => ’json’,
    ’async’ => false
  )
);

Muestra como uno puede combinar opciones para ambos FormHelper::submit() and
JsHelper::request() al usar el submit.

JsHelper::link($title, $url = null, $options = array())
.......................................................
Crea un elemento anchor (ancla) HTML que tiene un evento click ligado a este. 
Las opciones pueden incluir ambos de esos HtmlHelper::link() y JsHelper::request(), 
JsHelper::event(), $options es un array de atributos html que son anexados al 
elemento anchor generado. Si una opción no es parte de los atributos estándar
ó $htmlAttributes este será pasado a JsHelper::request() como una opción. Si una
id no es suministrada, será creado uno generado aleatoriamente para cada enlace
generado.

Opciones
........
• confirm: Genera un diálog confirm() antes de enviar el evento.
• id: Usa un id personalizado.
• htmlAttributes: htmlAttributes adicionales no estándar. Los atributos estándar
  son clase, id, rel, title, escape, onblur y onfocus.
• buffer: Inhabilita el buffering y retorna una etiqueta script en adición al enlace.

Ejemplo de uso:

echo $this->Js->link(
  ’Page 2’,
  array(’page’ => 2),
  array(’update’ => ’#content’)
);

Creará un enlace apuntando a /page:2 y actualiza #content con la respuesta.

Uno puede usar la opción htmlAttributes para agregar atributos personalizados
adicionales:

echo $this->Js->link(’Page 2’, array(’page’ => 2), 
  array(
    ’update’ => ’#content’,
    ’htmlAttributes’ => array(’other’ => ’value’)
  )
);

Produce el siguiente HTML:

<a href="/posts/index/page:2" other="value">Page 2</a>

JsHelper::serializeForm($options = array())
...........................................
Serializa el formulario anexado a $selector. Pasa true para $isForm si la selección
actual es un elemento formulario. Convierte el formulario ó el elemento form 
anexado a la selección actual en un objeto string/json (dependiendo de la 
implementación de librería) para uso con operaciones XHR.

Opciones
........
• isForm: Es la selección actual un formulario, ó un input? (por defecto false)
• inline: Está la sentencia renderizada para usarse dentro de otra sentencia JS?
  (por defecto false)

Fijar inline == false le permite quitar la cola (trailing) ;. Útil cuando necesita
serializar un elemento form como parte de otra operación JavaScript, ó usar el
método serialize en un literal Object.

JsHelper::redirect($url)
........................
Redirige la página a $url usando window.location.

JsHelper::value($value)
.......................
Convierte una variable PHP-nativa de cualquier tipo a una representación 
JSON equivalente. Escapa cualquiera de los valores de string en strings 
compatibles con JSON. Los caracteres UTF-8 serán escapados.

Paginación AJAX
---------------
Semejante a la paginación AJAX en 1.2, uno puede usar JsHelper para manejar la
creación de enlaces de paginación AJAX en vez de enlaces HTML planos.

Hacer enlaces AJAX 
..................
Antes de que uno pueda crear enlaces AJAX uno debe incluir la librería JavaScript
que coincide con el adaptador que uno está usando con JsHelper. Por defecto JsHelper 
usa jQuery. Así en su layout incluir jQuery (ó cualquier librería que uno esté 
usando). También asegurarse de incluir RequestHandlerComponent en sus componentes.
Agregar lo siguiente a su controlador:

public $components = array(’RequestHandler’);
public $helpers = array(’Js’);

Luego enlazar la librería JavaScript que uno quiere usar. Para esto estaremos usando
jQuery:

echo $this->Html->script(’jquery’);

Similar a 1.2 necesita decirle al PaginatorHelper que uno quiere hacer enlaces
JavaScript mejorados en vez de HTML planos. Para hacer esto usar options():

$this->Paginator->options(
  array(
    ’update’ => ’#content’,
    ’evalScripts’ => true
  )
);

El PaginatorHelper sabe ahora como hacer enlaces JavaScript mejorados, y que 
aquellos enlaces deberían actualizar el elemento #content. Por supuesto este
elemento debe existir, y con frecuencia las veces que uno quiere envolver 
$content_for_layout con un div que coincide con la id usada para la opción update.
Uno también debería fijar evalScripts a true si uno está usando los adaptadores
Mootools ó Prototype, sin evalScripts estas librerías no serán capaces de encadenar
peticiones juntas. La opción indicator no es soportada por JsHelper y será ignorada.

Uno crea luego todos los enlaces que necesite para sus características de paginación.
Ya que JsHelper hace buffer automático de todo el contenido de script generado para
reducir el nro. de etiquetas <script> en su código fuente uno debe escribir el buffer.

Al fondo de su archivo de vista asegúrese de incluir:

echo $this->Js->writeBuffer();

Si uno omite esto no será capaz de encadenar enlaces de paginación AJAX. Cuando
uno escribe el buffer, también es limpiado (cleared), así uno no tiene que 
preocuparse respecto al mismo JavaScript siendo producido 2 veces.

Agregar efectos y transiciones
..............................
Ya que el indicador ya no es soportado, debe agregar cualquiera de los efectos
indicador uno mismo:

<!DOCTYPE html>
<html>
  <head>
    <?php echo $this->Html->script(’jquery’); ?>
    //more stuff here.
  </head>
  <body>
    <div id="content">
      <?php echo $this->fetch(’content’); ?>
    </div>
      <?php
        echo $this->Html->image(
          ’indicator.gif’,
          array(’id’ => ’busy-indicator’)
        );
      ?>
  </body>
</html>

Recordar poner el archivo indicator.gif dentro de la carpeta app/webroot/img. Puede
ver una situación donde indicator.gif se exhibe inmediatamente sobre la carga de
la página. Necesita poner este CSS #busy-indicator { display:none; } en su archivo
CSS principal.

Con el layout de arriba, hemos incluído un archivo de imagen indicador, que exhibirá
una animación indicadora de ocupado (busy) que mostraremos y esconderemos con el
JsHelper. Para hacer eso necesitaremos actualizar nuestra función options():

$this->Paginator->options(
  array(                 
    ’update’ => ’#content’,
    ’evalScripts’ => true,
    ’before’ => $this->Js->get(’#busy-indicator’)->effect(
      ’fadeIn’,
      array(’buffer’ => false)
    ),
    ’complete’ => $this->Js->get(’#busy-indicator’)->effect(
      ’fadeOut’,
      array(’buffer’ => false)
    ),
  )
);

Esto mostrará / esconderá el elemento indicador de ocupado antes y después que
el div #content es actualizado. Aunque el indicador ha sido quitado, las 
características nuevas ofrecidas por JsHelper permiten más control y que sean 
creados más efectos complejos.

NumberHelper
------------
class NumberHelper(View $view, array $settings = array())
.........................................................
NumberHelper contiene métodos convenientes que habilitan exhibir números en 
formatos comunes en sus vistas. Estos métodos incluyen modos de formatear monedas,
porcentajes, tamaño de datos, formatear números a precisiones específicas y también
darle a uno más flexibilidad con números formateados.

Cambiado en v.2.1: NumberHelper ha sido refactorizado en la clase CakeNumber para
permitir un uso fácil fuera de la capa View. Dentro de una vista, estos métodos
son accesibles vía la clase NumberHelper y uno puede llamarla como si llamara a
un método helper normal: $this->Number->method($args);.

Todas estas funciones retornan el número formateado; Estos no hacen echo automático
de la salida dentro de la vista.

NumberHelper::currency(mixed $number, string $currency = ‘USD’, array $options = array())
.........................................................................................

Parámetros
..........
• $number (float): El valor a convertir.
• $currency (string): El formato de moneda conocido a usar.
• $options (array): Opciones, ver abajo.

Este método se usa para exhibir un número en formatos de moneda común (EUR,GBP,USD).
El uso en una vista luce como:

// called as NumberHelper
echo $this->Number->currency($number, $currency);

// called as CakeNumber
App::uses(’CakeNumber’, ’Utility’);
echo CakeNumber::currency($number, $currency);

El 1er parámetro, $number, debería ser un número en punto flotante que representa
la cantidad de dinero que uno está expresando. El 2do parámetro se usa para elegir
un esquema de formato de moneda predefinido:

---------------------------------------------------
| $currency | 1234.56, formatted by currency type |
---------------------------------------------------
| EUR       | C1.234,56                           |
| GBP       | £1,234.56                           |
| USD       | $1,234.56                           |
---------------------------------------------------

El 3er parámetor es un array de opciones para definir adicionalmente la salida.
Siguientes opciones disponibles:

-------------------------------------------------------------------------------------------
| Opción            | Descripción                                                         |
-------------------------------------------------------------------------------------------
| before            | El símbolo de moneda para poner antes de los números. Ej.: '$'      |
|                   |                                                                     |
| after             | El símbolo de moneda para poner después de los números decimales.   |
|                   | Ej.: 'c'. Se fija a boolean false para no usar símbolos decimales.  |                                                                  |
|                   | Ej.: 0.35 => $0.35.                                                 |
|                   |                                                                     |
| zero              | El texto a usar para valores 0, puede ser un string ó un nro.       |
|                   | Ej.: 0, 'Free!'                                                     |
|                   |                                                                     |
| places            | Número de ubicaciones decimales a usar. Ej.: 2                      |
|                   |                                                                     |
| thousands         | Separador miles. Ej.: ','                                           |
|                   |                                                                     |
| decimals          | Símbolo de separador decimal. Ej.: '.'                              |
|                   |                                                                     |
| negative          | Símbolo para números negativos. Si es igual a '()', el número       |
|                   | será envuelto con ( y )                                             |
|                   |                                                                     |
| escape            | Debería ser la salida escapado con htmlentity? Por defecto en true  | 
|                   |                                                                     |
| wholeSymbol       | String a usar para todos los números. Ej.: 'dollars'                |
|                   |                                                                     |
| wholePosition     | Ya sea 'antes' ó 'después' de ubicar el símbolo entero              |
|                   |                                                                     |
| fractionSymbol    | String a usar para números fraccionales. Ej: 'cents' (centavos)     |
|                   |                                                                     |
| fractionPosition  | Ya sea 'antes' ó 'después' de colocar el símbolo de fracción        |
|                   |                                                                     |
| fractionExponent  | Exponente fracción de esta moneda específica. Por defecto en 2      |
|                   |                                                                     |
-------------------------------------------------------------------------------------------

Si un valor $currency no reconocido es suministrado, este es preanexado a un
número formateado en USD. Ej.:

// called as NumberHelper
echo $this->Number->currency(’1234.56’, ’FOO’);

// Outputs
FOO 1,234.56

// called as CakeNumber
App::uses(’CakeNumber’, ’Utility’);
echo CakeNumber::currency(’1234.56’, ’FOO’);

Cambiado en v.2.4: Se agregó la opción fractionExponent.

NumberHelper::defaultCurrency(string $currency)
...............................................

Parámetros
..........
• $currency (string): Fija una moneda conocida para CakeNumber::currency().

Setter/getter para la moneda por defecto. Este quita la necesidad de siempre
pasar la moneda a CakeNumber::currency() y cambiar todas las salidas de moneda
fijando otro valor por defecto.

Este método se agregó en v.2.3.

NumberHelper::addFormat(string $formatName, array $options)
...........................................................
Parámetros
..........

• $formatName (string): El nombre de formato a usarse en el futuro.

• $options (array): El array de opciones para este formato. Usa las mismas claves
  $options que CakeNumber::currency().

Agregar un formato de moneda al helper Number. Facilita la reutilización de 
formatos de moneda:

// called as NumberHelper
$this->Number->addFormat('BRL', array('before' => 'R$', 'thousands' => '.', 'decimals' => ','));
App::uses(’CakeNumber’, ’Utility’);
CakeNumber::addFormat('BRL', array('before' => 'R$', 'thousands' => '.', 'decimals' => ','));

Puede ahora usar a BRL como una forma corta al formatear montos de moneda:

// called as NumberHelper
echo $this->Number->currency($value, ’BRL’);

// called as CakeNumber
App::uses(’CakeNumber’, ’Utility’);
echo CakeNumber::currency($value, ’BRL’);
Added formats are merged with the following defaults:
array(
  ’wholeSymbol’ => ’’,
  ’wholePosition’ => ’before’,
  ’fractionSymbol’ => false,
  ’fractionPosition’ => ’after’,
  ’zero’ => 0,
  ’places’ => 2,
  ’thousands’ => ’,’,
  ’decimals’ => ’.’,
  ’negative’ => ’()’,
  ’escape’ => true,
  ’fractionExponent’ => 2
)

NumberHelper::precision(mixed $number, int $precision = 3)
..........................................................

Parámetros
..........
• $number (float): Valor a convertir
• $precision (integer): El número de lugares decimales a exhibir

Este método exhibe un número con el monto de precisión especificado (lugares
decimales). Este redondeará en orden de mantener el nivel de precisión definida:

// called as NumberHelper
echo $this->Number->precision(456.91873645, 2);

// Outputs
456.92

// called as CakeNumber
App::uses(’CakeNumber’, ’Utility’);
echo CakeNumber::precision(456.91873645, 2);

NumberHelper::toPercentage(mixed $number, int $precision = 2, array $options = array())
.......................................................................................
Parameters
• $number (float) – The value to covert.
• $precision (integer) – The number of decimal places to display.
• $options (array) – Options, see below.
Option Description
multiply
Boolean to indicate whether the value has to be multiplied by 100. Useful for decimal
percentages.
Like precision(), this method formats a number according to the supplied precision (where numbers
are rounded to meet the given precision). This method also expresses the number as a percentage and
prepends the output with a percent sign.:
// Called as NumberHelper. Output: 45.69%
echo $this->Number->toPercentage(45.691873645);
// Called as CakeNumber. Output: 45.69%
App::uses(’CakeNumber’, ’Utility’);
echo CakeNumber::toPercentage(45.691873645);
// Called with multiply. Output: 45.69%
echo CakeNumber::toPercentage(0.45691, 2, array(
’multiply’ => true
));
New in version 2.4: The $options argument with the multiply option was added.
NumberHelper::fromReadableSize(string $size, $default)
Parameters
• $size (string) – The formatted human readable value.
This method unformats a number from a human readable byte size to an integer number of bytes.
New in version 2.3: This method was added in 2.3
NumberHelper::toReadableSize(string $dataSize)
Parameters
• $dataSize (string) – The number of bytes to make readable.
This method formats data sizes in human readable forms. It provides a shortcut way to convert bytes
to KB, MB, GB, and TB. The size is displayed with a two-digit precision level, according to the size
of data supplied (i.e. higher sizes are expressed in larger terms):

SEGUIR(168/203)