VISTAS
======
Las vistas son responsables de generar la salida específica requerida para la
petición. Posibles formas:

. HTML
. XML
. JSON
. Archivos de streaming
. Descarga de PDF

CakePHP viene con algunas clases de View incorporadas para manejar los escenarios
de renderización más comunes:

. Para crear web services XML ó JSON puede usar vistas XML ó JSON
. Para servir archivos protegidos, ó archivos generados dinámicamente, puede usar
  Sending files
. Para crear vistas con temas múltiples, puede usar Themes 

Plantillas de Vista
-------------------
Por defecto los archivos de vista de CakePHP están escritos en PHP plano y tienen
extensión .ctp (Plantilla CakePHP). Estos archivos contienen toda la lógica de
presentación necesaria para obtener los datos que este recibió del controlador
en un formato que está listo para la audiencia a la que uno sirve.

Un archivo de vista se almacena en /app/View/, en una subcarpeta nombrada después
del controlador que usa el archivo. Tiene un nombre de archivo correspondiente
a su acción. Ej.: el archivo de vista para la acción 'view()' del controlador de
'Products' se encontraría normalmente en /app/View/Products/view.ctp. 

La capa de vista en CakePHP puede hacerse de un número de partes diferentes:

. Vistas (Views): las Views son parte de la página que es única a la acción que
se está corriendo. Forman la carne de la respuesta de su aplicación.

. Elements: pequeños fragmentos de código de vista reutilizables. Los elementos
son usualmente renderizados dentro de vistas.

. Layouts: archivos de vista que contienen código de presentación que envuelve
varias interfaces en su aplicación. La mayoría de las vistas son renderizadas
dentro de un layout.

. helpers: estas clases encapsulan lógica de vista que es necesaria en varios 
lugares en la capa de vista. Estos pueden ayudar a construir formularios, construir
funcionalidad AJAX, datos de paginación del modelo, ó servir alimentaciones RSS.
  
Extender Vistas
---------------
Las extensiones de Vista le permite envolver una vista en otra. Ej.: su aplicación
tiene una barra lateral que necesita cambiar dependiendo de la vista específica
siendo renderizada. Extender un archivo de vista común, puede evitar repetir
el marcado común para su barra lateral, y sólo definir las partes que cambian:

// app/View/Common/view.ctp
<h1><?php echo $this->fetch(’title’); ?></h1>
<?php echo $this->fetch(’content’); ?>

<div class="actions">
  <h3>Related actions</h3>
  <ul>
    <?php echo $this->fetch(’sidebar’); ?>
  </ul>
</div>

El archivo de vista de arriba podría usarse como una vista padre. Esta espera que
la vista que extiende definirá los bloques de título y barra lateral. El
bloque de contenido contendrá todo el contenido no capturado de la vista que se
extiende. Asumiendo que nuestro archivo de vista tiene una variable $post con los
datos sobre nuestro post, la vista luciría:

<?php
  // app/View/Posts/view.ctp
  $this->extend(’/Common/view’);
  $this->assign(’title’, $post);
  $this->start(’sidebar’);
?>
<li>
  <?php
    echo $this->Html->link(
      ’edit’, array(
        ’action’ => ’edit’,
        $post[’Post’][’id’]
      )
    ); 
  ?>
</li>
<?php $this->end(); ?>
// The remaining content will be available as the ’content’ block
// in the parent view.
<?php echo h($post[’Post’][’body’]);

La vista post de arriba muestra como uno puede extender una vista, y popular un
set de bloques. Cualquier contenido ya no definido en un bloque definido será
capturado y puesto en un bloque especial nombrado 'content'. Cuando una vista
contiene una llamada a extend(), la ejecución continúa hasta el fondo del 
archivo de vista actual. Una vez que este está completo, la vista extendida 
será renderizada. Llamar a extend() más de una vez en un archivo de vista 
redefinirá la vista padre que se procesará luego:

$this->extend(’/Common/view’);
$this->extend(’/Common/index’);

El resultado de arriba resultará en /Common/index.ctp siendo renderizado como 
la vista padre a la vista actual.

Puede anidar vistas extendidas tantas veces como necesite. Cada vista puede 
extender otra vista si se desea. Cada vista padre obtendrá el contenido 
de la vista previa así como el bloque content.

Nota: Debería evitar usar 'content' como un nombre de bloque en su aplicación.
CakePHP lo usa para contenido sin capturar en vistas extendidas.

Usar bloques de vista
---------------------
Los bloques de vista reemplazan $scripts_for_layout y proveen una API flexible
que le permite definir ranuras ó bloques en sus vistas/layouts que serán definidas
en algún lado. Ej.: los bloques son ideales para implementar cosas como barras
laterales, ó regiones para cargar bienes (assets) en el fondo / cima del layout.
Los bloques pueden ser definidos de 2 modos: ya sea como un bloque de captura,
ó por asignación directa. Los métodos start(), append() y end() le permiten 
trabajar con bloques de captura:

// create the sidebar block.
$this->start(’sidebar’);
echo $this->element(’sidebar/recent_topics’);
echo $this->element(’sidebar/recent_comments’);
$this->end();

// Append into the sidebar later on.
$this->append(’sidebar’);
echo $this->element(’sidebar/popular_topics’);
$this->end();

Puede también anexar dentro de un bloque usando start() en múltiples ocasiones.
assign() puede ser usado para limpiar (clear) ó sobreescribir un bloque a la vez:

// Clear the previous content from the sidebar block.
$this->assign(’sidebar’, ’’);

En 2.3, se agregaron métodos nuevos para trabajar con bloques. El método prepend()
se agregó al contenido prepend() para un bloque existente:

// Prepend to sidebar
$this->prepend(’sidebar’, ’this content goes on top of sidebar’);

El método startIfEmpty() puede usarse para iniciar un bloque sólo si este está
vacío ó indefinido. Si el bloque ya existe, el contenido capturado será 
descartado. Esto es útil cuando quiere definir condicionalmente el contenido por
defecto para un bloque si este no existe realmente:
 
// In a view file.
// Create a navbar block
$this->startIfEmpty(’navbar’);
echo $this->element(’navbar’);
echo $this->element(’notifications’);
$this->end();

// In a parent view/layout
<?php $this->startIfEmpty(’navbar’); ?>
<p>If the block is not defined by now - show this instead</p>
<?php $this->end(); ?>
// Somewhere later in the parent view/layout
echo $this->fetch(’navbar’);

En el ej. de arriba, el bloque navbar solo contendrá el contenido agregado en 
la 1er sección. Ya que el bloque fue definido en la vista hijo, el contenido por
defecto con <p> será descartado.

Nota: Debería evitar usar content como un nombre de bloque. Este es usado 
por CakePHP internamente para vistas extendidas, y contenido de vista en el layout.

Exhibir bloques
...............
Puede exhibir bloques con el método fetch(), el cual da salida a un bloque, retornando
'' si un bloque no existe:

echo $this->fetch(’sidebar’);

Puede también usar fetch para mostrar contenido condicionalmente que que debería
rodear un bloque si este existe. Esto es útil en layouts, ó vistas extendidas
donde uno quiere mostrar encabezados ú otro marcado de forma condicional:

// in app/View/Layouts/default.ctp
<?php if ($this->fetch(’menu’)): ?>
  <div class="menu">
    <h3>Menu options</h3>
    <?php echo $this->fetch(’menu’); ?>
  </div>
<?php endif; ?>

Como en 2.3.0, puede también proveer un valor por defecto para un bloque si este
no tienen ningún contenido. Esto le permite agregar contenido de posición 
(placeholder) para estados vacíos. Puede proveer un valor por defecto usando
el 2do argumento:

<div class="shopping-cart">
  <h3>Your Cart</h3>
  <?php echo $this->fetch(’cart’, ’Your cart is empty’); ?>
</div>

El argumento $default se agregó en 2.3.

Using blocks for script and CSS files
-------------------------------------
Los bloques reemplazan la variable de layout $scripts_for_layout deprecada. En
vez de eso debería usar bloques. El HtmlHelper se une en bloques de vista, y sus
métodos script(), css(), y meta() pueden cada uno actualizar un bloque con el 
mismo nombre cuando se usa con la opción inline = false:

<?php
  // in your view file
  $this->Html->script(’carousel’, array(’inline’ => false));
  $this->Html->css(’carousel’, null, array(’inline’ => false));
?>
// In your layout file.
<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <?php echo $this->fetch(’script’); ?>
    <?php echo $this->fetch(’css’); ?>
  </head>
  // rest of the layout follows

El HtmlHelper también le permite controlar a que bloque van los scripts y CSS:

// in your view
$this->Html->script(’carousel’, array(’block’ => ’scriptBottom’));

// in your layout
echo $this->fetch(’scriptBottom’);

Layouts
.......
Un layout contiene código de presentación que se envuelve alrededor de una vista.
Todo lo que querría ver en todas sus vistas debería ponerse en el layout.

El layout por defecto de CakePHP se ubica en /app/View/Layouts/default.ctp. Si
quiere cambiar completamente como se ve su aplicación, empezar con esto, ya que
el código de vista renderizado por controlador se ubica dentro del layout por 
defecto cuando la página es renderizada.

Otros archivos de layout debería ubicarse en /app/View/Layouts. Al crear un layout,
necesita decirle a CakePHP donde poner la salida de sus vistas. Para hacerlo,
asegurarse de que su layout incluya un lugar para $this->fetch(’content’). Ej.
de como debería lucir un layout por defecto:

<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <!-- Include external files and scripts here (See HTML helper for more info.) -->
    <?php
      echo $this->fetch(’meta’);
      echo $this->fetch(’css’);
      echo $this->fetch(’script’);
    ?>
  </head>
  <body>
  <!-- If you’d like some sort of menu to show up on all of your views, include it here -->
    <div id="header">
      <div id="menu">...</div>
    </div>
    <!-- Here’s where I want my views to be displayed -->
    <?php echo $this->fetch(’content’); ?>
    <!-- Add a footer to each displayed page -->
    <div id="footer">...</div>
  </body>
</html>

Nota: fetch(’content’) es un reemplazo para $content_for_layout y las líneas
fetch(’meta’), fetch(’css’) y fetch(’script’) son contenidas en la variable
$scripts_for_layout.

Los bloques script, css y meta contienen cualquier contenido definido en las 
vistas usando el helper HTML incorporado. Útil para incluir archivos CSS y 
Javascript desde vistas.

Nota: Al usar HtmlHelper::css() ó HtmlHelper::script() en archivos de vista,
especificar 'false' para la opción 'inline' para poner la fuente HTML en un 
bloque con el mismo nombre.   

El bloque 'content' contiene los contenidos de la vista renderizada.

$title_for_layout contiene el título de página. Esta variable es generada 
automáticamente, pero uno puede redefinirla fijándola en su controlador / vista.

Fijar el título para el layout es más fácil hacerlo en el controlador, fijando
la variable $title_for_layout:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
  }
}

Puede también fijar la variable title_for_layout desde dentro del archivo de vista:

$this->set(’title_for_layout’, $titleContent);

Puede crear varios layouts como quiera: sólo ubíquelos en el directorio app/View/Layouts,
e intercambiar entre ellos dentro de sus acciones controlador usando la propiedad
$layout de la vista:

// from a controller
public function admin_view() {
  // stuff
  $this->layout = ’admin’;
}

// from a view file
$this->layout = ’loggedin’;

Ej.: si una sección de mi sitio incluyó un espacio para banner de avisos (ad), puedo
crear un layout nuevo con el menor espacio de publicidad y especificarlo como el
layout para todas las acciones de controlador usando algo como:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
    $this->layout = ’default_small_ad’;
  }

  public function view_image() {
    $this->layout = ’image’;
    //output user image
  }
}

CakePHP tiene 2 layouts núcleo característicos (junto al layout por defecto de
CakePHP) que uno puede usar:

. ‘ajax’: útil para elaboración de respuestas AJAX - es un layout vacío (la
  mayoría de las llamadas AJAX sólo requieren un pequeño marcado en el retorno.
  en vez de una interfaz completamente renderizada).  

. ‘flash’: se usa para mensajes mostrados por el método Controller::flash().

Los otros 3 layouts, xml, js y rss existen en el núcleo para servir contenido 
que no es text/html.

Usar layouts desde plugins
..........................
Si quiere usar un layout que existe en un plugin, puede usar sintaxis de plugin.
Ej.: para usar el layout de contenido desde el plugin Contacts:

class UsersController extends AppController {
  public function view_active() {
    $this->layout = ’Contacts.contact’;
  }
}

Elementos
---------
Algunas aplicaciones tienen pequeños bloques de código de presentación que 
necesitan repetirse de página a página, a veces en lugares diferentes del layout.
CakePHP puede ayudarle a repetir partes de su página web que necesitan reusarse.
Estas partes reutilizables son llamadas 'Elementos'. Avisos, cajas de ayuda,
controles de navegación, menús extra, formularios de login, y callouts son 
con frecuencia implementados en CakePHP como elementos. Los 'Elementos' pueden
usarse para hacer una vista más legible, poniendo el renderizado de repetir 
elementos en su propio archivo. Estos pueden también ayudarlo a reutilizar
fragmentos de contenido en su aplicación.

Los 'Elementos' viven en la carpeta /app/View/Elements/, y tienen la extensión de
archivo .ctp. Son salida usando el método element de la vista:

echo $this->element(’helpbox’);

Pasar variables dentro de un Elemento
.....................................
Puede pasar datos a un elemento a través del 2do argumento del elemento:

echo $this->element(’helpbox’, array(
  "helptext" => "Oh, this text is very helpful."
));

Dentro del archivo elemento, todas las variables pasadas están disponibles como 
miembros del array de parámetro (del mismo modo que Controller::set() en el 
controlador funciona con los archivos de vista). En el ej. de arriba, el archivo
/app/View/Elements/helpbox.ctp puede usar la variable $helptext:

// inside app/View/Elements/helpbox.ctp
echo $helptext; //outputs "Oh, this text is very helpful."

El método View::element() también soporta opciones para el elemento. Las opciones
soportadas son ‘cache’ y ‘callbacks’. Ej.:

echo $this->element(’helpbox’, 
  array(
    "helptext" => "This is passed to the element as $helptext",
    "foobar" => "This is passed to the element as $foobar",
  ),
  array(
    // uses the "long_view" cache configuration
    "cache" => "long_view",
    // set to true to have before/afterRender called for the element
    "callbacks" => true
  )
);

El cacheo de elemento es facilitado a través de la clase Cache. Puede configurar
elementos para ser almacenados en cualquier configuración de Cache que ha 
establecido. Esto le da flexibilidad para decidir donde y por cuanto los elementos
son almacenados. Para cachear versiones diferentes del mismo elemento en una
aplicación, proveer un valor de clave de cache único usando el formato:

$this->element(’helpbox’, array(), array(
  "cache" => array(’config’ => ’short’, ’key’ => ’unique value’)
  )
);

You can take full advantage of elements by using requestAction(), which fetches view variables from
a controller action and returns them as an array. This enables your elements to perform in true MVC style.
Create a controller action that prepares the view variables for your elements, then call requestAction()
inside the second parameter of element() to feed the element the view variables from your controller.

To do this, in your controller add something like the following for the Post example:

class PostsController extends AppController {
  // ...
  public function index() {
    $posts = $this->paginate();
    if ($this->request->is(’requested’)) {
      return $posts;
    } else {
      $this->set(’posts’, $posts);
    }
  }
}

And then in the element we can access the paginated posts model. To get the latest five posts in an ordered
list, we would do something like the following:

<h2>Latest Posts</h2>
<?php
  $posts = $this->requestAction(
    ’posts/index/sort:created/direction:asc/limit:5’
  );
?>
<ol>
<?php foreach ($posts as $post): ?>
<li><?php echo $post[’Post’][’title’]; ?></li>
<?php endforeach; ?>
</ol>

Caching Elements
................
Puede tomar ventaja del cacheo de vista de CakePHP si suministra un parámetro de
caché. Si se lo fija a true, cacheará el elemento en la configuración Cache por
'defecto'. Sino, puede setear que configuración de cache debería usarse. Ej. de
cachear un elemento:

echo $this->element(’helpbox’, array(), array(’cache’ => true));

Si renderiza el mismo elemento más de una vez en una vista y tiene el cacheo 
habilitado, fijar el parámetro 'key' a un nombre diferente cada vez. Esto evitará
que cada llamada sucesiva sobreescriva el resultado cacheado de la llamada del
element() previo. Ej.:

SEGUIR(94)