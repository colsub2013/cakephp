VISTAS
======
Las vistas son responsables de generar la salida específica requerida para la
petición. Posibles formas:

. HTML
. XML
. JSON
. Archivos de streaming
. Descarga de PDF

CakePHP viene con algunas clases de View incorporadas para manejar los escenarios
de renderización más comunes:

. Para crear web services XML ó JSON puede usar vistas XML ó JSON
. Para servir archivos protegidos, ó archivos generados dinámicamente, puede usar
  Sending files
. Para crear vistas con temas múltiples, puede usar Themes 

Plantillas de Vista
-------------------
Por defecto los archivos de vista de CakePHP están escritos en PHP plano y tienen
extensión .ctp (Plantilla CakePHP). Estos archivos contienen toda la lógica de
presentación necesaria para obtener los datos que este recibió del controlador
en un formato que está listo para la audiencia a la que uno sirve.

Un archivo de vista se almacena en /app/View/, en una subcarpeta nombrada después
del controlador que usa el archivo. Tiene un nombre de archivo correspondiente
a su acción. Ej.: el archivo de vista para la acción 'view()' del controlador de
'Products' se encontraría normalmente en /app/View/Products/view.ctp. 

La capa de vista en CakePHP puede hacerse de un número de partes diferentes:

. Vistas (Views): las Views son parte de la página que es única a la acción que
se está corriendo. Forman la carne de la respuesta de su aplicación.

. Elements: pequeños fragmentos de código de vista reutilizables. Los elementos
son usualmente renderizados dentro de vistas.

. Layouts: archivos de vista que contienen código de presentación que envuelve
varias interfaces en su aplicación. La mayoría de las vistas son renderizadas
dentro de un layout.

. helpers: estas clases encapsulan lógica de vista que es necesaria en varios 
lugares en la capa de vista. Estos pueden ayudar a construir formularios, construir
funcionalidad AJAX, datos de paginación del modelo, ó servir alimentaciones RSS.
  
Extender Vistas
---------------
Las extensiones de Vista le permite envolver una vista en otra. Ej.: su aplicación
tiene una barra lateral que necesita cambiar dependiendo de la vista específica
siendo renderizada. Extender un archivo de vista común, puede evitar repetir
el marcado común para su barra lateral, y sólo definir las partes que cambian:

// app/View/Common/view.ctp
<h1><?php echo $this->fetch(’title’); ?></h1>
<?php echo $this->fetch(’content’); ?>

<div class="actions">
  <h3>Related actions</h3>
  <ul>
    <?php echo $this->fetch(’sidebar’); ?>
  </ul>
</div>

El archivo de vista de arriba podría usarse como una vista padre. Esta espera que
la vista que extiende definirá los bloques de título y barra lateral. El
bloque de contenido contendrá todo el contenido no capturado de la vista que se
extiende. Asumiendo que nuestro archivo de vista tiene una variable $post con los
datos sobre nuestro post, la vista luciría:

<?php
  // app/View/Posts/view.ctp
  $this->extend(’/Common/view’);
  $this->assign(’title’, $post);
  $this->start(’sidebar’);
?>
<li>
  <?php
    echo $this->Html->link(
      ’edit’, array(
        ’action’ => ’edit’,
        $post[’Post’][’id’]
      )
    ); 
  ?>
</li>
<?php $this->end(); ?>
// The remaining content will be available as the ’content’ block
// in the parent view.
<?php echo h($post[’Post’][’body’]);

La vista post de arriba muestra como uno puede extender una vista, y popular un
set de bloques. Cualquier contenido ya no definido en un bloque definido será
capturado y puesto en un bloque especial nombrado 'content'. Cuando una vista
contiene una llamada a extend(), la ejecución continúa hasta el fondo del 
archivo de vista actual. Una vez que este está completo, la vista extendida 
será renderizada. Llamar a extend() más de una vez en un archivo de vista 
redefinirá la vista padre que se procesará luego:

$this->extend(’/Common/view’);
$this->extend(’/Common/index’);

El resultado de arriba resultará en /Common/index.ctp siendo renderizado como 
la vista padre a la vista actual.

Puede anidar vistas extendidas tantas veces como necesite. Cada vista puede 
extender otra vista si se desea. Cada vista padre obtendrá el contenido 
de la vista previa así como el bloque content.

Nota: Debería evitar usar 'content' como un nombre de bloque en su aplicación.
CakePHP lo usa para contenido sin capturar en vistas extendidas.

Usar bloques de vista
---------------------
Los bloques de vista reemplazan $scripts_for_layout y proveen una API flexible
que le permite definir ranuras ó bloques en sus vistas/layouts que serán definidas
en algún lado. Ej.: los bloques son ideales para implementar cosas como barras
laterales, ó regiones para cargar bienes (assets) en el fondo / cima del layout.
Los bloques pueden ser definidos de 2 modos: ya sea como un bloque de captura,
ó por asignación directa. Los métodos start(), append() y end() le permiten 
trabajar con bloques de captura:

// create the sidebar block.
$this->start(’sidebar’);
echo $this->element(’sidebar/recent_topics’);
echo $this->element(’sidebar/recent_comments’);
$this->end();

// Append into the sidebar later on.
$this->append(’sidebar’);
echo $this->element(’sidebar/popular_topics’);
$this->end();

Puede también anexar dentro de un bloque usando start() en múltiples ocasiones.
assign() puede ser usado para limpiar (clear) ó sobreescribir un bloque a la vez:

// Clear the previous content from the sidebar block.
$this->assign(’sidebar’, ’’);

En 2.3, se agregaron métodos nuevos para trabajar con bloques. El método prepend()
se agregó al contenido prepend() para un bloque existente:

// Prepend to sidebar
$this->prepend(’sidebar’, ’this content goes on top of sidebar’);

El método startIfEmpty() puede usarse para iniciar un bloque sólo si este está
vacío ó indefinido. Si el bloque ya existe, el contenido capturado será 
descartado. Esto es útil cuando quiere definir condicionalmente el contenido por
defecto para un bloque si este no existe realmente:
 
// In a view file.
// Create a navbar block
$this->startIfEmpty(’navbar’);
echo $this->element(’navbar’);
echo $this->element(’notifications’);
$this->end();

// In a parent view/layout
<?php $this->startIfEmpty(’navbar’); ?>
<p>If the block is not defined by now - show this instead</p>
<?php $this->end(); ?>
// Somewhere later in the parent view/layout
echo $this->fetch(’navbar’);

En el ej. de arriba, el bloque navbar solo contendrá el contenido agregado en 
la 1er sección. Ya que el bloque fue definido en la vista hijo, el contenido por
defecto con <p> será descartado.

Nota: Debería evitar usar content como un nombre de bloque. Este es usado 
por CakePHP internamente para vistas extendidas, y contenido de vista en el layout.

Exhibir bloques
...............
Puede exhibir bloques con el método fetch(), el cual da salida a un bloque, retornando
'' si un bloque no existe:

echo $this->fetch(’sidebar’);

Puede también usar fetch para mostrar contenido condicionalmente que que debería
rodear un bloque si este existe. Esto es útil en layouts, ó vistas extendidas
donde uno quiere mostrar encabezados ú otro marcado de forma condicional:

// in app/View/Layouts/default.ctp
<?php if ($this->fetch(’menu’)): ?>
  <div class="menu">
    <h3>Menu options</h3>
    <?php echo $this->fetch(’menu’); ?>
  </div>
<?php endif; ?>

Como en 2.3.0, puede también proveer un valor por defecto para un bloque si este
no tienen ningún contenido. Esto le permite agregar contenido de posición 
(placeholder) para estados vacíos. Puede proveer un valor por defecto usando
el 2do argumento:

<div class="shopping-cart">
  <h3>Your Cart</h3>
  <?php echo $this->fetch(’cart’, ’Your cart is empty’); ?>
</div>

El argumento $default se agregó en 2.3.

Using blocks for script and CSS files
-------------------------------------
Los bloques reemplazan la variable de layout $scripts_for_layout deprecada. En
vez de eso debería usar bloques. El HtmlHelper se une en bloques de vista, y sus
métodos script(), css(), y meta() pueden cada uno actualizar un bloque con el 
mismo nombre cuando se usa con la opción inline = false:

<?php
  // in your view file
  $this->Html->script(’carousel’, array(’inline’ => false));
  $this->Html->css(’carousel’, null, array(’inline’ => false));
?>
// In your layout file.
<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <?php echo $this->fetch(’script’); ?>
    <?php echo $this->fetch(’css’); ?>
  </head>
  // rest of the layout follows

El HtmlHelper también le permite controlar a que bloque van los scripts y CSS:

// in your view
$this->Html->script(’carousel’, array(’block’ => ’scriptBottom’));

// in your layout
echo $this->fetch(’scriptBottom’);

Layouts
.......
Un layout contiene código de presentación que se envuelve alrededor de una vista.
Todo lo que querría ver en todas sus vistas debería ponerse en el layout.

El layout por defecto de CakePHP se ubica en /app/View/Layouts/default.ctp. Si
quiere cambiar completamente como se ve su aplicación, empezar con esto, ya que
el código de vista renderizado por controlador se ubica dentro del layout por 
defecto cuando la página es renderizada.

Otros archivos de layout debería ubicarse en /app/View/Layouts. Al crear un layout,
necesita decirle a CakePHP donde poner la salida de sus vistas. Para hacerlo,
asegurarse de que su layout incluya un lugar para $this->fetch(’content’). Ej.
de como debería lucir un layout por defecto:

<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <!-- Include external files and scripts here (See HTML helper for more info.) -->
    <?php
      echo $this->fetch(’meta’);
      echo $this->fetch(’css’);
      echo $this->fetch(’script’);
    ?>
  </head>
  <body>
  <!-- If you’d like some sort of menu to show up on all of your views, include it here -->
    <div id="header">
      <div id="menu">...</div>
    </div>
    <!-- Here’s where I want my views to be displayed -->
    <?php echo $this->fetch(’content’); ?>
    <!-- Add a footer to each displayed page -->
    <div id="footer">...</div>
  </body>
</html>

Nota: fetch(’content’) es un reemplazo para $content_for_layout y las líneas
fetch(’meta’), fetch(’css’) y fetch(’script’) son contenidas en la variable
$scripts_for_layout.

Los bloques script, css y meta contienen cualquier contenido definido en las 
vistas usando el helper HTML incorporado. Útil para incluir archivos CSS y 
Javascript desde vistas.

Nota: Al usar HtmlHelper::css() ó HtmlHelper::script() en archivos de vista,
especificar 'false' para la opción 'inline' para poner la fuente HTML en un 
bloque con el mismo nombre.   

El bloque 'content' contiene los contenidos de la vista renderizada.

$title_for_layout contiene el título de página. Esta variable es generada 
automáticamente, pero uno puede redefinirla fijándola en su controlador / vista.

Fijar el título para el layout es más fácil hacerlo en el controlador, fijando
la variable $title_for_layout:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
  }
}

Puede también fijar la variable title_for_layout desde dentro del archivo de vista:

$this->set(’title_for_layout’, $titleContent);

Puede crear varios layouts como quiera: sólo ubíquelos en el directorio app/View/Layouts,
e intercambiar entre ellos dentro de sus acciones controlador usando la propiedad
$layout de la vista:

// from a controller
public function admin_view() {
  // stuff
  $this->layout = ’admin’;
}

// from a view file
$this->layout = ’loggedin’;

Ej.: si una sección de mi sitio incluyó un espacio para banner de avisos (ad), puedo
crear un layout nuevo con el menor espacio de publicidad y especificarlo como el
layout para todas las acciones de controlador usando algo como:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
    $this->layout = ’default_small_ad’;
  }

  public function view_image() {
    $this->layout = ’image’;
    //output user image
  }
}

CakePHP tiene 2 layouts núcleo característicos (junto al layout por defecto de
CakePHP) que uno puede usar:

. ‘ajax’: útil para elaboración de respuestas AJAX - es un layout vacío (la
  mayoría de las llamadas AJAX sólo requieren un pequeño marcado en el retorno.
  en vez de una interfaz completamente renderizada).  

. ‘flash’: se usa para mensajes mostrados por el método Controller::flash().

Los otros 3 layouts, xml, js y rss existen en el núcleo para servir contenido 
que no es text/html.

Usar layouts desde plugins
..........................
Si quiere usar un layout que existe en un plugin, puede usar sintaxis de plugin.
Ej.: para usar el layout de contenido desde el plugin Contacts:

class UsersController extends AppController {
  public function view_active() {
    $this->layout = ’Contacts.contact’;
  }
}

Elementos
---------
Algunas aplicaciones tienen pequeños bloques de código de presentación que 
necesitan repetirse de página a página, a veces en lugares diferentes del layout.
CakePHP puede ayudarle a repetir partes de su página web que necesitan reusarse.
Estas partes reutilizables son llamadas 'Elementos'. Avisos, cajas de ayuda,
controles de navegación, menús extra, formularios de login, y callouts son 
con frecuencia implementados en CakePHP como elementos. Los 'Elementos' pueden
usarse para hacer una vista más legible, poniendo el renderizado de repetir 
elementos en su propio archivo. Estos pueden también ayudarlo a reutilizar
fragmentos de contenido en su aplicación.

Los 'Elementos' viven en la carpeta /app/View/Elements/, y tienen la extensión de
archivo .ctp. Son salida usando el método element de la vista:

echo $this->element(’helpbox’);

Pasar variables dentro de un Elemento
.....................................
Puede pasar datos a un elemento a través del 2do argumento del elemento:

echo $this->element(’helpbox’, array(
  "helptext" => "Oh, this text is very helpful."
));

Dentro del archivo elemento, todas las variables pasadas están disponibles como 
miembros del array de parámetro (del mismo modo que Controller::set() en el 
controlador funciona con los archivos de vista). En el ej. de arriba, el archivo
/app/View/Elements/helpbox.ctp puede usar la variable $helptext:

// inside app/View/Elements/helpbox.ctp
echo $helptext; //outputs "Oh, this text is very helpful."

El método View::element() también soporta opciones para el elemento. Las opciones
soportadas son ‘cache’ y ‘callbacks’. Ej.:

echo $this->element(’helpbox’, 
  array(
    "helptext" => "This is passed to the element as $helptext",
    "foobar" => "This is passed to the element as $foobar",
  ),
  array(
    // uses the "long_view" cache configuration
    "cache" => "long_view",
    // set to true to have before/afterRender called for the element
    "callbacks" => true
  )
);

El cacheo de elemento es facilitado a través de la clase Cache. Puede configurar
elementos para ser almacenados en cualquier configuración de Cache que ha 
establecido. Esto le da flexibilidad para decidir donde y por cuanto los elementos
son almacenados. Para cachear versiones diferentes del mismo elemento en una
aplicación, proveer un valor de clave de cache único usando el formato:

$this->element(’helpbox’, array(), array(
  "cache" => array(’config’ => ’short’, ’key’ => ’unique value’)
  )
);

You can take full advantage of elements by using requestAction(), which fetches view variables from
a controller action and returns them as an array. This enables your elements to perform in true MVC style.
Create a controller action that prepares the view variables for your elements, then call requestAction()
inside the second parameter of element() to feed the element the view variables from your controller.

To do this, in your controller add something like the following for the Post example:

class PostsController extends AppController {
  // ...
  public function index() {
    $posts = $this->paginate();
    if ($this->request->is(’requested’)) {
      return $posts;
    } else {
      $this->set(’posts’, $posts);
    }
  }
}

And then in the element we can access the paginated posts model. To get the latest five posts in an ordered
list, we would do something like the following:

<h2>Latest Posts</h2>
<?php
  $posts = $this->requestAction(
    ’posts/index/sort:created/direction:asc/limit:5’
  );
?>
<ol>
<?php foreach ($posts as $post): ?>
<li><?php echo $post[’Post’][’title’]; ?></li>
<?php endforeach; ?>
</ol>

Cachear elementos
.................
Puede tomar ventaja del cacheo de vista de CakePHP si suministra un parámetro de
caché. Si se lo fija a true, cacheará el elemento en la configuración Cache por
'defecto'. Sino, puede setear que configuración de cache debería usarse. Ej. de
cachear un elemento:

echo $this->element(’helpbox’, array(), array(’cache’ => true));

Si renderiza el mismo elemento más de una vez en una vista y tiene el cacheo 
habilitado, fijar el parámetro 'key' a un nombre diferente cada vez. Esto evitará
que cada llamada sucesiva sobreescriba el resultado cacheado de la llamada del
element() previo. Ej.:

echo $this->element(
  ’helpbox’,
  array(’var’ => $var),
  array(’cache’ => array(’key’ => ’first_use’, ’config’ => ’view_long’)
);

echo $this->element(
  ’helpbox’,
  array(’var’ => $differenVar),
  array(’cache’ => array(’key’ => ’second_use’, ’config’ => ’view_long’)
);

Lo de arriba asegurará que ambos resultados element son cacheados de forma
separada. Si quiere que todos los cacheos de elemento usen la misma configuración
de caché, puede evitar alguna repetición fijando View::$elementCache a la 
configuración de caché que quiere usar. CakePHP usará esta configuración 
cuando no se de nada. 

Peticionar elementos desde un plugin
....................................

2.0
...
Para cargar un elemento desde un plugin, usar la opción plugin:

echo $this->element(’helpbox’, array(), array(’plugin’ => ’Contacts’));

2.1
...
Si uno está usando un plugin y desea usar elementos desde dentro del plugin, 
use la sintaxis familiar de plugin. Si la vista está siendo renderizada desde un
controlador / acción plugin, el nombre del plugin será prefijado automáticamente
sobre todos los elementos utilizados, a menos que otro nombre de plugin esté
presente. Si el elemento no existe en el plugin, este mirará en la carpeta 
principal APP:

echo $this->element(’Contacts.helpbox’);

Si su vista es una parte de un plugin, puede omitir el nombre de plugin. Ej.:
si uno está en el ContactsController del plugin Contacts, lo siguiente:

echo $this->element(’helpbox’);
// and
echo $this->element(’Contacts.helpbox’);

es equivalente y resultará en el mismo elemento siendo renderizado.

Cambio en v.2.1: la opción $options[plugin] fue deprecada y se agregó soporte
para Plugin.element.

Crear sus propias clases de vista
---------------------------------
Puede necesitar crear clases de vista personalizadas para habilitar tipos nuevos
de vistas de datos, ó agregar lógica personalizada de renderización de vista 
adicional a su aplicación. Convenciones de clases de vista:

• Los archivos de clase View deberían ponerse en App/View. Ej.: App/View/PdfView.php
• Las clases View deberían tener el sufijo 'View'. Ej.: PdfView.
• Al referenciar nombres de clase de vista debería omitir el sufijo View. Ej.:
  $this->viewClass = ’Pdf’;.

Uno también querrá extender View para asegurarse que las cosas funcionen:

// in App/View/PdfView.php
App::uses(’View’, ’View’);
class PdfView extends View {
  public function render($view = null, $layout = null) {
    // custom logic here.
  }
}

Reemplazar el método 'render' le deja tomar control completo sobre como su 
contenido es renderizado.

API View 
--------
Clase View
..........
Los métodos View son accesibles en todas las vistas, elementos y archivos de 
layout. Para llamar a cualquier método view usar $this->method():

View::set(string $var, mixed $value)
Las Views tienen un método set() que es análogo al set() hallado en objetos Controller.
Usar set() desde su archivo vista agregará las variables al layout y elementos 
que serán posteriormente renderizados.  

En su archivo vista puede hacer:

$this->set(’activeMenuButton’, ’posts’);

En su layout, la variable $activeMenuButton estará disponible y contiene el valor
'posts'.

View::get(string $var, $default = null)
Obtener el valor de una viewVar con el nombre $var.

Puede proveer un valor por defecto en caso que la variable ya no esté fijada.
Cambiado en v.2.5: el argumento $default fue agregado en 2.5.

View::getVar(string $var)
Obtiene el valor del viewVar con el nombre $var.
Deprecado desde v.2.3: usar View::get(). 

View::getVars()
Obtiene una lista de todas las variables de vista disponibles en el ámbito
de renderización actual. Retorna un array de nombre de variables.

View::element(string $elementPath, array $data, array $options = array())
Renderiza un elemento ó vista parcial. 

View::uuid(string $object, mixed $url)
Genera un ID DOM único no aleatorio para un objeto, basado en el tipo de objeto
y URL. Este método se usa con frecuencia por helpers que necesitan generar 
ID's de DOM únicos para elementos como el JsHelper:

$uuid = $this->uuid(
  ’form’,
  array(’controller’ => ’posts’, ’action’ => ’index’)
);
//$uuid contains ’form0425fe3bad’

View::addScript(string $name, string $content)
Agrega contenido al buffer de scripts interno. Este buffer es hecho disponible
en el layout como $scripts_for_layout. Este método es útil al crear helpers
que necesitan agregar javascript ó css directamente al layout. Los scripts
agregados desde el layout y elementos en el layout no serán agregados a 
$scripts_for_layout. Este método se usa con frecuencia desde dentro de helpers,
como helpers JsHelper y HtmlHelper. Deprecado en v.2.1. 

View::blocks()
Obtiene los nombres de todos los bloques definidos como un array.

View::start($name)
Comienzan un bloque de captura para un bloque de vista. 
Nuevo en v.2.1.

View::end()
Finaliza el bloque de captura más abierto en la parte superior.
Nuevo en v.2.1.

View::append($name, $content)
Agregado al bloque con $name. 
Nuevo en v.2.1.

View::prepend($name, $content)
Anteponer al bloque con $name. 
Nuevo en v.2.3.

View::startIfEmpty($name)
Inicia un bloque si este está vacío. Todo el contenido en el bloque será capturado
y descartado si el bloque ya está definido.
Nuevo en v.2.3.

View::assign($name, $content)
Asigna el valor de un bloque. Esto sobreescribirá cualquier contenido existente.
Nuevo en v.2.1.

View::fetch($name, $default = ‘’)
Extrae el valor de un bloque. Si un bloque está vacío ó indefinido, se retornará ''.
Nuevo en v.2.1.

View::extend($name)
Extiende el view/element/layout actual con el nombrado (en argumento). 
Nuevo en v.2.1.

property View::$layout
Fija al layout la vista actual que será contenida (wrapped in).

property View::$elementCache
La configuración de caché usada para elementos de caché. Fijar esta propiedad
cambiará la configuración por defecto usada para elementos de caché. Este 
valor por defecto puede ser redefinido usando la opción 'cache' en el método
element.

property View::$request
Una instancia de CakeRequest. Usar esta instancia para acceder a información sobre
la petición actual.

property View::$output
Contiene el último contenido renderizado desde una vista, ya sea el archivo de
vista, ó el contenido de layout. Deprecado en v.2.1: Usar 
$view->Blocks->get(’content’); en lugar de eso.

property View::$Blocks
Una instancia de ViewBlock. Usada para proveer funcionalidad de bloque de vista
en la renderización de la vista.
New in version 2.1.

Más sobre vistas
----------------

Temas (Themes)
..............
Puede tomar ventaja de temas, haciendo fácil intercambiar el look and feel de 
su página rápido y fácil.

Para usar temas, especificar el nombre de tema en su controlador:

class ExampleController extends AppController {
  public $theme = ’Example’;
}

Cambiado en v.2.1: las versiones anteriores a 2.1 requirieron fijar 
$this->viewClass = ’Theme’. 2.1 quita este requerimiento como ya que la 
clase View normal soporta themes.

Puede también fijar ó cambiar el nombre de theme dentro de una acción ó dentro
las funciones de callback beforeFilter ó beforeRender:

$this->theme = ’AnotherExample’;

Los archivos de vista necesitan estar en la carpeta /app/View/Themed/. Dentro de
la carpeta themed, crear una carpeta usando el mismo nombre que su nombre de 
theme. Ej.: el theme de arriba debería ser hallado en /app/View/Themed/AnotherExample.
CakePHP espera nombres de theme en camel case. Mas allá de eso, la estructura
de carpeta dentro de /app/View/Themed/Example/ es exactamente la misma que
/app/View/.  

Ej.: el archivo de vista para una acción de edit de un controlador Posts debería
residir en /app/View/Themed/Example/Posts/edit.ctp. Los archivos de layout 
deberían residir en /app/View/Themed/Example/Layouts/.

Si un archivo de vista no puede hallarse en theme, CakePHP intentará ubicar el
archivo de vista en la carpeta /app/View/. Así, puede crear archivos de vista
maestros y redefinirlos en una base caso por caso dentro de su carpeta theme.

Haberes (assets) de Theme
.........................
Los themes pueden contener haberes estáticos así como archivos de vista. Un theme
puede incluir cualquiera de los haberes necesarios en su directorio webroot. Esto
le permite un empaquetado y distribución de themes sencillo. En desarrollo, las
peticiones para los haberes de theme serán manejadas por el Dispatcher. Para
mejorar la performance en producción, se recomienda symlink ó copiar haberes de
theme en en el webroot de la aplicación.  

Para usar el webroot theme nuevo crear directorios como:

app/View/Themed/<themeName>/webroot<path_to_file>

en su theme. El Dispatcher lo manejará hallando los haberes de theme correctos
en sus rutas de vista.

Todos los helpers incorporados de CakePHP son conscientes de themes y crearán
las rutas correctas de forma automática. Como los archivos de vista, si un 
archivo no está en la carpeta theme, será por defecto en la carpeta principal webroot:

//When in a theme with the name of ’purple_cupcake’
$this->Html->css(’main.css’);

//creates a path like
/theme/purple_cupcake/css/main.css

//and links to
app/View/Themed/PurpleCupcake/webroot/css/main.css

Increasing performance of plugin and theme assets

It’s a well known fact that serving assets through PHP is guaranteed to be slower than serving those assets
without invoking PHP. And while the core team has taken steps to make plugin and theme asset serving
as fast as possible, there may be situations where more performance is required. In these situations it’s
recommended that you either symlink or copy out plugin/theme assets to directories in app/webroot
with paths matching those used by CakePHP.

• app/Plugin/DebugKit/webroot/js/my_file.js se vuelve app/webroot/debug_kit/js/my_file.js

• app/View/Themed/Navy/webroot/css/navy.css se vuelve app/webroot/themed/Navy/css/navy.css

Media Views
-----------

clase MediaView
...............
Deprecado en v.2.3: Usar en vez de eso 'Enviar Archivos'.

Media views le permite enviar archivos binarios al usuario. Ej.: puede desear
tener un directorio de archivos fuera de webroot para evitar a los usuarios
de enlazarlos directamente. Puede usar el Media view para extraer (pull) el 
archivo desde dentro de una carpeta /app/, permitiéndole realizar autenticación
antes de entregar el archivo al usuario.

Para usar el Media view, necesita decirle a su controlador de usar la clase
MediaView en vez de la clase View por defecto. Después de eso, sólo pasar 
parámetros adicionales para especificar donde está ubicado su archivo:

class ExampleController extends AppController {
  public function download() {
    $this->viewClass = ’Media’;
    // Download app/outside_webroot_dir/example.zip
    $params = array(
      ’id’ => ’example.zip’,
      ’name’ => ’example’,
      ’download’ => true,
      ’extension’ => ’zip’,
      ’path’ => APP . ’outside_webroot_dir’ . DS
    );
    $this->set($params);
  }
}

Ej. de renderizar un archivo cuyo mime type no está incluido en el array $mimeType
de MediaView. Estamos también usando una ruta relativa que estará por defecto 
en su carpeta app/webroot:

public function download() {
  $this->viewClass = ’Media’;
  // Render app/webroot/files/example.docx
  $params = array(
    ’id’ => ’example.docx’,
    ’name’ => ’example’,
    ’extension’ => ’docx’,
    ’mimeType’ => array(
      ’docx’ => ’application/vnd.openxmlformats-officedocument’ .
      ’.wordprocessingml.document’
    ),
    ’path’ => ’files’ . DS
  );
  $this->set($params);
}

Parámetros ajustables (settables)
---------------------------------
id La ID es el nombre de archivo ya que este reside en el servidor de archivo 
   incluyendo la extensión de archivo

name El nombre le permite especificar un nombre de archivo alternativo para ser
     enviado al usuario. Especificar el nombre sin la extensión de archivo
     
download Un valor boolean que indica si los headers deberían ser fijados a 
         forzar la descarga
         
extension La extensión de archivo. Este es emparejado contra una lista interna de
          mime types aceptables. Si el mime type especificado no está en la lista
          (ó enviado en el array de parámetro mimeType), el archivo no será
          descargado
                    
path El nombre de carpeta, incluyendo el separador de directorio final. La ruta
     debería ser absoluta pero puede ser relativa a la carpeta app/webroot
      

mimeType Un array con mime types adicionales a ser mergeados con la lista interna
         MediaView de mime types aceptables

cache Un valor boolean ó Integer - si se fija a true le permitirá a los navegadores
      cachear el archivo (por defecto en false si no está seteado); de otro modo
      fijar este al número de segundos en el futuro para cuando la caché 
      debería expirar

Vistas JSON y XML
=================
Nuevo en CakePHP 2.1 hay 2 nuevas clases de vista. XmlView y JsonView le dejan
crear respuestas XML y JSON fácilmente, e integrarlas con el RequestHandlerComponent.  

Habilitando RequestHandlerComponent en su aplicación, y habilitando soporte 
para las extensiones xml y json, puede impulsar las clases de vista nuevas 
automáticamente. XmlView y JsonView serán referidas como vistas de datos para 
el resto de esta página.

Hay 2 formas que puede generar vistas de datos. La 1ra es usar la clave _serialize,
y la 2da es crear archivos de vista normales.

Habilitar vistas de datos en su aplicación
------------------------------------------
Antes de que pueda usar las clases vista de datos, necesita cierta configuración:

1. Habilitar las extensiones json y/ó xml con Router::parseExtensions(). Esto
   habilitará a Router manejar extensiones múltiples

2. Agregar el RequestHandlerComponent a su lista de componentes de su controlador.
   Esto habilitará conmutación de la clase de vista sobre content types de forma
   automática. Puede también configurar el componente con la configuración    
   viewClassMap, para mapear tipos a sus clases personalizadas y/ó mapear otros
   tipos de datos
   
Nuevo en v.2.3: el método RequestHandlerComponent::viewClassMap() ha sido agregado
a tipos de mapeo para viewClasses. La configuración viewClassMap no funcionará
en versiones anteriores.

Después de agregar Router::parseExtensions(’json’); a su archivo de rutas, 
CakePHP conmutará automáticamente clases de vista cuando una petición es hecha 
con la extensión .json, ó el Accept header es application/json.

Usar vistas de datos con la clave serialize
-------------------------------------------
La clave _serialize es una variable de vista especial que indica que otras 
variable(s) de vista deberían ser serializadas al usar una vista de datos.
Esto le deja saltar definir archivos de vista para sus acciones controlador si
no necesita hacer cualquier formateo personalizado antes de que sus datos
sean convertidos en json/xml.

Si necesita hacer cualquier formateo ó manipulación de sus variables de vista
antes de generar la respuesta, debería usar archivos de vista. El valor de 
_serialize puede ser ya sea un string ó un array de variables de vista a 
serializar:
 
class PostsController extends AppController {
  public $components = array(’RequestHandler’);
  public function index() {
    $this->set(’posts’, $this->paginate());
    $this->set(’_serialize’, array(’posts’));
  }
}

Uno puede también definir _serialize como un array de variables de vista a combinar:

class PostsController extends AppController {
  public $components = array(’RequestHandler’);
  public function index() {
    // some code that created $posts and $comments
    $this->set(compact(’posts’, ’comments’));
    $this->set(’_serialize’, array(’posts’, ’comments’));
  }
}

Definir _serialize como un array tiene el beneficio agregado de anexar automáticamente
un elemento de <response> de nivel superior al usar XmlView. Si uno usa un valor
string para _serialize y XmlView, asegurarse que su variable de vista tiene un
elemento de nivel superior único. Sin un elemento de nivel superior único el Xml
fallará en generarse.

Usar una vista de datos con archivos de vista
---------------------------------------------
Uno debería usar archivos de vista si necesita hacer alguna manipulación de su 
contenido de vista antes de crear la salida final. Por ej. si tuvimos posts, 
que tenía un archivo conteniendo el HTML generado, probablemente querríamos
omitir eso desde una respuesta JSON. Esta es una situación donde un archivo de
vista sería útil:

// Controller code
class PostsController extends AppController {
  public function index() {
    $this->set(compact(’posts’, ’comments’));
  } 
}

// View code - app/View/Posts/json/index.ctp
foreach ($posts as &$post) {
  unset($post[’Post’][’generated_html’]);
}
echo json_encode(compact(’posts’, ’comments’));

Nota: Las clases de vista de datos no soportan layouts. Ellas asumen que el archivo
de vista producirá (output) el contenido serializado.

Clase XmlView
.............
Una clase de vista para generar datos de vista Xml. Por defecto al usar _serialize 
el XmlView envolverá sus variables de vista serializadas con un nodo <response>.
Puede fijar un nombre personalizado para este nodo usando la variable de vista
_rootNode. Nuevo en v.2.3: se agregó la característica _rootNode.

Clase JsonView
..............
Una clase de vista para generar datos de vista JSON. 

Response JSONP 
--------------
Nuevo en v.2.4.

Al usar JsonView puede usar la variable de vista especial _jsonp para habilitar
retornar una respuesta JSONP. Fijarla a true hace a la clase de vista chequear si
el parámetro query string nombrado 'callback' está fijado y si lo está envolver
la respuesta json en el nombre de función provisto. Si uno quiere usar un 
nombre de parámetro query string personalizado en vez de 'callback' fijar _jsonp
al nombre requerido en vez de true.

Helpers
-------
Los Helpers son clases como-componente para la capa de presentación de su 
aplicación.

CakePHP emite un número de helpers para ayudan en la creación de la vista. Ayudan
en crear marcado bien formado (incluyendo formularios), auxilio en texto 
de formato, tiempos y números, y pueden aún acelerar la funcionalidad AJAX.

CacheHelper
-----------
class CacheHelper(View $view, array $settings = array())
........................................................
El Cache helper ayuda en cachear layouts y vistas enteros, ahorrando tiempo
en recobrar datos repetitivos. El caching de View en CakePHP almacena layouts y
vistas parseados temporalmente como archivos PHP + HTML simples. Cache Helper
funciona bastante diferente que otros helpers. Este no tiene métodos que son
llamados directamente. En vez de eso, una vista es marcada con etiquetas de 
cache que indican que bloques de contenido no deberían ser cacheados. El 
CacheHelper usa luego callbacks helper para procesar el archivo y salida para
generar el archivo de cache.

Peticionada una URL, CakePHP chequea para ver si el string de petición ya ha
sido cacheado. Si lo tiene, el resto del proceso de dispatching de URL es 
salteado. Cualquiera de los bloque nocache son procesados normalmente y la vista
es servida. Esto crea grandes ahorros en tiempo de procesamiento para cada 
petición a una URL cacheada a medida que es ejecutado el código mínimo. Si 
CakePHP no halla una vista cached, ó la caché ha expirado para la URL peticinada
esta continúa para procesar la petición normalmente.

Usar el Helper
--------------
Pasos a tomar antes de usar CacheHelper: en su APP/Config/core.php descomentar 
la llamada a escritura Configure para Cache.check. Esto le dirá a CakePHP que
chequee, y genere archivos de cache de vista al manejar peticiones.

Una vez que ha descomentado la línea Cache.check necesitará agregar el helper a 
su array $helpers del controlador:

class PostsController extends AppController {
  public $helpers = array(’Cache’);
}

Uno también necesitará agregar el CacheDispatcher a sus filtros de dispatcher en
su boostrap:

Configure::write(’Dispatcher.filters’, array(
  ’CacheDispatcher’
));

Nuevo en v.2.3: Si tiene una configuración con múltiples dominios ó lenguajes uno
puede usar Configure::write(‘Cache.viewPrefix’, ‘YOURPREFIX’); para almacenar
los archivos cache de vista prefijados.

Las opciones de configuración adicionales de CacheHelper tienen algunas opciones
de configuración adicionales que puede usar para sintonizar y ajustar su 
comportamiento. Esto es hecho a través de la variable $cacheAction en sus 
controladores. $cacheAction debería ser fijado a un array que contiene las 
acciones que quiere cacheadas, y la duración en segundos en que quiere esas 
vistas cacheadas. El valor de tiempo puede ser expresado en un formato strtotime()
('1 hour' ó '3 minutes').
  
Usando el ej. de un ArticlesController, que recibe un montón de tráfico que 
necesita ser cacheado:

public $cacheAction = array(
  ’view’ => 36000,
  ’index’ => 48000
);

Esto cacheará la acción de vista 10 horas, y la acción de index 13 horas. Haciendo
a $cacheAction un valor amigable con strtotime() puede cachear cada acción en el
controlador:

public $cacheAction = "1 hour";

Puede también habilitar callbacks controlador/componente para vistas cacheadas
creadas con CacheHelper. Para hacerlo debe usar el formato array para $cacheAction
y crear un array como el siguiente:

public $cacheAction = array(
  ’view’ => array(’callbacks’ => true, ’duration’ => 21600),
  ’add’ => array(’callbacks’ => true, ’duration’ => 36000),
  ’index’ => array(’callbacks’ => true, ’duration’ => 48000)
);

Fijar callbacks => true le dice a CacheHelper que uno busca que los archivos 
generados creen los componentes y modelos para el controlador. Adicionalmente, 
disparar el componente initialize, beforeFilter del controlador, y callbacks
de startup de componente.

Nota: Fijar callbacks => true derrota en parte al propósito de cacheo. Esta es
también la razón de que está inhabilitado por defecto.

Marcar Non-Cached Content en Views
----------------------------------
Hay veces que no no quiere que la vista entera sea cacheada. Ej.: ciertas partes
de la página pueden lucir diferente si un usuario es actualmente logueado ó 
navegando su sitio como invitado.

Para indicar los bloques de contenido que no van a cachearse, envolverlos en 
<!--nocache--> <!--/nocache--> como:

<!--nocache-->
<?php if ($this->Session->check(’User.name’)): ?>
  Welcome, <?php echo h($this->Session->read(’User.name’)); ?>.
<?php else: ?>
  <?php echo $this->Html->link(’Login’, ’users/login’); ?>
<?php endif; ?>
<!--/nocache-->

Nota: no puede usar etiquetas 'nocache' en elementos. Ya que no hay callbacks
alrededor de elementos, ellos no pueden ser cacheados.

Cacheada una acción, el método controlador para la acción no será llamado. Cuando
es creado un archivo de cache, el objeto request, y las variables de vista son
serializadas con serialize() de PHP.

Advertencia: Si tiene variables de vista que contienen contenido no serializable
como objetos SimpleXML, manejos de recurso, ó cierres (closures) uno puede no ser
capaz de usar caching de vista.

Limpiar (clearing) la Cache
---------------------------
CakePHP limpiará una vista cacheada si un modelo usando en la vista cached es
modificado. Ej.: si una vista cacheada usa datos desde el modelo Post, y ha 
habido una consulta INSERT, UPDATE ó DELETE hecha a un Post, la cache para esa
vista es limpiado, y es generado contenido nuevo en la siguiente petición.

Nota: Esta limpieza de cache automática requiere que el nombre de controlador /
modelo sea parte de la URL. Si ha usado enrutamiento para cambiar sus URL's esta
característica no funcionará.

Si necesita limpiar la cache manualmente, puede hacerlo llamando a Cache::clear().
Esto limpiará todos los datos cacheados, excluyendo archivos de vista cacheados.
Si necesita borrar los archivos de vista cacheados, usar clearCache().

FormHelper
----------
clase FormHelper(View $view, array $settings = array())
.......................................................
FormHelper hace la mayoría del levantamiento pesado en la creación del formulario.
FormHelper se enfoca en crear formularios rápidamente, en un modo que tendrá
validación streamline, re-populación y layout. FormHelper hará casi todo lo 
usando convenciones, ó puede especificar métodos para obtener sólo lo que necesita.

Crear Formularios
-----------------
El 1er método que usar para tomar ventaja del FormHelper es create(). Este método
produce la apertura de una etiqueta 'form'.

FormHelper::create(string $model = null, array $options = array())
..................................................................
Todos los parámetros son opcionales. Si create() es llamado sin parámetros 
suministrados, este asume que uno está construyendo un formulario que se envía
al controlador actual, vía la URL actual. El método por defecto para envío de
formulario es POST. El elemento 'form' es también retornado con un ID de DOM.
El ID es generado usando el nombre del modelo, y el nombre de la acción controlador,
en camel case. Si fuese a llamar a create() dentro de una vista UsersController,
se vería algo como la siguiente salida en la vista renderizada:

<form id="UserAddForm" method="post" action="/users/add">

Nota: Puede también pasar false para $model. Esto ubicará sus datos de formulario
en el array: $this->request->data (en vez de en el sub-array: 
$this->request->data[’Model’]). Esto es útil para formularios cortos que pueden
no representar nada en su DB.

El método create() no permite personalizar mucho más usando los parámetros,
sin embargo. Primero, puede especificar un nombre de modelo. Especificando un 
modelo para un formulario, uno está creando aquel contexto del formulario. Todos
los campos se asumen a pertenecer a este modelo (a menos que se especifique otro),
y todos los modelos referenciados son asumidos a ser asociados con este. Si no
especifica un modelo, este asume que uno está usando el modelo por defecto para el
controlador actual:

// If you are on /recipes/add
echo $this->Form->create(’Recipe’);

Produce:

<form id="RecipeAddForm" method="post" action="/recipes/add">

Esto hará un POST de los datos de formulario para la acción add() de RecipesController.
Pero, puede también usar la misma lógica para crear la edición de un formulario.
FormHelper usa la propiedad $this->request->data para detectar automáticamente
si crear un formulario de 'Agregar' ó 'Editar'. Si $this->request->data contiene
un elemento array nombrado después del modelo de formulario, y ese array contiene
un valor no vacío de la clave primaria del modelo, FormHelper creará un formulario
de 'Editar' para ese registro. Ej.: si navegamos a http://site.com/recipes/edit/5,
obtendríamos lo siguiente:

// Controller/RecipesController.php:
public function edit($id = null) {
  if (empty($this->request->data)) {
    $this->request->data = $this->Recipe->findById($id);
  } else {
    // Save logic goes here
  }
}

// View/Recipes/edit.ctp:
// Since $this->request->data[’Recipe’][’id’] = 5,
// we will get an edit form
<?php echo $this->Form->create(’Recipe’); ?>

Salida:

<form id="RecipeEditForm" method="post" action="/recipes/edit/5">
<input type="hidden" name="_method" value="PUT" />

Nota: Dado que este es un formulario de edición, es generado un campo input hidden
para redefinir el método HTTP por defecto.

Al crear formularios para modelos en plugins, siempre debería usar sintaxis de 
plugin al crear un formulario. Esto asegurará que el formulario es generado
correctamente:

echo $this->Form->create(’ContactManager.Contact’);

El array $options es donde ocurre la mayoría de la configuración del formulario.
Este array especial puede contener un número de pares clave-valor diferentes
que afectan el modo que la etiqueta 'form' es generada.

Cambiado en v.2.0: La URL por defecto para todos los formularios, es ahora la 
URL actual incluyendo los parámetros query string, nombrado y pasado. Puede 
redefinir este valor por defecto suministrando $options[’url’] en el 2do 
parámetro de $this->Form->create().

Opciones para create(): Hay un número de opciones para create(): 
......................

• $options[’type’] 
  ////////////////
Clave que se usa para especificar el tipo de formulario a ser creado. 
Valores válidos incluyen ‘post’, ‘get’, ‘file’, ‘put’ y ‘delete’. 

Suministrar ya sea 'post' ó 'get' cambia el método de envío del fomulario de 
forma acorde:

echo $this->Form->create(’User’, array(’type’ => ’get’));

Produce:

<form id="UserAddForm" method="get" action="/users/add">

Especificar 'file' cambia el método de envío del formulario a 'post', e incluye
un tipo de encriptación de 'multipart/form-data' en la etiqueta 'form'. Esto está
para ser usado si hay cualquiera de los elementos file dentro del formulario. La
ausencia del atributo enctype apropiado originará que la subida de archivos no
funcione:

echo $this->Form->create(’User’, array(’type’ => ’file’));

Salida:

<form id="UserAddForm" enctype="multipart/form-data" method="post" action="/users/add">

Al usar 'put' ó 'delete', su formulario será funcionalmente equivalente a un 
formulario 'post', pero cuando es enviado, el método de petición HTTP será 
redefinido con 'PUT' or 'DELETE', respectivamente. Esto le permite a CakePHP 
emular el soporte REST apropiado en navegadores web.

• $options[’action’] 
  //////////////////
La clave 'action' le permite apuntar el formulario a una acción específica en su
controlador actual. Ej.: si uno querría apuntar el formulario a la acción login()
del controlador actual, uno debería suministrar un arrray $options como el que
sigue:

echo $this->Form->create(’User’, array(’action’ => ’login’));

Salida:

<form id="UserLoginForm" method="post" action="/users/login">

• $options[’url’] 
  ///////////////
Si la acción de formulario deseada no está en el controlador actual, puede 
especificar una URL para la acción de formulario usando la clave 'url' del array
$options. La URL suministrada puede ser relativa a su aplicación CakePHP:

echo $this->Form->create(null, array(
  ’url’ => array(’controller’ => ’recipes’, ’action’ => ’add’)
));

Produce:

<form method="post" action="/recipes/add">

ó puede apuntar a un dominio externo:

echo $this->Form->create(null, array(
  ’url’ => ’http://www.google.com/search’,
  ’type’ => ’get’
));

Produce:

<form method="get" action="http://www.google.com/search">

También chequear el método HtmlHelper::url() para más ejemplos de diferentes
tipos de URL's.

• $options[’default’]
  ///////////////////
Si 'default' ha sido fijado a boolean false, la acción de submit del formulario
es cambiada tal que presionar el botón 'Submit' no envía el formulario. Si el 
formulario se presume enviar vía AJAX, fijar 'default' a false suprime el 
comportamiento por defecto del formulario así uno puede agarrar los datos y 
enviarlos vía AJAX en su lugar.

• $options[’inputDefaults’] 
  /////////////////////////
Puede declarar un set de opciones por defecto para input() con la clave
inputDefaults para personalizar su creación de input por defecto:

echo $this->Form->create(’User’, 
  array(
    ’inputDefaults’ => array(
      ’label’ => false,
      ’div’ => false
    )
  )
);

Todas las entradas creadas desde ese punto hacia adelante heredan las opciones
declaradas en inputDefaults. Puede redefinir defaultOptions declarando la opción
en la llamada a input():

echo $this->Form->input(’password’); // No div, no label
// has a label element
echo $this->Form->input(
  ’username’,
  array(’label’ => ’Username’)
);

Cerrar el Formulario
--------------------
FormHelper::end($options = null, $secureAttributes = array())
.............................................................
FormHelper incluye un método end() que completa el formulario. Con frecuencia, 
end() sólo produce una etiqueta 'form' de cierre, pero usar end() también 
permite a FormHelper insertar elementos form hidden necesarios que requiere 
SecurityComponent:

<?php echo $this->Form->create(); ?>
<!-- Form elements go here -->
<?php echo $this->Form->end(); ?>

Si un string es suministrado como el 1er parámetro para end(), FormHelper produce
un botón de submit nombrado de acuerdo con la etiqueta de cierre del formulario:

<?php echo $this->Form->end(’Finish’); ?>

Producirá:

<div class="submit">
  <input type="submit" value="Finish" />
</div>
</form>

Puede especificar ajustes de detalle pasando un array a end():

$options = array(
  ’label’ => ’Update’,
  ’div’ => array(
    ’class’ => ’glass-pill’,
  )
);
echo $this->Form->end($options);

Producirá:

<div class="glass-pill"><input type="submit" value="Update" name="Update">
</div>

Nota: Si está usando SecurityComponent en su aplicación debería siempre finalizar
sus formularios con end().

El parámetro $secureAttributes fue agregado en v.2.5.

Crear elementos de formulario
-----------------------------
Hay varios modos de crear inputs de formulario con el FormHelper. Se arrancará
mirando a input(). Este método inspeccionará automáticamente el campo modelo que
ha sido suministrado para crear un input apropiado para ese campo. Internamente
input() se delega a otros métodos en FormHelper.

FormHelper::input(string $fieldName, array $options = array())
..............................................................
Crea los siguientes elementos dado un Model.field particular:

• Envolver div
• Elemento label
• Elemento(s) input
• Elemento error con mensaje si es aplicable

El tipo de input creado depende del tipo de dato de la columna:

Tipo de Columna: Campo de formulario resultante
:::::::::::::::

String (char, varchar, etc.): Texto
:::::::::::::::::::::::::::

Boolean, tinyint(1): Checkbox
:::::::::::::::::::

text: textarea
::::

text, with name of password, passwd, or psword: password
::::::::::::::::::::::::::::::::::::::::::::::

text, with name of email: email
::::::::::::::::::::::::

text, with name of tel, telephone, or phone: teléfono
:::::::::::::::::::::::::::::::::::::::::::

date: selecciones de día, mes y año
::::

datetime, timestamp: día, mes, año, hora, minuto, y selección de meridiano tiempo, hora, minuto y selección de meridiano 
:::::::::::::::::::

binary: archivo
::::::

La opción $options le permite personalizar como trabaja input(), y controlar
finamente que es generado. El div envolvente tendrá un nombre de clase requerido
anexado si las reglas de validación para el campo del Model no especifica
allowEmpty => true. Una limitación de este comportamiento es que el modelo del
campo debe haber sido cargado durante su petición. O ser directamente asociado
al modelo suministrado a create().

Nuevo en v.2.5: El tipo binario ahora mapea a un input file.

Desde v.2.3 el atributo 'required' de HTML5 también será añadido al input basado
en reglas de validación. Puede fijar explícitamente la clave requerida en el array
options para redefinirlo para un campo. Para saltear validación de navegador 
disparando el formulario entero uno puede fijar la opción ’formnovalidate’ => true
para el botón input que uno genera usando FormHelper::submit() ó fijar ’novalidate’ => true 
en opciones para FormHelper::create().    
 
Ej.: se asume que su modelo User incluye campos para un nombre de usuario (varchar),
password (varchar), aprobado (datetime) y cita (text). Puede usar el método input()
del FormHelper para crear inputs apropiados para estos campos de formulario:

echo $this->Form->create();
echo $this->Form->input(’username’); //text
echo $this->Form->input(’password’); //password
echo $this->Form->input(’approved’); //day, month, year, hour, minute,
//meridian
echo $this->Form->input(’quote’); //textarea
echo $this->Form->end(’Add’);

Ej. mas extensivo mostrando algunas opciones para un campo date:

echo $this->Form->input(’birth_dt’, 
  array(
    ’label’ => ’Date of birth’,
    ’dateFormat’ => ’DMY’,
    ’minYear’ => date(’Y’) - 70,
    ’maxYear’ => date(’Y’) - 18,
  )
);

Junto a las opciones específicas para input() hallado abajo, puede especificar
cualquier opción para el tipo input y cualquier atributo HTML (por ej. onfocus).

Se asume que User hasAndBelongsToMany Group. En su controlador, fijar una 
variable plural en camelCase (group -> groups en este caso, ó 
ExtraFunkyModel -> extraFunkyModels) con las opciones de selección. En la acción
controlador uno pondría lo siguiente:

$this->set(’groups’, $this->User->Group->find(’list’));

Y en la vista puede ser creada una selección múltiple con este código:

echo $this->Form->input(’Group’);

Si quiere crear un campo de selección mientras usa una Relación belongsTo - ó
hasOne, puede agregar lo siguiente a su controlador Users (asumiendo que 
User belongsTo Group):

$this->set(’groups’, $this->User->Group->find(’list’));

Más tarde, agregar los siguiente a su vista de formulario:

echo $this->Form->input(’group_id’);

Si su nombre de modelo consiste de 2 ó más palabras, ej., “UserGroup”, al pasar
los datos usando set() uno debería nombrar sus datos en formato pluralizado y 
camelCase como sigue:

$this->set(’userGroups’, $this->UserGroup->find(’list’));
// or
$this->set(
  ’reallyInappropriateModelNames’,
  $this->ReallyInappropriateModelName->find(’list’)
);

Nota: Evitar usar FormHelper::input() para generar botones de submit. Usar en
vez de eso FormHelper::submit().

FormHelper::inputs(mixed $fields = null, array $blacklist = null, $options = array())
.....................................................................................
Genera un set de inputs para $fields. Si $fields es null todos los campos del 
modelo actual, excepto para aquellos definidos en $blacklist, serán usados.

Adicionalmente a la salida de campos controlador, $fields puede ser usado para 
controlar renderización de legend y fieldset con las claves fieldset y legend.
$this->Form->inputs(array(’legend’ => ’My legend’)); generaría un set input con 
un legend personalizado. Puede personalizar inputs individuales también a través
de $fields:
 
echo $this->Form->inputs(
  array(
    ’name’ => array(’label’ => ’custom label’)
  )
);

Adicionalmente al control fields, inputs() le permite usar algunas opciones 
adicionales:

•fieldset: Se fija a false para inhabilitar el fieldset. Suministrado un string
 este será usado como el nombre de clase para el elemento fieldset
  
•legend: Se fija a false para inhabilitar el legend para el set input generado.
O suministrar un string para personalizar el texto del legend

Convenciones de nombramiento del campo 
......................................
Siempre que uno especifique un nombre de campo con los métodos form helper, este
usará automáticamente el nombre de modelo actual para construir un input con un 
formato como el que sigue:

<input type="text" id="ModelnameFieldname" name="data[Modelname][fieldname]">

Esto le permite omitir el nombre de modelo al generar inputs para el modelo para
el que fue creado el formulario. Puede crear inputs para modelos asociados, 
ó modelos arbitrarios pasando Modelname.fieldname como el 1er parámetro:

echo $this->Form->input(’Modelname.fieldname’);

Si necesita especificar múltiples campos usando el mismo nombre de campo, así 
crear un array que puede ser almacenado en un tiro con saveAll(), usar la 
siguiente convención:

echo $this->Form->input(’Modelname.0.fieldname’);
echo $this->Form->input(’Modelname.1.fieldname’);

Salida:

<input type="text" id="Modelname0Fieldname" name="data[Modelname][0][fieldname]">
<input type="text" id="Modelname1Fieldname" name="data[Modelname][1][fieldname]">

FormHelper usa internamente varios sufijos de campo para creación de input
datetime. Si está usando campos nombrados year, month, day, hour, minute, ó meridian
y teniendo problemas (issues) al obtener el input correcto, puede fijar el atributo
name para redefinir el comportamiento por defecto:

echo $this->Form->input(’Model.year’, 
  array(
    ’type’ => ’text’,
    ’name’ => ’data[Model][year]’
  )
);

Opciones 
........
FormHelper::input() soporta varias opciones. Adicionalmente a sus propias opciones
input() acepta opciones para los tipos input generados, así como atributos HTML.
Lo siguiente cubrirá lo específico a opciones para FormHelper::input().

• $options[’type’]: Puede forzar el tipo de un input, redefinir introspección del
modelo, especificando un tipo. Adicionalmente a los tipos de campo hallados al 
Crear elementos de formulario, puede también crear ‘file’, ‘password’, y cualquier
tipo soportado por HTML5:

echo $this->Form->input(’field’, array(’type’ => ’file’));
echo $this->Form->input(’email’, array(’type’ => ’email’));

Salida:

<div class="input file">
  <label for="UserField">Field</label>
  <input type="file" name="data[User][field]" value="" id="UserField" />
</div>
<div class="input email">
  <label for="UserEmail">Email</label>
  <input type="email" name="data[User][email]" value="" id="UserEmail" />
</div>

• $options[’div’]: Usar esta opción para fijar atributos del div que contiene al
input. Usar un valor string fijará el nombre de clase del div. Un array fijará
los atributos del div a aquellos especificados por las claves/valores del array.
Alternativamente, puede fijar esta clave a false para inhabilitar las salida
del div.

Fijar el nombre de clase:

echo $this->Form->input(’User.name’, 
  array(
    ’div’ => ’class_name’
  )
);

Salida:

<div class="class_name">
  <label for="UserName">Name</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Fijar atributos múltiples:

echo $this->Form->input(’User.name’, 
  array(
    ’div’ => array(
      ’id’ => ’mainDiv’,
      ’title’ => ’Div Title’,
      ’style’ => ’display:block’
    )
  )
);

Salida:

<div class="input text" id="mainDiv" title="Div Title" style="display:block">
  <label for="UserName">Name</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Inhabilitar la salida del div:

echo $this->Form->input(’User.name’, array(’div’ => false)); ?>

Salida:

<label for="UserName">Name</label>
<input name="data[User][name]" type="text" value="" id="UserName" />

• $options[’label’]: Fijar esta clave al string que uno querría que se muestre
dentro de la etiqueta que usualmente acompaña el input:

echo $this->Form->input(’User.name’, array(
  ’label’ => ’The User Alias’
));

Salida:

<div class="input">
  <label for="UserName">The User Alias</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Alternativamente, fijar esta clave a false para inhabilitar la salida de la 
etiqueta:

echo $this->Form->input(’User.name’, array(’label’ => false));

Salida:

<div class="input">
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

Fijar esto a un array para proveer opciones adicionales para el elemento label.
Si lo hace, puede usar una clave texto en el array para personalizar el texto del
label:

echo $this->Form->input(’User.name’, 
  array(
    ’label’ => array(
      ’class’ => ’thingy’,
      ’text’ => ’The User Alias’
    )
  )
);

Salida:

<div class="input">
  <label for="UserName" class="thingy">The User Alias</label>
  <input name="data[User][name]" type="text" value="" id="UserName" />
</div>

• $options[’error’]: Usar esta clave le permite redefinir los mensajes de error 
del modelo por defecto y pueden ser usados, por ej., para fijar mensajes i18n.
Este tiene un número de subopciones las cuales controlan el elemento envolvente,
envuelven el nombre de clase del elemento, y si el HTML en el mensaje de error
será escapado.

Para inhabilitar la salida de mensaje de error y clases de campo fijar la clave
error a false:

$this->Form->input(’Model.field’, array(’error’ => false));

Para inhabilitar sólo el mensaje de error, pero retener las clases de campo, 
fijar la clave errorMessage a false:

$this->Form->input(’Model.field’, array(’errorMessage’ => false));

Para modificar el tipo de elemento envolvente y su clase, usar el formato:

$this->Form->input(’Model.field’, 
  array(
    ’error’ => array(
      ’attributes’ => array(’wrap’ => ’span’, ’class’ => ’bzzz’)
    )
  )
);

Para evitar que HTML sea escapado automáticamente en la salida del mensaje de 
error, fijar la subopción escape a false:

$this->Form->input(’Model.field’, 
  array(
    ’error’ => array(
      ’attributes’ => array(’escape’ => false)
    )
  )
);

Para redefinir los mensajes de error del modelo usar un array con las claves que
coinciden con los nombres de regla de validación:

$this->Form->input(’Model.field’, 
  array(
    ’error’ => array(’tooShort’ => __(’This is not long enough’))
  )
);

Como arriba uno puede fijar el mensaje de error para cada regla de validación
que uno tiene en sus modelos. Adicionalmente puede proveer mensajes i18n para 
sus formularios.

Nuevo en v.2.3: Soporte para la opción errorMessage.

• $options[’before’], $options[’between’], $options[’separator’], y $options[’after’]

Usar estas claves si necesita inyectar algún marcado dentro de la salida del
método input():

echo $this->Form->input(’field’, 
  array(
    ’before’ => ’--before--’,
    ’after’ => ’--after--’,
    ’between’ => ’--between---’
  )
);

Salida:

<div class="input">
  --before--
  <label for="UserField">Field</label>
  --between---
  <input name="data[User][field]" type="text" value="" id="UserField" />
  --after--
</div>

Para radio inputs el atributo 'separator' puede usarse para inyectar marcado para
separar cada par input / label:

echo $this->Form->input(’field’, 
  array(
    ’before’ => ’--before--’,
    ’after’ => ’--after--’,
    ’between’ => ’--between---’,
    ’separator’ => ’--separator--’,
    ’options’ => array(’1’, ’2’)
  )
);

Salida:

<div class="input">
  --before--
  <input name="data[User][field]" type="radio" value="1" id="UserField1" />
  <label for="UserField1">1</label>
  --separator--
  <input name="data[User][field]" type="radio" value="2" id="UserField2" />
  <label for="UserField2">2</label>
  --between---
  --after--
</div>

Para elementos tipo date y datetime puede usarse el atributo 'separator' para 
cambiar el string entre elementos select. El valor por defecto es '-'.

• $options[’format’]: El ordenamiento del HTML generado por FormHelper es también
controlable. Las opciones 'format' soportan un array de strings los cuales describen
la plantilla a la que uno querría decir elemento a seguir. Las claves de array 
soportadas son: array(’before’, ’input’, ’between’, ’label’, ’after’,’error’).    

• $options[’inputDefaults’]: Si se haya a uno mismo repitiendo las mismas opciones
en múltiples llamadas input(), puede usar inputDefaults para mantener su código
seco:

echo $this->Form->create(’User’, 
  array(
    ’inputDefaults’ => array(
      ’label’ => false,
      ’div’ => false
    )   
  )
);

Todos los input creados desde ese punto heredarían las opciones declaradas en
inputDefaults. Puede redefinir el defaultOptions declarando la opción en la 
llamada input():

// No div, no label
echo $this->Form->input(’password’);

// has a label element
echo $this->Form->input(’username’, array(’label’ => ’Username’));

Para cambiar posteriormente los valores por defecto usar FormHelper::inputDefaults().

Generar tipos de inputs específicos
-----------------------------------
Adicionalmente al método input() genérico, FormHelper tiene métodos específicos
para generar un número de tipos diferentes de inputs. Estos pueden ser usados
para generar sólo el widget input mismo, y combinado con otros métodos como  
label() y error() para generar layouts de formulario completamente personalizados.

Opciones comunes 
................
Muchos de los métodos de elemento input soportan un set común de opciones. Todas
estas opciones son también soportadas por input(). Para reducir la repetición 
las opciones comunes compartidas por todos los métodos input son como siguen:

• $options[’class’]: Puede fijar el nombre de clase para un input:
 
echo $this->Form->input(’title’, array(’class’ => ’custom-class’));

• $options[’id’]: Fijar esta clave para forzar el valor de id del DOM para el 
input.

• $options[’default’]: Usado para fijar un valor por defecto para el campo input.
El valor es usado si los datos pasados al formulario no contienen un valor para
el campo (ó si no se pasó ningún dato).

Ejemplo de uso:

echo $this->Form->input(’ingredient’, array(’default’ => ’Sugar’));

Ejemplo con el campo select (se seleccionará el tamaño 'Medium' por defecto):

$sizes = array(’s’ => ’Small’, ’m’ => ’Medium’, ’l’ => ’Large’);
echo $this->Form->input(
  ’size’,
  array(’options’ => $sizes, ’default’ => ’m’)
);

Nota: No puede usar 'default' para chequear un checkbox - en vez de eso uno 
puede fijar el valor en $this->request->data en su controlador, ó fijar la
opción input checked a true.

Los campos por defecto date y datetime pueden ser fijados usando la clave 'selected'.

Cuidado al usar false para asignar un valor por defecto. Se usa un valor false
para inhabilitar/excluir opciones de un campo input, así 'default' => false no
fijará ningún valor. En vez de eso usar ’default’ => 0. 

Adicionalmente a las opciones de arriba, puede mezclar (mixin) cualquier atributo
HTML que desea usar. Cualquier nombre de opción no especial será tratado como un 
atributo HTML, y aplicado al elemento input HTML generado.

Opciones para inputs select, chechbox y radio 
.............................................
• $options[’selected’]: Usado en combinación con un input de tipo select 
(ej.: para tipos select, date, time, datetime). Fijar 'selected' al valor del
item que uno quiere seleccionar por defecto cuando el input es renderizado:

echo $this->Form->input(’close_time’, 
  array(
    ’type’ => ’time’,
    ’selected’ => ’13:30:00’
  )
);

Nota: La clave selected para inputs date y datetime pueden también ser un 
timestamp UNIX

• $options[’empty’]: Si se fija a true, fuerza al input a permanecer vacío. 

Cuando es pasado a una lista select, este crea una opción 'en blanco' (blank) 
con un valor vacío en su lista de drop down. Si quiere tener un valor vacío con
exhibido en vez de solo una opción en blanco, pasar un string a vacío:

echo $this->Form->input(’field’, 
  array(
    ’options’ => array(1, 2, 3, 4, 5),
    ’empty’ => ’(choose one)’
  )
);

Salida:

<div class="input">
  <label for="UserField">Field</label>
  <select name="data[User][field]" id="UserField">
    <option value="">(choose one)</option>
    <option value="0">1</option>
    <option value="1">2</option>
    <option value="2">3</option>
    <option value="3">4</option>
    <option value="4">5</option>
  </select>
</div>

Nota: Si uno necesita fijar el valor por defecto en un campo password a valor en
blanco (blank), usar en su lugar 'value' => ''.

Las Options pueden también ser suministradas como pares key-value.

• $options[’hiddenField’]: Para ciertos tipos input (checkboxes, radios) es creado
un input hidden tal que la clave en $this->request->data existirá aún sin un 
valor especificado:

<input type="hidden" name="data[Post][Published]" id="PostPublished_" value="0" />
<input type="checkbox" name="data[Post][Published]" value="1" id="PostPublished" />

Esto puede ser deshabilitado fijando $options[’hiddenField’] = false:

echo $this->Form->checkbox(’published’, array(’hiddenField’ => false));

Que produce:

<input type="checkbox" name="data[Post][Published]" value="1" id="PostPublished" />

Si quiere crear múltiples bloques de inputs en un formulario que están agrupados
todos juntos, debería usar este parámetro en todos los inputs excepto el primero.
Si el input hidden está en la página en múltiples lugares, solo el último grupo
de valores input será almacenado.

En este ej., serían pasados sólo los colores terciarios, y los colores primarios
serían redefinidos:

<h2>Primary Colors</h2>
<input type="hidden" name="data[Color][Color]" id="Colors_" value="0" />
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsRed" />
<label for="ColorsRed">Red</label>
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsBlue" />
<label for="ColorsBlue">Blue</label>
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsYellow" />
<label for="ColorsYellow">Yellow</label>

<h2>Tertiary Colors</h2>
<input type="hidden" name="data[Color][Color]" id="Colors_" value="0" />
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsGreen" />
<label for="ColorsGreen">Green</label>
<input type="checkbox" name="data[Color][Color][]" value="5" id="ColorsPurple" />
<label for="ColorsPurple">Purple</label>
<input type="checkbox" name="data[Addon][Addon][]" value="5" id="ColorsOrange" />
<label for="ColorsOrange">Orange</label>

Inhabilitar ’hiddenField’ en el grupo del 2do input evitaría este comportamiento.
Puede fijar un valor de campo hidden diferente en vez de 0 tal como 'N':

echo $this->Form->checkbox(’published’, 
  array(
    ’value’ => ’Y’,
    ’hiddenField’ => ’N’,
  )
);

Opciones datetime
.................
• $options[’timeFormat’]: Usado para especificar el formato de los inputs select
para un set de inputs relacionados al tiempo. Valores válidos incluyen 12, 24, 
y null.  

• $options[’dateFormat’]: Usado para especificar el formato de los inputs select
para un set de inputs relacionados a date. Valores válidos incluyen cualquier
combinación de ‘D’, ‘M’ y ‘Y’ ó null. Los input serán puestos en el orden definido
por la opción dateFormat.
   
• $options[’minYear’], $options[’maxYear’]: Usado en combinación con un input
date / datetime. Define el final más bajo y/ó más alto de valores mostrados en 
el campo select de años.

• $options[’orderYear’]: Usado en combinación con un input date / datetime. Define
el orden en cual serán fijados los valores de año. Valores válidos incluyen
‘asc’, ‘desc’. El valor por defecto es ‘desc’.     

• $options[’interval’]: Esta opción especifica el número de minutos entre cada
opción en la caja 'select':

echo $this->Form->input(’Model.time’, 
  array(
    ’type’ => ’time’,
    ’interval’ => 15
  )
);

Crearía 4 opciones en el select de minuto. Uno por cada 15 minutos.

• $options[’round’]: Puede establecerse para arriba ó abajo para forzar el 
redondeo en una ú otra dirección. Está por defecto a null el cual redondea de
la mitad para arriba de acuerdo al intervalo.

Nuevo en v.2.4.

Métodos de Formulario específicos del elemento
----------------------------------------------
Todos los elementos son creados bajo un formulario para el modelo User como en
los ej.'s de arriba. Por esta razón, el código HTML generado contendrá atributos
que referencian al modelo User. Ej.: name=data[User][username], id=UserUsername.

FormHelper::label(string $fieldName, string $text, array $options)
..................................................................
Crea un elemento label. $fieldName es usado para generar el id del DOM. Si $text
es indefinido, $fieldName será usado para inclinar (inflect) el texto del label:

echo $this->Form->label(’User.name’);
echo $this->Form->label(’User.name’, ’Your username’);

Salida:

<label for="UserName">Name</label>
<label for="UserName">Your username</label>

$options puede ser ya sea un array de atributos HTML, ó un string que será usado
como un nombre de clase:

echo $this->Form->label(’User.name’, null, array(’id’ => ’user-label’));
echo $this->Form->label(’User.name’, ’Your username’, ’highlight’);

Salida:

<label for="UserName" id="user-label">Name</label>
<label for="UserName" class="highlight">Your username</label>

FormHelper::text(string $name, array $options)
..............................................
El resto de los métodos disponibles en el FormHelper son para crear elementos 
de formulario específicos. Algunos desde estos métodos también hacen uso de un
parámetro $options especial. En este caso, sin embargo, se usa primariamente 
$options para especificar atributos de etiqueta HTML (tal como el valor ó id del
DOM de un elemento en el formulario):

echo $this->Form->text(’username’, array(’class’ => ’users’));

Producirá:

<input name="data[User][username]" type="text" class="users" id="UserUsername" />

FormHelper::password(string $fieldName, array $options)
.......................................................
Crea un campo password:

echo $this->Form->password(’password’);

Producirá:

<input name="data[User][password]" value="" id="UserPassword" type="password" />

FormHelper::hidden(string $fieldName, array $options)
.....................................................
Crea un input de formulario hidden. Ej.:

echo $this->Form->hidden(’id’);

Producirá:

<input name="data[User][id]" id="UserId" type="hidden" />

Si el formulario es editado (el array $this->request->data contendrá info 
almacenada para el modelo User), el valor correspondiente al campo id será 
agregado automáticamente al HTML generado. Ej. para data[User][id] = 10:

<input name="data[User][id]" id="UserId" type="hidden" />

Cambiado en v.2.0: Los campos hidden ya no quitan más el atributo de clase. Esto
significa que si hay errores de validación en campos hidden, el nombre de clase
error-field será aplicado.

FormHelper::textarea(string $fieldName, array $options)
.......................................................
Crea un campo input textarea:

echo $this->Form->textarea(’notes’);

Producirá:

<textarea name="data[User][notes]" id="UserNotes"></textarea>

Si el formulario es editado (esto es, el array $this->request->data contendrá la 
información almacenada para el modelo User), el valor correspondiente al campo
'notes' será agregado automáticamente al HTML generado. Ej.:

<textarea name="data[User][notes]" id="UserNotes">
  This text is to be edited.
</textarea>

Nota: El tipo input textarea permite al atributo $options de 'escape' que determina
si ó no los contenidos del textarea deberían ser escapados. Por defecto a true.

echo $this->Form->textarea(’notes’, array(’escape’ => false);
// OR....
echo $this->Form->input(
  ’notes’,
  array(’type’ => ’textarea’, ’escape’ => false)
);

Opciones
........
Adicionalmente a las opciones comunes, textarea() soporta algunas opciones
específicas:

•$options[’rows’], $options[’cols’]: Estas 2 claves especifican el número de filas
y columnas:

echo $this->Form->textarea(
  ’textarea’,
  array(’rows’ => ’5’, ’cols’ => ’5’)
);

Produce:

<textarea name="data[Form][textarea]" cols="5" rows="5" id="FormTextarea"></textarea>

FormHelper::checkbox(string $fieldName, array $options)
.......................................................
Crea un elemento checkbox de formulario. Este método también genera un input form
hidden asociado para forzar el envío de datos para el campo especificado:

echo $this->Form->checkbox(’done’);

Producirá:

<input type="hidden" name="data[User][done]" value="0" id="UserDone_" />
<input type="checkbox" name="data[User][done]" value="1" id="UserDone" />

Es posible especificar el valor del checkbox usando el array $options:

echo $this->Form->checkbox(’done’, array(’value’ => 555));

Producirá:

<input type="hidden" name="data[User][done]" value="0" id="UserDone_" />
<input type="checkbox" name="data[User][done]" value="555" id="UserDone" />

Si uno no busca que el Form helper cree un input hidden:

echo $this->Form->checkbox(’done’, array(’hiddenField’ => false));

Producirá:

<input type="checkbox" name="data[User][done]" value="1" id="UserDone" />

FormHelper::radio(string $fieldName, array $options, array $attributes)
.......................................................................
Crea un set de inputs radio button.

Opciones
........
•$attributes[’value’]: Para fijar que valor debería ser seleccionado por defecto.

•$attributes[’separator’]: Para especificar HTML entre radio buttons (ej.: <br />).

•$attributes[’between’]: Especifica algún contenido a ser insertado entre la leyenda y el 1er elemento.

•$attributes[’disabled’]: Especifica esto a 'true' ó 'disabled' inhabilitará todos los radio buttons generados.

•$attributes[’legend’]: Los elementos Radio son envueltos con un label y fieldset por defecto.
 Fija $attributes[’legend’] a false para quitarlos:
  
 $options = array(’M’ => ’Male’, ’F’ => ’Female’);
 $attributes = array(’legend’ => false);
 echo $this->Form->radio(’gender’, $options, $attributes);

Producirá:

<input name="data[User][gender]" id="UserGender_" value="" type="hidden" />
<input name="data[User][gender]" id="UserGenderM" value="M" type="radio" />
<label for="UserGenderM">Male</label>
<input name="data[User][gender]" id="UserGenderF" value="F" type="radio" />
<label for="UserGenderF">Female</label>

Si por alguna razón uno no busca el input hidden, fijar $attributes[’value’] a un
valor selected ó boolean false hará solo eso.

En v.2.1: Fue agregada la opción $attributes[’disabled’].

FormHelper::select(string $fieldName, array $options, array $attributes)
........................................................................
Crea un elemento select, populado con los items en $options, con la opción 
especificada por $attributes[’value’] mostrada como seleccionada por defecto. 
Fijar la clave ‘empty’ en la variable $attributes a false apaga la opción vacío 
por defecto:

$options = array(’M’ => ’Male’, ’F’ => ’Female’);
echo $this->Form->select(’gender’, $options);

Producirá:

<select name="data[User][gender]" id="UserGender">
  <option value=""></option>
  <option value="M">Male</option>
  <option value="F">Female</option>
</select>

El tipo input select permite un atributo $option especial llamado ’escape’ que 
acepta un booleano y determina si la entidad HTML codifica los contenidos de las
opciones select. Por defecto en true:

$options = array(’M’ => ’Male’, ’F’ => ’Female’);
echo $this->Form->select(’gender’, $options, array(’escape’ => false));

•$attributes[’options’]: Esta clave le permite especificar opciones manualmente
para un input select, ó para un grupo radio. A menos que el 'type' se especifique
como 'radio', FormHelper asumirá que la salida objetivo es un input select:

echo $this->Form->select(’field’, array(1,2,3,4,5));

Produce:

<select name="data[User][field]" id="UserField">
  <option value="0">1</option>
  <option value="1">2</option>
  <option value="2">3</option>
  <option value="3">4</option>
  <option value="4">5</option>
</select>

Las opciones pueden también ser suministradas como pares clave-valor:

echo $this->Form->select(’field’, 
  array(
    ’Value 1’ => ’Label 1’,
    ’Value 2’ => ’Label 2’,
    ’Value 3’ => ’Label 3’
  )
);

Produce:

<select name="data[User][field]" id="UserField">
  <option value="Value 1">Label 1</option>
  <option value="Value 2">Label 2</option>
  <option value="Value 3">Label 3</option>
</select>

Si uno quisiese generar un select con optgroups, sólo pasar datos en formato
jerárquico. Esto funciona en checkboxes y radioboxes múltiples también, pero en
vez de optgroups envuelve elementos en fieldsets:

$options = array(
  ’Group 1’ => array(
    ’Value 1’ => ’Label 1’,
    ’Value 2’ => ’Label 2’
  ),
  ’Group 2’ => array(
    ’Value 3’ => ’Label 3’
  )
);
echo $this->Form->select(’field’, $options);

Produce:

<select name="data[User][field]" id="UserField">
  <optgroup label="Group 1">
    <option value="Value 1">Label 1</option>
    <option value="Value 2">Label 2</option>
  </optgroup>
  <optgroup label="Group 2">
    <option value="Value 3">Label 3</option>
  </optgroup>
</select>

•$attributes[’multiple’]: Si ‘multiple’ ha sido fijado a true para un input que
produce un select, el select permitirá selecciones múltiples:

echo $this->Form->select(
  ’Model.field’,
  $options,
  array(’multiple’ => true)
);

Alternativamente fijar 'multiple' a 'checkbox' para producir una lista de
checkboxes relacionados:

$options = array(
  ’Value 1’ => ’Label 1’,


SEGUIR(125/203)