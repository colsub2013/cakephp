VISTAS
======
Las vistas son responsables de generar la salida específica requerida para la
petición. Posibles formas:

. HTML
. XML
. JSON
. Archivos de streaming
. Descarga de PDF

CakePHP viene con algunas clases de View incorporadas para manejar los escenarios
de renderización más comunes:

. Para crear web services XML ó JSON puede usar vistas XML ó JSON
. Para servir archivos protegidos, ó archivos generados dinámicamente, puede usar
  Sending files
. Para crear vistas con temas múltiples, puede usar Themes 

Plantillas de Vista
-------------------
Por defecto los archivos de vista de CakePHP están escritos en PHP plano y tienen
extensión .ctp (Plantilla CakePHP). Estos archivos contienen toda la lógica de
presentación necesaria para obtener los datos que este recibió del controlador
en un formato que está listo para la audiencia a la que uno sirve.

Un archivo de vista se almacena en /app/View/, en una subcarpeta nombrada después
del controlador que usa el archivo. Tiene un nombre de archivo correspondiente
a su acción. Ej.: el archivo de vista para la acción 'view()' del controlador de
'Products' se encontraría normalmente en /app/View/Products/view.ctp. 

La capa de vista en CakePHP puede hacerse de un número de partes diferentes:

. Vistas (Views): las Views son parte de la página que es única a la acción que
se está corriendo. Forman la carne de la respuesta de su aplicación.

. Elements: pequeños fragmentos de código de vista reutilizables. Los elementos
son usualmente renderizados dentro de vistas.

. Layouts: archivos de vista que contienen código de presentación que envuelve
varias interfaces en su aplicación. La mayoría de las vistas son renderizadas
dentro de un layout.

. helpers: estas clases encapsulan lógica de vista que es necesaria en varios 
lugares en la capa de vista. Estos pueden ayudar a construir formularios, construir
funcionalidad AJAX, datos de paginación del modelo, ó servir alimentaciones RSS.
  
Extender Vistas
---------------
Las extensiones de Vista le permite envolver una vista en otra. Ej.: su aplicación
tiene una barra lateral que necesita cambiar dependiendo de la vista específica
siendo renderizada. Extender un archivo de vista común, puede evitar repetir
el marcado común para su barra lateral, y sólo definir las partes que cambian:

// app/View/Common/view.ctp
<h1><?php echo $this->fetch(’title’); ?></h1>
<?php echo $this->fetch(’content’); ?>

<div class="actions">
  <h3>Related actions</h3>
  <ul>
    <?php echo $this->fetch(’sidebar’); ?>
  </ul>
</div>

El archivo de vista de arriba podría usarse como una vista padre. Esta espera que
la vista que extiende definirá los bloques de título y barra lateral. El
bloque de contenido contendrá todo el contenido no capturado de la vista que se
extiende. Asumiendo que nuestro archivo de vista tiene una variable $post con los
datos sobre nuestro post, la vista luciría:

<?php
  // app/View/Posts/view.ctp
  $this->extend(’/Common/view’);
  $this->assign(’title’, $post);
  $this->start(’sidebar’);
?>
<li>
  <?php
    echo $this->Html->link(
      ’edit’, array(
        ’action’ => ’edit’,
        $post[’Post’][’id’]
      )
    ); 
  ?>
</li>
<?php $this->end(); ?>
// The remaining content will be available as the ’content’ block
// in the parent view.
<?php echo h($post[’Post’][’body’]);

La vista post de arriba muestra como uno puede extender una vista, y popular un
set de bloques. Cualquier contenido ya no definido en un bloque definido será
capturado y puesto en un bloque especial nombrado 'content'. Cuando una vista
contiene una llamada a extend(), la ejecución continúa hasta el fondo del 
archivo de vista actual. Una vez que este está completo, la vista extendida 
será renderizada. Llamar a extend() más de una vez en un archivo de vista 
redefinirá la vista padre que se procesará luego:

$this->extend(’/Common/view’);
$this->extend(’/Common/index’);

El resultado de arriba resultará en /Common/index.ctp siendo renderizado como 
la vista padre a la vista actual.

Puede anidar vistas extendidas tantas veces como necesite. Cada vista puede 
extender otra vista si se desea. Cada vista padre obtendrá el contenido 
de la vista previa así como el bloque content.

Nota: Debería evitar usar 'content' como un nombre de bloque en su aplicación.
CakePHP lo usa para contenido sin capturar en vistas extendidas.

Usar bloques de vista
---------------------
Los bloques de vista reemplazan $scripts_for_layout y proveen una API flexible
que le permite definir ranuras ó bloques en sus vistas/layouts que serán definidas
en algún lado. Ej.: los bloques son ideales para implementar cosas como barras
laterales, ó regiones para cargar bienes (assets) en el fondo / cima del layout.
Los bloques pueden ser definidos de 2 modos: ya sea como un bloque de captura,
ó por asignación directa. Los métodos start(), append() y end() le permiten 
trabajar con bloques de captura:

// create the sidebar block.
$this->start(’sidebar’);
echo $this->element(’sidebar/recent_topics’);
echo $this->element(’sidebar/recent_comments’);
$this->end();

// Append into the sidebar later on.
$this->append(’sidebar’);
echo $this->element(’sidebar/popular_topics’);
$this->end();

Puede también anexar dentro de un bloque usando start() en múltiples ocasiones.
assign() puede ser usado para limpiar (clear) ó sobreescribir un bloque a la vez:

// Clear the previous content from the sidebar block.
$this->assign(’sidebar’, ’’);

En 2.3, se agregaron métodos nuevos para trabajar con bloques. El método prepend()
se agregó al contenido prepend() para un bloque existente:

// Prepend to sidebar
$this->prepend(’sidebar’, ’this content goes on top of sidebar’);

El método startIfEmpty() puede usarse para iniciar un bloque sólo si este está
vacío ó indefinido. Si el bloque ya existe, el contenido capturado será 
descartado. Esto es útil cuando quiere definir condicionalmente el contenido por
defecto para un bloque si este no existe realmente:
 
// In a view file.
// Create a navbar block
$this->startIfEmpty(’navbar’);
echo $this->element(’navbar’);
echo $this->element(’notifications’);
$this->end();

// In a parent view/layout
<?php $this->startIfEmpty(’navbar’); ?>
<p>If the block is not defined by now - show this instead</p>
<?php $this->end(); ?>
// Somewhere later in the parent view/layout
echo $this->fetch(’navbar’);

En el ej. de arriba, el bloque navbar solo contendrá el contenido agregado en 
la 1er sección. Ya que el bloque fue definido en la vista hijo, el contenido por
defecto con <p> será descartado.

Nota: Debería evitar usar content como un nombre de bloque. Este es usado 
por CakePHP internamente para vistas extendidas, y contenido de vista en el layout.

Exhibir bloques
...............
Puede exhibir bloques con el método fetch(), el cual da salida a un bloque, retornando
'' si un bloque no existe:

echo $this->fetch(’sidebar’);

Puede también usar fetch para mostrar contenido condicionalmente que que debería
rodear un bloque si este existe. Esto es útil en layouts, ó vistas extendidas
donde uno quiere mostrar encabezados ú otro marcado de forma condicional:

// in app/View/Layouts/default.ctp
<?php if ($this->fetch(’menu’)): ?>
  <div class="menu">
    <h3>Menu options</h3>
    <?php echo $this->fetch(’menu’); ?>
  </div>
<?php endif; ?>

Como en 2.3.0, puede también proveer un valor por defecto para un bloque si este
no tienen ningún contenido. Esto le permite agregar contenido de posición 
(placeholder) para estados vacíos. Puede proveer un valor por defecto usando
el 2do argumento:

<div class="shopping-cart">
  <h3>Your Cart</h3>
  <?php echo $this->fetch(’cart’, ’Your cart is empty’); ?>
</div>

El argumento $default se agregó en 2.3.

Using blocks for script and CSS files
-------------------------------------
Los bloques reemplazan la variable de layout $scripts_for_layout deprecada. En
vez de eso debería usar bloques. El HtmlHelper se une en bloques de vista, y sus
métodos script(), css(), y meta() pueden cada uno actualizar un bloque con el 
mismo nombre cuando se usa con la opción inline = false:

<?php
  // in your view file
  $this->Html->script(’carousel’, array(’inline’ => false));
  $this->Html->css(’carousel’, null, array(’inline’ => false));
?>
// In your layout file.
<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <?php echo $this->fetch(’script’); ?>
    <?php echo $this->fetch(’css’); ?>
  </head>
  // rest of the layout follows

El HtmlHelper también le permite controlar a que bloque van los scripts y CSS:

// in your view
$this->Html->script(’carousel’, array(’block’ => ’scriptBottom’));

// in your layout
echo $this->fetch(’scriptBottom’);

Layouts
.......
Un layout contiene código de presentación que se envuelve alrededor de una vista.
Todo lo que querría ver en todas sus vistas debería ponerse en el layout.

El layout por defecto de CakePHP se ubica en /app/View/Layouts/default.ctp. Si
quiere cambiar completamente como se ve su aplicación, empezar con esto, ya que
el código de vista renderizado por controlador se ubica dentro del layout por 
defecto cuando la página es renderizada.

Otros archivos de layout debería ubicarse en /app/View/Layouts. Al crear un layout,
necesita decirle a CakePHP donde poner la salida de sus vistas. Para hacerlo,
asegurarse de que su layout incluya un lugar para $this->fetch(’content’). Ej.
de como debería lucir un layout por defecto:

<!DOCTYPE html>
<html lang="en">
  <head>
    <title><?php echo $this->fetch(’title’); ?></title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <!-- Include external files and scripts here (See HTML helper for more info.) -->
    <?php
      echo $this->fetch(’meta’);
      echo $this->fetch(’css’);
      echo $this->fetch(’script’);
    ?>
  </head>
  <body>
  <!-- If you’d like some sort of menu to show up on all of your views, include it here -->
    <div id="header">
      <div id="menu">...</div>
    </div>
    <!-- Here’s where I want my views to be displayed -->
    <?php echo $this->fetch(’content’); ?>
    <!-- Add a footer to each displayed page -->
    <div id="footer">...</div>
  </body>
</html>

Nota: fetch(’content’) es un reemplazo para $content_for_layout y las líneas
fetch(’meta’), fetch(’css’) y fetch(’script’) son contenidas en la variable
$scripts_for_layout.

Los bloques script, css y meta contienen cualquier contenido definido en las 
vistas usando el helper HTML incorporado. Útil para incluir archivos CSS y 
Javascript desde vistas.

Nota: Al usar HtmlHelper::css() ó HtmlHelper::script() en archivos de vista,
especificar 'false' para la opción 'inline' para poner la fuente HTML en un 
bloque con el mismo nombre.   

El bloque 'content' contiene los contenidos de la vista renderizada.

$title_for_layout contiene el título de página. Esta variable es generada 
automáticamente, pero uno puede redefinirla fijándola en su controlador / vista.

Fijar el título para el layout es más fácil hacerlo en el controlador, fijando
la variable $title_for_layout:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
  }
}

Puede también fijar la variable title_for_layout desde dentro del archivo de vista:

$this->set(’title_for_layout’, $titleContent);

Puede crear varios layouts como quiera: sólo ubíquelos en el directorio app/View/Layouts,
e intercambiar entre ellos dentro de sus acciones controlador usando la propiedad
$layout de la vista:

// from a controller
public function admin_view() {
  // stuff
  $this->layout = ’admin’;
}

// from a view file
$this->layout = ’loggedin’;

Ej.: si una sección de mi sitio incluyó un espacio para banner de avisos (ad), puedo
crear un layout nuevo con el menor espacio de publicidad y especificarlo como el
layout para todas las acciones de controlador usando algo como:

class UsersController extends AppController {
  public function view_active() {
    $this->set(’title_for_layout’, ’View Active Users’);
    $this->layout = ’default_small_ad’;
  }

  public function view_image() {
    $this->layout = ’image’;
    //output user image
  }
}

CakePHP tiene 2 layouts núcleo característicos (junto al layout por defecto de
CakePHP) que uno puede usar:

. ‘ajax’: útil para elaboración de respuestas AJAX - es un layout vacío (la
  mayoría de las llamadas AJAX sólo requieren un pequeño marcado en el retorno.
  en vez de una interfaz completamente renderizada).  

. ‘flash’: se usa para mensajes mostrados por el método Controller::flash().

Los otros 3 layouts, xml, js y rss existen en el núcleo para servir contenido 
que no es text/html.

Usar layouts desde plugins
..........................
Si quiere usar un layout que existe en un plugin, puede usar sintaxis de plugin.
Ej.: para usar el layout de contenido desde el plugin Contacts:

class UsersController extends AppController {
  public function view_active() {
    $this->layout = ’Contacts.contact’;
  }
}

Elementos
---------
Algunas aplicaciones tienen pequeños bloques de código de presentación que 
necesitan repetirse de página a página, a veces en lugares diferentes del layout.
CakePHP puede ayudarle a repetir partes de su página web que necesitan reusarse.
Estas partes reutilizables son llamadas 'Elementos'. Avisos, cajas de ayuda,
controles de navegación, menús extra, formularios de login, y callouts son 
con frecuencia implementados en CakePHP como elementos. Los 'Elementos' pueden
usarse para hacer una vista más legible, poniendo el renderizado de repetir 
elementos en su propio archivo. Estos pueden también ayudarlo a reutilizar
fragmentos de contenido en su aplicación.

Los 'Elementos' viven en la carpeta /app/View/Elements/, y tienen la extensión de
archivo .ctp. Son salida usando el método element de la vista:

echo $this->element(’helpbox’);

Pasar variables dentro de un Elemento
.....................................
Puede pasar datos a un elemento a través del 2do argumento del elemento:

echo $this->element(’helpbox’, array(
  "helptext" => "Oh, this text is very helpful."
));

Dentro del archivo elemento, todas las variables pasadas están disponibles como 
miembros del array de parámetro (del mismo modo que Controller::set() en el 
controlador funciona con los archivos de vista). En el ej. de arriba, el archivo
/app/View/Elements/helpbox.ctp puede usar la variable $helptext:

// inside app/View/Elements/helpbox.ctp
echo $helptext; //outputs "Oh, this text is very helpful."

El método View::element() también soporta opciones para el elemento. Las opciones
soportadas son ‘cache’ y ‘callbacks’. Ej.:

echo $this->element(’helpbox’, 
  array(
    "helptext" => "This is passed to the element as $helptext",
    "foobar" => "This is passed to the element as $foobar",
  ),
  array(
    // uses the "long_view" cache configuration
    "cache" => "long_view",
    // set to true to have before/afterRender called for the element
    "callbacks" => true
  )
);

El cacheo de elemento es facilitado a través de la clase Cache. Puede configurar
elementos para ser almacenados en cualquier configuración de Cache que ha 
establecido. Esto le da flexibilidad para decidir donde y por cuanto los elementos
son almacenados. Para cachear versiones diferentes del mismo elemento en una
aplicación, proveer un valor de clave de cache único usando el formato:

$this->element(’helpbox’, array(), array(
  "cache" => array(’config’ => ’short’, ’key’ => ’unique value’)
  )
);

You can take full advantage of elements by using requestAction(), which fetches view variables from
a controller action and returns them as an array. This enables your elements to perform in true MVC style.
Create a controller action that prepares the view variables for your elements, then call requestAction()
inside the second parameter of element() to feed the element the view variables from your controller.

To do this, in your controller add something like the following for the Post example:

class PostsController extends AppController {
  // ...
  public function index() {
    $posts = $this->paginate();
    if ($this->request->is(’requested’)) {
      return $posts;
    } else {
      $this->set(’posts’, $posts);
    }
  }
}

And then in the element we can access the paginated posts model. To get the latest five posts in an ordered
list, we would do something like the following:

<h2>Latest Posts</h2>
<?php
  $posts = $this->requestAction(
    ’posts/index/sort:created/direction:asc/limit:5’
  );
?>
<ol>
<?php foreach ($posts as $post): ?>
<li><?php echo $post[’Post’][’title’]; ?></li>
<?php endforeach; ?>
</ol>

Cachear elementos
.................
Puede tomar ventaja del cacheo de vista de CakePHP si suministra un parámetro de
caché. Si se lo fija a true, cacheará el elemento en la configuración Cache por
'defecto'. Sino, puede setear que configuración de cache debería usarse. Ej. de
cachear un elemento:

echo $this->element(’helpbox’, array(), array(’cache’ => true));

Si renderiza el mismo elemento más de una vez en una vista y tiene el cacheo 
habilitado, fijar el parámetro 'key' a un nombre diferente cada vez. Esto evitará
que cada llamada sucesiva sobreescriba el resultado cacheado de la llamada del
element() previo. Ej.:

echo $this->element(
  ’helpbox’,
  array(’var’ => $var),
  array(’cache’ => array(’key’ => ’first_use’, ’config’ => ’view_long’)
);

echo $this->element(
  ’helpbox’,
  array(’var’ => $differenVar),
  array(’cache’ => array(’key’ => ’second_use’, ’config’ => ’view_long’)
);

Lo de arriba asegurará que ambos resultados element son cacheados de forma
separada. Si quiere que todos los cacheos de elemento usen la misma configuración
de caché, puede evitar alguna repetición fijando View::$elementCache a la 
configuración de caché que quiere usar. CakePHP usará esta configuración 
cuando no se de nada. 

Peticionar elementos desde un plugin
....................................

2.0
...
Para cargar un elemento desde un plugin, usar la opción plugin:

echo $this->element(’helpbox’, array(), array(’plugin’ => ’Contacts’));

2.1
...
Si uno está usando un plugin y desea usar elementos desde dentro del plugin, 
use la sintaxis familiar de plugin. Si la vista está siendo renderizada desde un
controlador / acción plugin, el nombre del plugin será prefijado automáticamente
sobre todos los elementos utilizados, a menos que otro nombre de plugin esté
presente. Si el elemento no existe en el plugin, este mirará en la carpeta 
principal APP:

echo $this->element(’Contacts.helpbox’);

Si su vista es una parte de un plugin, puede omitir el nombre de plugin. Ej.:
si uno está en el ContactsController del plugin Contacts, lo siguiente:

echo $this->element(’helpbox’);
// and
echo $this->element(’Contacts.helpbox’);

es equivalente y resultará en el mismo elemento siendo renderizado.

Cambio en v.2.1: la opción $options[plugin] fue deprecada y se agregó soporte
para Plugin.element.

Crear sus propias clases de vista
---------------------------------
Puede necesitar crear clases de vista personalizadas para habilitar tipos nuevos
de vistas de datos, ó agregar lógica personalizada de renderización de vista 
adicional a su aplicación. Convenciones de clases de vista:

• Los archivos de clase View deberían ponerse en App/View. Ej.: App/View/PdfView.php
• Las clases View deberían tener el sufijo 'View'. Ej.: PdfView.
• Al referenciar nombres de clase de vista debería omitir el sufijo View. Ej.:
  $this->viewClass = ’Pdf’;.

Uno también querrá extender View para asegurarse que las cosas funcionen:

// in App/View/PdfView.php
App::uses(’View’, ’View’);
class PdfView extends View {
  public function render($view = null, $layout = null) {
    // custom logic here.
  }
}

Reemplazar el método 'render' le deja tomar control completo sobre como su 
contenido es renderizado.

API View 
--------
Clase View
..........
Los métodos View son accesibles en todas las vistas, elementos y archivos de 
layout. Para llamar a cualquier método view usar $this->method():

View::set(string $var, mixed $value)
Las Views tienen un método set() que es análogo al set() hallado en objetos Controller.
Usar set() desde su archivo vista agregará las variables al layout y elementos 
que serán posteriormente renderizados.  

En su archivo vista puede hacer:

$this->set(’activeMenuButton’, ’posts’);

En su layout, la variable $activeMenuButton estará disponible y contiene el valor
'posts'.

View::get(string $var, $default = null)
Obtener el valor de una viewVar con el nombre $var.

Puede proveer un valor por defecto en caso que la variable ya no esté fijada.
Cambiado en v.2.5: el argumento $default fue agregado en 2.5.

View::getVar(string $var)
Obtiene el valor del viewVar con el nombre $var.
Deprecado desde v.2.3: usar View::get(). 

View::getVars()
Obtiene una lista de todas las variables de vista disponibles en el ámbito
de renderización actual. Retorna un array de nombre de variables.

View::element(string $elementPath, array $data, array $options = array())
Renderiza un elemento ó vista parcial. 

View::uuid(string $object, mixed $url)
Genera un ID DOM único no aleatorio para un objeto, basado en el tipo de objeto
y URL. Este método se usa con frecuencia por helpers que necesitan generar 
ID's de DOM únicos para elementos como el JsHelper:

$uuid = $this->uuid(
  ’form’,
  array(’controller’ => ’posts’, ’action’ => ’index’)
);
//$uuid contains ’form0425fe3bad’

View::addScript(string $name, string $content)
Agrega contenido al buffer de scripts interno. Este buffer es hecho disponible
en el layout como $scripts_for_layout. Este método es útil al crear helpers
que necesitan agregar javascript ó css directamente al layout. Los scripts
agregados desde el layout y elementos en el layout no serán agregados a 
$scripts_for_layout. Este método se usa con frecuencia desde dentro de helpers,
como helpers JsHelper y HtmlHelper. Deprecado en v.2.1. 

View::blocks()
Obtiene los nombres de todos los bloques definidos como un array.

View::start($name)
Comienzan un bloque de captura para un bloque de vista. 
Nuevo en v.2.1.

View::end()
Finaliza el bloque de captura más abierto en la parte superior.
Nuevo en v.2.1.

View::append($name, $content)
Agregado al bloque con $name. 
Nuevo en v.2.1.

View::prepend($name, $content)
Anteponer al bloque con $name. 
Nuevo en v.2.3.

View::startIfEmpty($name)
Inicia un bloque si este está vacío. Todo el contenido en el bloque será capturado
y descartado si el bloque ya está definido.
Nuevo en v.2.3.

View::assign($name, $content)
Asigna el valor de un bloque. Esto sobreescribirá cualquier contenido existente.
Nuevo en v.2.1.

View::fetch($name, $default = ‘’)
Extrae el valor de un bloque. Si un bloque está vacío ó indefinido, se retornará ''.
Nuevo en v.2.1.

View::extend($name)
Extiende el view/element/layout actual con el nombrado (en argumento). 
Nuevo en v.2.1.

property View::$layout
Fija al layout la vista actual que será contenida (wrapped in).

property View::$elementCache
La configuración de caché usada para elementos de caché. Fijar esta propiedad
cambiará la configuración por defecto usada para elementos de caché. Este 
valor por defecto puede ser redefinido usando la opción 'cache' en el método
element.

property View::$request
Una instancia de CakeRequest. Usar esta instancia para acceder a información sobre
la petición actual.

property View::$output
Contiene el último contenido renderizado desde una vista, ya sea el archivo de
vista, ó el contenido de layout. Deprecado en v.2.1: Usar 
$view->Blocks->get(’content’); en lugar de eso.

property View::$Blocks
Una instancia de ViewBlock. Usada para proveer funcionalidad de bloque de vista
en la renderización de la vista.
New in version 2.1.

Más sobre vistas
----------------

Temas (Themes)
..............
Puede tomar ventaja de temas, haciendo fácil intercambiar el look and feel de 
su página rápido y fácil.

Para usar temas, especificar el nombre de tema en su controlador:

SEGUIR(97)