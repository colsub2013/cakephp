MODELOS
=======
Las clases del modelo pueden usarse para acceder a:

. Tablas de base de datos
. Archivos
. Web Services externos
. Eventos iCal

Un modelo puede asociarse con otros. Ej.: un Recipe puede asociarse con un Author
como también un Ingredient.

Entender Modelos
----------------
Un modelo representa modelo de datos. 

Ej. de definición de modelo en CakePHP:

App::uses(’AppModel’, ’Model’);
class Ingredient extends AppModel {
  public $name = ’Ingredient’;
}

Con sólo una declaración, el modelo Ingredient es dotado con toda la funcionalidad
que necesita para crear consultas y almacenar y borrar datos. Estos métodos vienen
de la clase Modelo de CakePHP por herencia. El modelo Ingredient extiende 
el modelo de aplicación, AppModel, que a su vez extiende la clase Model interna
de CakePHP. 

Es esta clase Model núcleo que otorga la funcionalidad en su modelo Ingredient.
App::uses(’AppModel’, ’Model’) asegura que el modelo es cargado cuando se
necesite.

La clase intermedia, AppModel, está vacía. Si no la ha creado, se tomará de la
carpeta núcleo de CakePHP. Redefinir el AppModel le permite definir funcionalidad
que debería estar disponible a todos los modelos dentro de su aplicación. Para
hacerlo, necesita crear su propio archivo AppModel.php que reside en la carpeta
Model, como lo hace con todos los otros modelos de su aplicación. Crear un proyecto
usando Bake generará automáticamente este archivo por uno.

De vuelta en el modelo Ingredient, crear el archivo PHP en el directorio /app/Model/.
Por convención, este debería tener el mismo nombre que la clase, que para este ej.
es Ingredient.php.

Nota: CakePHP creará dinámicamente un objeto modelo para uno si este no puede 
hallar un archivo correspondiente en /app/Model. Esto significa que si su 
archivo modelo no se nombra correctamente (ej., se nombra ingredient.php ó 
Ingredients.php en vez de Ingredient.php), CakePHP usará una instancia de AppModel
en vez de su archivo modelo (que CakePHP asume perdido). Si uno intenta usar 
un método que ha definido en su modelo, ó un comportamiento unido a su modelo,
y uno está obteniendo errores SQL que que son el nombre del método que uno está
llamando, es una señal segura que CakePHP no puede hallar su modelo y necesita
chequear los nombres de archivo, su caché de aplicación, ó ambos.

Nota: Algunos nombres de clase no son útiles para nombres de modelo. Ej.: 'File'
no puede usarse, ya que 'File' es una clase que ya existe en el núcleo CakePHP.

Definido su modelo, este puede ser accedido desde dentro de su Controller. CakePHP
hará al modelo disponible automáticamente para acceso cuando su nombre coincida
con el del controlador. Ej.: un controlador llamado IngredientsController inicializará
automáticamente el modelo Ingredient y lo anexará al controlador en $this->Ingredient:

class IngredientsController extends AppController {
  public function index() {
    //grab all ingredients and pass it to the view:
    $ingredients = $this->Ingredient->find(’all’);
    $this->set(’ingredients’, $ingredients);
  }
}

Los modelos asociados están disponibles a través del modelo principal. En el 
siguiente ej., Recipe tiene una asociación con el modelo Ingredient:

class Recipe extends AppModel {
  public function steakRecipes() {
    $ingredient = $this->Ingredient->findByName(’Steak’);
    return $this->findAllByMainIngredient($ingredient[’Ingredient’][’id’]);
  }
}

Este muestra como usar modelos que ya están enlazados (linked).

Más sobre modelos
-----------------

Asociaciones: Enlazar modelos
-----------------------------
En CakePHP, los enlaces entre modelos son manejados a través de asociaciones.

Definir relaciones entre objetos diferentes en su aplicación debería ser un 
proceso natural. Ej.: en una DB recipe (receta), una receta puede tener varias
reseñas (reviews), las reseñas pueden tener un único autor, y los autores pueden
tener varias recetas.

Relationship Types
..................
Los 4 tipos de asociación en CakePHP son: hasOne, hasMany, belongsTo, y hasAndBelongsToMany
(HABTM).

---------------------------------------------------------------------------------------------------
| Relación       | Tipo de asociación  | Ejemplo                                                  |
---------------------------------------------------------------------------------------------------
| one to one     | hasOne              | Un usuario tiene un único perfil.                        |
| one to many    | hasMany             | Un usuario puede tener múltiples recetas.                |
| many to one    | belongsTo           | Muchas recetas pueden pertenecer a un usuario.           |
| many to many   | hasAndBelongsToMany | Las recetas tienen, y pertenecen a varios ingredientes.  |
---------------------------------------------------------------------------------------------------

Las asociaciones son definidas creando una variable de clase nombrada después de la 
asociación que uno está definiendo. La variable de clase puede ser tanto un
string como un array multidimensional usado para definir cosas específicas de 
asociación.

class User extends AppModel {
  public $hasOne = ’Profile’;
  public $hasMany = array(
    ’Recipe’ => array(
      ’className’ => ’Recipe’,
      ’conditions’ => array(’Recipe.approved’ => ’1’),
      ’order’ => ’Recipe.created DESC’
    )
  );
}

En el ej. de arriba, la 1ra instancia de la palabra 'Recipe' es lo que se denomina
un 'Alias'. Este es un identificador para la relación, y puede ser cualquiera que
elija. Usualmente, uno eligirá el mismo nombre que la clase que este referencia.
Pero, los alias para cada modelo deben ser únicos a través de la aplicación. 
Ej.: es apropiado tener:

class User extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’MemberOf’ => array(
      ’className’ => ’Group’,
    )
  );
  
}

class Group extends AppModel {
  
  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’User’,
    )
  );
}

pero lo siguiente no funcionará bien en todas las circunstancias:

class User extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’Group’,
    )
  );

}

class Group extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’User’,
    )
  );

}

debido a que aquí tenemos el alias 'Member' que se refiere a ambos User (en Group)
y el modelo Group (en User) en las asociaciones HABTM. Elegir nombres no únicos
para alias de modelo a través de modelos pueden originar un comportamiento
inesperado. 

CakePHP creará automáticamente enlaces entre los objetos modelo asociados. Ej.: 
en su modelo User uno puede acceder al modelo Recipe como:

$this->Recipe->someFunction();

Similarmente en su controlador uno puede acceder a un modelo asociado simplemente
siguiendo sus asociaciones de modelo:

$this->User->Recipe->someFunction();

Nota: las asociaciones son definidas en 'un sentido'. Si define User hasMany Recipe,
esto no tiene efecto en el Modelo Recipe. Necesita definir Recipe belongsTo User 
para ser capaz de acceder al modelo User desde su modelo Recipe.

hasOne
......
Se va a configurar un modelo User con una relación hasOne para un modelo Profile.

Primero, sus tablas en la DB necesitan tener las claves correctamente. Para que 
funcione una relación hasOne, una tabla tiene que contener una clave foránea
que apunta a un registro en la otra. En este caso, la tabla profiles contendrá
un campo llamado user_id. El patrón básico:

hasOne: el otro modelo contiene la clave foránea.
°°°°°°
---------------------------------------------
| Relación              | Esquema           | 
---------------------------------------------
| Apple hasOne Banana   | bananas.apple_id  |
| User hasOne Profile   | profiles.user_id  |
| Doctor hasOne Mentor  | mentors.doctor_id |
---------------------------------------------

Nota: no es obligatorio seguir las convenciones CakePHP. Puede redefinir el uso
de cualquier clave foránea en sus definiciones de asociaciones.

El archivo modelo User será almacenado en /app/Model/User.php. Para definir la 
asociación ‘User hasOne Profile’, agregar la propiedad $hasOne a la clase modelo.
Recordar tener un modelo Profile en /app/Model/Profile.php, ó la asociación no
funcionará: 
 
class User extends AppModel {
  public $hasOne = ’Profile’;
}

Hay 2 modos de describir esta relación en sus archivos modelo. El método más
simple es fijar el atributo $hasOne a un string que contiene el nombre de clase
del modelo asociado, como se ha hecho arriba.

Si necesita más control, puede definir sus asociaciones usando sintaxis de array.
Ej.: puede querer limitar la asociación para incluir sólo ciertos registros.

class User extends AppModel {
  public $hasOne = array(
    ’Profile’ => array(
      ’className’ => ’Profile’,
      ’conditions’ => array(’Profile.published’ => ’1’),
      ’dependent’ => true
    )
  );
}

Las claves posibles para los arrays de asociación hasOne incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. Si 
uno está definiendo una relación ‘User hasOne Profile’, la clave className sería
igual a ‘Profile’. 

• foreignKey: el nombre de la clave foránea hallada en el otro modelo. Esto es
útil si necesita definir relaciones hasOne múltiples. El valor por defecto para 
esta clave es el '_', el nombre único del modelo actual, con sufijo ‘_id’. En el
ej. de arriba, este sería por defecto ‘user_id’.

• conditions: un array de condiciones compatibles con find() ó strings SQL como  
array(‘Profile.approved’ => true).

• fields: una lista de campos a ser recobrados cuando son extraídos los datos de
modelo asociados. Retorna todos los campos por defecto.

• order: un array de cláusulas de orden compatibles con find() ó strings SQL como
array(‘Profile.last_name’ => ‘ASC’).

• dependent: cuando se fija a true la clave dependent, y el método delete() del 
modelo es llamado con el parámetro cascade fijado a true, los registros de modelo
asociado también son borrados. En este caso, se lo fija a true tal que borrar
un User también borrará su Profile asociado.
 
Definida esta asociación, las operaciones de find en el modelo User también 
extraerá un registro relacionado a Profile si este existe:

//Sample results from a $this->User->find() call.
Array
(
  [User] => Array
  (
    [id] => 121
    [name] => Gwoo the Kungwoo
    [created] => 2007-05-01 10:31:01
  )
  [Profile] => Array
  (
    [id] => 12
    [user_id] => 121
    [skill] => Baking Cakes
    [created] => 2007-05-01 10:31:01
  )
)

belongsTo
.........
Ahora que se tiene el acceso a datos Profile desde el modelo User, se define una
asociación belongsTo en el modelo Profile para obtener acceso a los datos User
relacionados. La asociación belongsTo es un complemento natural a las asociaciones
hasOne y hasMany: nos permite ver los datos desde la otra dirección.

Cuando se hacen claves a sus tablas de DB para una relación belongsTo, seguir la
convención:

belongsTo: el modelo actual contiene la clave foránea.

-----------------------------------------------
| Relación                | Schema            |
-----------------------------------------------
| Banana belongsTo Apple  | bananas.apple_id  |
| Profile belongsTo User  | profiles.user_id  |
| Mentor belongsTo Doctor | mentors.doctor_id |
-----------------------------------------------

Consejo: Si un modelo (tabla) contiene una clave foránea, esta pertenece a
(belongsTo) otro modelo (tabla).

Podemos definir la asociación belongsTo en nuestro modelo Profile en 
/app/Model/Profile.php usando la sintaxis string como sigue:

class Profile extends AppModel {
  public $belongsTo = ’User’;
}

Podemos también definir una relación mas específica usando la sintaxis de array:

class Profile extends AppModel {
  public $belongsTo = array(
    ’User’ => array(
      ’className’ => ’User’,
      ’foreignKey’ => ’user_id’
    )
  );
}

Las claves posibles para arrays de asociación belongsTo incluyen:

• className: El nombre de clase del modelo siendo asociado al modelo actual.
Si uno está definiendo una relación 'Profile belongsTo User', la clave className
debería ser igual a 'User'.

• foreignKey: El nombre de la clave foránea hallada en modelo actual. Esto es útil
si uno necesita definir relaciones belongsTo múltiples. El valor por defecto para
esta clave está con '_', nombre único del otro modelo, con el sufijo '_id'. 

• conditions: Un array de condiciones compatible con find() or strings SQL como
array(’User.active’ => true)   

• type: El tipo del join a usar en la consulta SQL. El valor por defecto es ‘LEFT’.
El valor ‘INNER’ puede ser útil (cuando se usó con algunas condiciones) cuando
quiere todo de su parte principal y modelos asociados ó absolutamente nada.

• fields: Una lista de campos a ser recobrados cuando son extraídos los datos
de modelo asociados. Retorna todos los campos por defecto.
    
• order: un array de cláusulas de orden find() compatibles ó strings SQL como
array(’User.username’ => ’ASC’)

• counterCache: si se fija a true, el Modelo asociado incrementará ó decrementará
automáticamente el campo “[singular_model_name]_count” en la tabla foránea siempre
y cuando haga un save() ó delete(). Si este es un string, luego este es el nombre
de campo a usar. El valor en el campo counter representa el número de filas 
relacionadas. Uno puede también especificar cachés de conteo múltiples definiendo
un array. 

• counterScope: Array de condiciones opcional a usar para actualizar el campo
counter cache. Definida esta asociación, las operaciones de find en el modelo
Profile también extraerán un registro User relacionado si este existe:

//Sample results from a $this->Profile->find() call.
Array
  (
    [Profile] => Array
  (
    [id] => 12
    [user_id] => 121
    [skill] => Baking Cakes
    [created] => 2007-05-01 10:31:01
  )
    [User] => Array
  (
    [id] => 121
    [name] => Gwoo the Kungwoo
    [created] => 2007-05-01 10:31:01
  )
)

hasMany
.......
Próximo paso: definir una asociación “User hasMany Comment”. Una asociación hasMany
nos permitirá extraer comentarios de un usuario cuando extraemos un registro User.

Con las claves para tablas de DB para una relación hasMany, seguir la convención:

hasMany: el otro modelo contiene la clave foránea.

-------------------------------------------------
| Relation                | Schema              |
-------------------------------------------------
| User hasMany Comment    | Comment.user_id     |
| Cake hasMany Virtue     | Virtue.cake_id      |
| Product hasMany Option  |  Option.product_id  |
-------------------------------------------------

Podemos definir la asociación hasMany en nuestro modelo User en /app/Model/User.php
usando la sintaxis de string que sigue:

class User extends AppModel {
  public $hasMany = ’Comment’;
}

Podríamos también definir una relación mas específica usando sintaxis de array:

class User extends AppModel {
  public $hasMany = array(
    ’Comment’ => array(
      ’className’ => ’Comment’,
      ’foreignKey’ => ’user_id’,
      ’conditions’ => array(’Comment.status’ => ’1’),
      ’order’ => ’Comment.created DESC’,
      ’limit’ => ’5’,
      ’dependent’ => true
    )
  );
}

Las claves posibles para arrays de asociación hasMany incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. Si 
  uno está definiendo una relación ‘User hasMany Comment’, la clave className
  debería ser igual a ‘Comment’.
  
• foreignKey: el nombre de la clave foránea hallada en el otro modelo. Esto es 
  útil si necesita definir relaciones hasMany múltiples. El valor por defecto para
  esta clave es '_', nombre único del modelo actual, con el sufijo ‘_id’.

• conditions: un array de condiciones compatibles con find() ó strings SQL como
  array(‘Comment.visible’ => true).

• order: un array de cláusulas de orden compatibles con find() ó strings SQL como
  array(‘Profile.last_name’ => ‘ASC’).  

• limit: el número máximo de filas asociadas que uno quiere retornar.

• offset: el número de filas asociadas para saltear (dadas el orden y condiciones
  actuales) antes de extraer y asociar.

• dependent: cuando se setea a true, es posible el borrado de modelo recursivo.
  En este ej., los registros Comment serán borrados cuando su registro User 
  asociado ha sido borrado.

• exclusive: cuando se setea a true, el borrado de modelo recursivo hace el borrado
  con una llamada deleteAll(), en vez de borrar cada entidad separadamente. Esto
  mejora la performance.

• finderQuery: Una consulta SQL completa de CakePHP que se usa para extraer registros
  de modelo asociado. Si una consulta que uno construye requiere una referencia
  al ID de modelo asociado, usar el marcador especial {$__cakeID__$} en la
  consulta. Ej.: si su modelo Apple hasMany Orange, la consulta debería lucir como:
  SELECT Orange.* from oranges as Orange WHERE Orange.apple_id = {$__cakeID__$};    

Definida esta asociación, las operaciones find en el modelo User también extraerán
los registros Comment relacionados si existen:

//Sample results from a $this->User->find() call.
Array
(
  [User] => Array
    (
      [id] => 121
      [name] => Gwoo the Kungwoo
      [created] => 2007-05-01 10:31:01
    )
  [Comment] => Array
    (
      [0] => Array
        (
          [id] => 123
          [user_id] => 121
          [title] => On Gwoo the Kungwoo
          [body] => The Kungwooness is not so Gwooish
          [created] => 2006-05-01 10:31:01
        )
      [1] => Array
        (
          [id] => 124
          [user_id] => 121
          [title] => More on Gwoo
          [body] => But what of the ’ Nut?
          [created] => 2006-05-01 10:41:01
        )
    )
)

Necesita una asociación Comment belongsTo User complementaria para obtener los
datos desde ambas direcciones. Esto permite obtener datos Comment desde User.
Agregar la asociación Comment belongsTo User en el modelo Comment le habilita
a obtener datos User desde el modelo Comment, completando la conexión y permitiendo
el flujo de información desde ya sea la perspectiva del modelo.

counterCache - Cachear su count()
.................................
Esta función le ayuda a cachear el contenido de datos relacionados. En vez de 
contar los registros manualmente vía find(’count’), el modelo en sí mismo rastrea
cualquier agregado / borrado a través del modelo $hasMany asociado e incrementa / 
decrementa un campo entero dedicado dentro de la tabla modelo padre.

El nombre del campo consiste de un  nombre de modelo único seguido por un '_' y 
la palabra 'count':

my_model_count

Digamos que tiene un modelo llamado ImageComment y otro llamado Image. Debería
agregar un campo INT nuevo a la tabla 'images' y nombrarla 'image_comment_count'.  

Más ejemplos:

---------------------------------------------------------------------------
| Modelo    | Modelo Asociado     | Ejemplo                               |
---------------------------------------------------------------------------
| User      | Image               | users.image_count                     |
| Image     | ImageComment        | images.image_comment_count            |
| BlogEntry | BlogEntryComment    | blog_entries.blog_entry_comment_count |
---------------------------------------------------------------------------

Una vez que uno ha agregado el campo counter, activar counter-cache en su asociación
agregando una clave counterCache y fijar el valor a true:

class ImageComment extends AppModel {
  public $belongsTo = array(
    ’Image’ => array(
      ’counterCache’ => true,
    )
  );
}

Desde ahora, cada vez que uno agrega ó quita un ImageComment asociado a Image,
el número dentro de image_comment_count es ajustado automáticamente.

counterScope
............
Puede también especificar counterScope. Esto le permite especificar una 
condición simple que le dice al modelo cuando actualizar (ó cuando no, dependiendo
de como uno lo mire) el valor counter.

Usando nuestro ej. modelo Image, podemos especificarlo como:

class ImageComment extends AppModel {
  public $belongsTo = array(
    ’Image’ => array(
      ’counterCache’ => true,
      // only count if "ImageComment" is active = 1
      ’counterScope’ => array(
        ’ImageComment.active’ => 1
      )
    )
  );
}

counterCache múltiple
.....................
Desde 2.0, CakePHP ha soportado tener counterCache múltiple en una relación de
modelo única. Es también posible definir un counterScope para cada counterCache.
Asumiendo que uno tiene un modelo User y un modelo Message, y quiere ser capaz
de contar la cantidad de mensajes leídos y no leídos para cada usuario. 
 
---------------------------------------------------------------------------
| Modelo   | Campo                 | Descripción          |               |
---------------------------------------------------------------------------
| User    | users.messages_read   | Conteo de lectura de Message          |  
| User    | users.messages_unread | Conteo de no lectura de Message       |
| Message | messages.is_read      | Determina si un Message es leído ó no |
---------------------------------------------------------------------------

Con esta configuración, su belongsTo lucirá como:

class Message extends AppModel {
  public $belongsTo = array(
    ’User’ => array(
      ’counterCache’ => array(
        ’messages_read’ => array(’Message.is_read’ => 1),
        ’messages_unread’ => array(’Message.is_read’ => 0)
      )
    )
  );
}

hasAndBelongsToMany (HABTM)
...........................
Esta asociación se usa cuando tiene 2 modelos que necesitan unirse, repetidamente,
varias veces, de maneras diferentes. La principal diferencia entre hasMany y HABTM
es que un enlace entre modelos en HABTM no es exclusivo.

Ej., vamos a unir (join up) nuestro modelo Recipe con un modelo Ingredient usando
HABTM. Usar tomates como un Ingredient para la receta 'spaghettis de mamá'
no agota (use up) el ingrediente. Puede también usarse para un Recipe de ensalada.

Los enlaces entre objetos hasMany asociados son exclusivos. Si User hasMany Comments,
un comentario es sólo enlazado a un usuario específico.

Necesitaremos configurar una tabla extra en la DB para manejar asociaciones
HABTM. Este nuevo nombre de tabla a unir necesita incluir los nombres de ambos
modelos involucrados, en orden alfabético, y separados con un '_'. Los contenidos
de la tabla deberían ser 2 campos que son claves foráneas (que deberían ser
enteros) apuntando a las claves primarias de los modelos involucrados. Para evitar
problemas, no definir una clave primaria combinada para estos 2 campos. Si su
aplicación requiere un índice único, puede definir uno. Si planea agregar 
cualquier información extra a esta tabla, ó usar un modelo 'with', debería 
agregar un campo clave primaria adicional (por convención 'id').

HABTM requiere una tabla de join que incluye ambos nombres de modelo.

-------------------------------------------------------------------------------
| Relación        | Campos de Tabla HABTM                                     |
-------------------------------------------------------------------------------
| Recipe HABTM    | ingredients_recipes.id, ingredients_recipes.ingredient_id,|
| Ingredient      | ingredients_recipes.recipe_id                             |
| Cake HABTM Fan  | cakes_fans.id, cakes_fans.cake_id, cakes_fans.fan_id      |
| Foo HABTM Bar   | bars_foos.id, bars_foos.foo_id, bars_foos.bar_id          |
-------------------------------------------------------------------------------

Nota: Los nombres de tabla están en orden alfabético por convención. Es posible
definir un nombre de tabla personalizado en la definición de asociación.

Asegurarse que las claves primarias en tablas cakes y recipes tengan campos 'id'
como se asumieron por convención. Si estos son diferentes que los asumidos, 
deben ser cambiados en la primaryKey del modelo.

Una vez que se ha creado esta tabla nueva, podemos definir la asociación HABTM
en los archivos modelo. En la sintaxis de array:

class Recipe extends AppModel {
  public $hasAndBelongsToMany = array(
    ’Ingredient’ =>
    array(
      ’className’ => ’Ingredient’,
      ’joinTable’ => ’ingredients_recipes’,
      ’foreignKey’ => ’recipe_id’,
      ’associationForeignKey’ => ’ingredient_id’,
      ’unique’ => true,
      ’conditions’ => ’’,
      ’fields’ => ’’,
      ’order’ => ’’,
      ’limit’ => ’’,
      ’offset’ => ’’,
      ’finderQuery’ => ’’,
      ’with’ => ’’
    )
  );
}

Posibles claves para los arrays de asociación HABTM incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. 
  Si está definiendo una relación 'Recipe HABTM Ingredient', la clave className
  debería ser igual a 'Ingredient'
   
• joinTable: el nombre de la tabla join usada en esta asociación (si la tabla
  actual no se adhiere a la convención de nombramiento para tablas join HABTM)

• with: define el nombre del modelo para la tabla join. Por defecto CakePHP 
  auto creará un modelo por uno. Usar el ej. sobre esto se llamaría IngredientsRecipe.
  Usando esta clave puede redefinir este nombre por defecto. El modelo de join
  de tabla puede usarse como cualquier modelo 'regular' para acceder a la tabla
  de join directamente. Creando una clase modelo con tal nombre y nombre de archivo,
  puede agregar cualquier comportamiento personalizado a las búsquedas de join 
  de tabla, tal como agregar mas información / columnas a esta

• foreignKey: el nombre de la clave foranea hallada en el modelo actual. Esto es 
  útil si necesita definir múltiples relaciones HABTM. El valor por defecto para
  esta clave es '_', nombre único del modelo actual, con el sufijo '_id'

• associationForeignKey: el nombre de la clave foránea hallada en el otro modelo.
  Útil si necesita definir múltiples relaciones HABTM. El valor por defecto para
  esta clave es '_', nombre único del otro modelo, con el sufijo '_id'       

• unique: boolean ó string keepExisting.

  – Si es true (valor por defecto) cake primero borrará los registros de relación
    existentes en la tabla de claves foráneas antes de insertar nuevas. Las
    asociaciones existentes necesitan pasarse de nuevo cuando se actualizan

  - Si es false, cake insertará el registro de relación, y así no se borran 
    registros de join durante una operación de guardado
  
  - Cuando se fija a keepExisting, este comportamiento es similar a true, pero
    las asociaciones existentes no son borradas

• conditions: un array de condiciones compatibles con find() ó string SQL. Si uno
  tiene condiciones sobre una tabla asociada, debería usar un modelo 'with', y
  definir las asociaciones belongsTo necesarias sobre esta

• fields: una lista de campos a ser recobrados cuando son extraidos los datos del
  modelo asociado. Retorna todos los campos por defecto

• order: un array de cláusulas de orden compatibles con find() ó strings SQL

• limit: el número máximo de filas asociadas que quiere retornar

• offset: el número de filas asociadas a saltarse (skip over) (dadas condiciones
  actuales y orden) antes de extraer y asociar

• finderQuery: una consulta SQL completa que CakePHP puede usar para extraer
  registros de modelo. Debería usarse en situaciones que requieren resultados
  altamente personalizados

Una vez que esta asociación ha sido definida, las operaciones de find en el 
modelo Recipe también extraerán registros relacionados a Tag si estos existen:

// Sample results from a $this->Recipe->find() call.
Array
(
  [Recipe] => Array
    (
      [id] => 2745
      [name] => Chocolate Frosted Sugar Bombs
      [created] => 2007-05-01 10:31:01
      [user_id] => 2346
    )
  [Ingredient] => Array
    (
      [0] => Array
        (
          [id] => 123
          [name] => Chocolate
        )
      [1] => Array
        (
          [id] => 124
          [name] => Sugar
        )
      [2] => Array
        (
          [id] => 125
          [name] => Bombs
        )
    )
)

Recordar definir una asociación HABTM en el modelo Ingredient si uno quiere
recobrar datos Recipe al usar el modelo Ingredient.

Nota: los datos HABTM son tratados como un set completo. Cada vez que es agregada
una nueva asociación de datos, el set de filas asociadas completa en la DB
es borrada (dropped) y recreada así uno siempre necesitará pasar el set de 
datos completo para almacenamiento. 

hasMany through (Modelo Join)
.............................

(219)