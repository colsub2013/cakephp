MODELOS
=======
Las clases del modelo pueden usarse para acceder a:

. Tablas de base de datos
. Archivos
. Web Services externos
. Eventos iCal

Un modelo puede asociarse con otros. Ej.: un Recipe puede asociarse con un Author
como también un Ingredient.

Entender Modelos
----------------
Un modelo representa modelo de datos. 

Ej. de definición de modelo en CakePHP:

App::uses(’AppModel’, ’Model’);
class Ingredient extends AppModel {
  public $name = ’Ingredient’;
}

Con sólo una declaración, el modelo Ingredient es dotado con toda la funcionalidad
que necesita para crear consultas y almacenar y borrar datos. Estos métodos vienen
de la clase Modelo de CakePHP por herencia. El modelo Ingredient extiende 
el modelo de aplicación, AppModel, que a su vez extiende la clase Model interna
de CakePHP. 

Es esta clase Model núcleo que otorga la funcionalidad en su modelo Ingredient.
App::uses(’AppModel’, ’Model’) asegura que el modelo es cargado cuando se
necesite.

La clase intermedia, AppModel, está vacía. Si no la ha creado, se tomará de la
carpeta núcleo de CakePHP. Redefinir el AppModel le permite definir funcionalidad
que debería estar disponible a todos los modelos dentro de su aplicación. Para
hacerlo, necesita crear su propio archivo AppModel.php que reside en la carpeta
Model, como lo hace con todos los otros modelos de su aplicación. Crear un proyecto
usando Bake generará automáticamente este archivo por uno.

De vuelta en el modelo Ingredient, crear el archivo PHP en el directorio /app/Model/.
Por convención, este debería tener el mismo nombre que la clase, que para este ej.
es Ingredient.php.

Nota: CakePHP creará dinámicamente un objeto modelo para uno si este no puede 
hallar un archivo correspondiente en /app/Model. Esto significa que si su 
archivo modelo no se nombra correctamente (ej., se nombra ingredient.php ó 
Ingredients.php en vez de Ingredient.php), CakePHP usará una instancia de AppModel
en vez de su archivo modelo (que CakePHP asume perdido). Si uno intenta usar 
un método que ha definido en su modelo, ó un comportamiento unido a su modelo,
y uno está obteniendo errores SQL que que son el nombre del método que uno está
llamando, es una señal segura que CakePHP no puede hallar su modelo y necesita
chequear los nombres de archivo, su caché de aplicación, ó ambos.

Nota: Algunos nombres de clase no son útiles para nombres de modelo. Ej.: 'File'
no puede usarse, ya que 'File' es una clase que ya existe en el núcleo CakePHP.

Definido su modelo, este puede ser accedido desde dentro de su Controller. CakePHP
hará al modelo disponible automáticamente para acceso cuando su nombre coincida
con el del controlador. Ej.: un controlador llamado IngredientsController inicializará
automáticamente el modelo Ingredient y lo anexará al controlador en $this->Ingredient:

class IngredientsController extends AppController {
  public function index() {
    //grab all ingredients and pass it to the view:
    $ingredients = $this->Ingredient->find(’all’);
    $this->set(’ingredients’, $ingredients);
  }
}

Los modelos asociados están disponibles a través del modelo principal. En el 
siguiente ej., Recipe tiene una asociación con el modelo Ingredient:

class Recipe extends AppModel {
  public function steakRecipes() {
    $ingredient = $this->Ingredient->findByName(’Steak’);
    return $this->findAllByMainIngredient($ingredient[’Ingredient’][’id’]);
  }
}

Este muestra como usar modelos que ya están enlazados (linked).

Más sobre modelos
-----------------

Asociaciones: Enlazar modelos
-----------------------------
En CakePHP, los enlaces entre modelos son manejados a través de asociaciones.

Definir relaciones entre objetos diferentes en su aplicación debería ser un 
proceso natural. Ej.: en una DB recipe (receta), una receta puede tener varias
reseñas (reviews), las reseñas pueden tener un único autor, y los autores pueden
tener varias recetas.

Relationship Types
..................
Los 4 tipos de asociación en CakePHP son: hasOne, hasMany, belongsTo, y hasAndBelongsToMany
(HABTM).

---------------------------------------------------------------------------------------------------
| Relación       | Tipo de asociación  | Ejemplo                                                  |
---------------------------------------------------------------------------------------------------
| one to one     | hasOne              | Un usuario tiene un único perfil.                        |
| one to many    | hasMany             | Un usuario puede tener múltiples recetas.                |
| many to one    | belongsTo           | Muchas recetas pueden pertenecer a un usuario.           |
| many to many   | hasAndBelongsToMany | Las recetas tienen, y pertenecen a varios ingredientes.  |
---------------------------------------------------------------------------------------------------

Las asociaciones son definidas creando una variable de clase nombrada después de la 
asociación que uno está definiendo. La variable de clase puede ser tanto un
string como un array multidimensional usado para definir cosas específicas de 
asociación.

class User extends AppModel {
  public $hasOne = ’Profile’;
  public $hasMany = array(
    ’Recipe’ => array(
      ’className’ => ’Recipe’,
      ’conditions’ => array(’Recipe.approved’ => ’1’),
      ’order’ => ’Recipe.created DESC’
    )
  );
}

En el ej. de arriba, la 1ra instancia de la palabra 'Recipe' es lo que se denomina
un 'Alias'. Este es un identificador para la relación, y puede ser cualquiera que
elija. Usualmente, uno eligirá el mismo nombre que la clase que este referencia.
Pero, los alias para cada modelo deben ser únicos a través de la aplicación. 
Ej.: es apropiado tener:

class User extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’MemberOf’ => array(
      ’className’ => ’Group’,
    )
  );
  
}

class Group extends AppModel {
  
  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’User’,
    )
  );
}

pero lo siguiente no funcionará bien en todas las circunstancias:

class User extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’Group’,
    )
  );

}

class Group extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’User’,
    )
  );

}

debido a que aquí tenemos el alias 'Member' que se refiere a ambos User (en Group)
y el modelo Group (en User) en las asociaciones HABTM. Elegir nombres no únicos
para alias de modelo a través de modelos pueden originar un comportamiento
inesperado. 

CakePHP creará automáticamente enlaces entre los objetos modelo asociados. Ej.: 
en su modelo User uno puede acceder al modelo Recipe como:

$this->Recipe->someFunction();

Similarmente en su controlador uno puede acceder a un modelo asociado simplemente
siguiendo sus asociaciones de modelo:

$this->User->Recipe->someFunction();

Nota: las asociaciones son definidas en 'un sentido'. Si define User hasMany Recipe,
esto no tiene efecto en el Modelo Recipe. Necesita definir Recipe belongsTo User 
para ser capaz de acceder al modelo User desde su modelo Recipe.

hasOne
......
Se va a configurar un modelo User con una relación hasOne para un modelo Profile.

Primero, sus tablas en la DB necesitan tener las claves correctamente. Para que 
funcione una relación hasOne, una tabla tiene que contener una clave foránea
que apunta a un registro en la otra. En este caso, la tabla profiles contendrá
un campo llamado user_id. El patrón básico:

hasOne: el otro modelo contiene la clave foránea.
°°°°°°
---------------------------------------------
| Relación              | Esquema           | 
---------------------------------------------
| Apple hasOne Banana   | bananas.apple_id  |
| User hasOne Profile   | profiles.user_id  |
| Doctor hasOne Mentor  | mentors.doctor_id |
---------------------------------------------

Nota: no es obligatorio seguir las convenciones CakePHP. Puede redefinir el uso
de cualquier clave foránea en sus definiciones de asociaciones.

El archivo modelo User será almacenado en /app/Model/User.php. Para definir la 
asociación ‘User hasOne Profile’, agregar la propiedad $hasOne a la clase modelo.
Recordar tener un modelo Profile en /app/Model/Profile.php, ó la asociación no
funcionará: 
 
class User extends AppModel {
  public $hasOne = ’Profile’;
}

Hay 2 modos de describir esta relación en sus archivos modelo. El método más
simple es fijar el atributo $hasOne a un string que contiene el nombre de clase
del modelo asociado, como se ha hecho arriba.

Si necesita más control, puede definir sus asociaciones usando sintaxis de array.
Ej.: puede querer limitar la asociación para incluir sólo ciertos registros.

class User extends AppModel {
  public $hasOne = array(
    ’Profile’ => array(
      ’className’ => ’Profile’,
      ’conditions’ => array(’Profile.published’ => ’1’),
      ’dependent’ => true
    )
  );
}

Las claves posibles para los arrays de asociación hasOne incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. Si 
uno está definiendo una relación ‘User hasOne Profile’, la clave className sería
igual a ‘Profile’. 

• foreignKey: el nombre de la clave foránea hallada en el otro modelo. Esto es
útil si necesita definir relaciones hasOne múltiples. El valor por defecto para 
esta clave es el '_', el nombre único del modelo actual, con sufijo ‘_id’. En el
ej. de arriba, este sería por defecto ‘user_id’.

• conditions: un array de condiciones compatibles con find() ó strings SQL como  
array(‘Profile.approved’ => true).

• fields: una lista de campos a ser recobrados cuando son extraídos los datos de
modelo asociados. Retorna todos los campos por defecto.

• order: un array de cláusulas de orden compatibles con find() ó strings SQL como
array(‘Profile.last_name’ => ‘ASC’).

• dependent: cuando se fija a true la clave dependent, y el método delete() del 
modelo es llamado con el parámetro cascade fijado a true, los registros de modelo
asociado también son borrados. En este caso, se lo fija a true tal que borrar
un User también borrará su Profile asociado.
 
Definida esta asociación, las operaciones de find en el modelo User también 
extraerá un registro relacionado a Profile si este existe:

//Sample results from a $this->User->find() call.
Array
(
  [User] => Array
  (
    [id] => 121
    [name] => Gwoo the Kungwoo
    [created] => 2007-05-01 10:31:01
  )
  [Profile] => Array
  (
    [id] => 12
    [user_id] => 121
    [skill] => Baking Cakes
    [created] => 2007-05-01 10:31:01
  )
)

belongsTo
.........
Ahora que se tiene el acceso a datos Profile desde el modelo User, se define una
asociación belongsTo en el modelo Profile para obtener acceso a los datos User
relacionados. La asociación belongsTo es un complemento natural a las asociaciones
hasOne y hasMany: nos permite ver los datos desde la otra dirección.

Cuando se hacen claves a sus tablas de DB para una relación belongsTo, seguir la
convención:

belongsTo: el modelo actual contiene la clave foránea.

-----------------------------------------------
| Relación                | Schema            |
-----------------------------------------------
| Banana belongsTo Apple  | bananas.apple_id  |
| Profile belongsTo User  | profiles.user_id  |
| Mentor belongsTo Doctor | mentors.doctor_id |
-----------------------------------------------

Consejo: Si un modelo (tabla) contiene una clave foránea, esta pertenece a
(belongsTo) otro modelo (tabla).

Podemos definir la asociación belongsTo en nuestro modelo Profile en 
/app/Model/Profile.php usando la sintaxis string como sigue:

class Profile extends AppModel {
  public $belongsTo = ’User’;
}

Podemos también definir una relación mas específica usando la sintaxis de array:

class Profile extends AppModel {
  public $belongsTo = array(
    ’User’ => array(
      ’className’ => ’User’,
      ’foreignKey’ => ’user_id’
    )
  );
}

Las claves posibles para arrays de asociación belongsTo incluyen:

• className: El nombre de clase del modelo siendo asociado al modelo actual.
Si uno está definiendo una relación 'Profile belongsTo User', la clave className
debería ser igual a 'User'.

• foreignKey: El nombre de la clave foránea hallada en modelo actual. Esto es útil
si uno necesita definir relaciones belongsTo múltiples. El valor por defecto para
esta clave está con '_', nombre único del otro modelo, con el sufijo '_id'. 

• conditions: Un array de condiciones compatible con find() or strings SQL como
array(’User.active’ => true)   

• type: El tipo del join a usar en la consulta SQL. El valor por defecto es ‘LEFT’.
El valor ‘INNER’ puede ser útil (cuando se usó con algunas condiciones) cuando
quiere todo de su parte principal y modelos asociados ó absolutamente nada.

• fields: Una lista de campos a ser recobrados cuando son extraídos los datos
de modelo asociados. Retorna todos los campos por defecto.
    
• order: un array de cláusulas de orden find() compatibles ó strings SQL como
array(’User.username’ => ’ASC’)

• counterCache: si se fija a true, el Modelo asociado incrementará ó decrementará
automáticamente el campo “[singular_model_name]_count” en la tabla foránea siempre
y cuando haga un save() ó delete(). Si este es un string, luego este es el nombre
de campo a usar. El valor en el campo counter representa el número de filas 
relacionadas. Uno puede también especificar cachés de conteo múltiples definiendo
un array. 

• counterScope: Array de condiciones opcional a usar para actualizar el campo
counter cache. Definida esta asociación, las operaciones de find en el modelo
Profile también extraerán un registro User relacionado si este existe:

//Sample results from a $this->Profile->find() call.
Array
  (
    [Profile] => Array
  (
    [id] => 12
    [user_id] => 121
    [skill] => Baking Cakes
    [created] => 2007-05-01 10:31:01
  )
    [User] => Array
  (
    [id] => 121
    [name] => Gwoo the Kungwoo
    [created] => 2007-05-01 10:31:01
  )
)

hasMany
.......
Próximo paso: definir una asociación “User hasMany Comment”. Una asociación hasMany
nos permitirá extraer comentarios de un usuario cuando extraemos un registro User.

Con las claves para tablas de DB para una relación hasMany, seguir la convención:

hasMany: el otro modelo contiene la clave foránea.

-------------------------------------------------
| Relation                | Schema              |
-------------------------------------------------
| User hasMany Comment    | Comment.user_id     |
| Cake hasMany Virtue     | Virtue.cake_id      |
| Product hasMany Option  |  Option.product_id  |
-------------------------------------------------

Podemos definir la asociación hasMany en nuestro modelo User en /app/Model/User.php
usando la sintaxis de string que sigue:

class User extends AppModel {
  public $hasMany = ’Comment’;
}

Podríamos también definir una relación mas específica usando sintaxis de array:

class User extends AppModel {
  public $hasMany = array(
    ’Comment’ => array(
      ’className’ => ’Comment’,
      ’foreignKey’ => ’user_id’,
      ’conditions’ => array(’Comment.status’ => ’1’),
      ’order’ => ’Comment.created DESC’,
      ’limit’ => ’5’,
      ’dependent’ => true
    )
  );
}

Las claves posibles para arrays de asociación hasMany incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. Si 
  uno está definiendo una relación ‘User hasMany Comment’, la clave className
  debería ser igual a ‘Comment’.
  
• foreignKey: el nombre de la clave foránea hallada en el otro modelo. Esto es 
  útil si necesita definir relaciones hasMany múltiples. El valor por defecto para
  esta clave es '_', nombre único del modelo actual, con el sufijo ‘_id’.

• conditions: un array de condiciones compatibles con find() ó strings SQL como
  array(‘Comment.visible’ => true).

• order: un array de cláusulas de orden compatibles con find() ó strings SQL como
  array(‘Profile.last_name’ => ‘ASC’).  

• limit: el número máximo de filas asociadas que uno quiere retornar.

• offset: el número de filas asociadas para saltear (dadas el orden y condiciones
  actuales) antes de extraer y asociar.

• dependent: cuando se setea a true, es posible el borrado de modelo recursivo.
  En este ej., los registros Comment serán borrados cuando su registro User 
  asociado ha sido borrado.

• exclusive: cuando se setea a true, el borrado de modelo recursivo hace el borrado
  con una llamada deleteAll(), en vez de borrar cada entidad separadamente. Esto
  mejora la performance.

• finderQuery: Una consulta SQL completa de CakePHP que se usa para extraer registros
  de modelo asociado. Si una consulta que uno construye requiere una referencia
  al ID de modelo asociado, usar el marcador especial {$__cakeID__$} en la
  consulta. Ej.: si su modelo Apple hasMany Orange, la consulta debería lucir como:
  SELECT Orange.* from oranges as Orange WHERE Orange.apple_id = {$__cakeID__$};    

Definida esta asociación, las operaciones find en el modelo User también extraerán
los registros Comment relacionados si existen:

//Sample results from a $this->User->find() call.
Array
(
  [User] => Array
    (
      [id] => 121
      [name] => Gwoo the Kungwoo
      [created] => 2007-05-01 10:31:01
    )
  [Comment] => Array
    (
      [0] => Array
        (
          [id] => 123
          [user_id] => 121
          [title] => On Gwoo the Kungwoo
          [body] => The Kungwooness is not so Gwooish
          [created] => 2006-05-01 10:31:01
        )
      [1] => Array
        (
          [id] => 124
          [user_id] => 121
          [title] => More on Gwoo
          [body] => But what of the ’ Nut?
          [created] => 2006-05-01 10:41:01
        )
    )
)

Necesita una asociación Comment belongsTo User complementaria para obtener los
datos desde ambas direcciones. Esto permite obtener datos Comment desde User.
Agregar la asociación Comment belongsTo User en el modelo Comment le habilita
a obtener datos User desde el modelo Comment, completando la conexión y permitiendo
el flujo de información desde ya sea la perspectiva del modelo.

counterCache - Cachear su count()
.................................
Esta función le ayuda a cachear el contenido de datos relacionados. En vez de 
contar los registros manualmente vía find(’count’), el modelo en sí mismo rastrea
cualquier agregado / borrado a través del modelo $hasMany asociado e incrementa / 
decrementa un campo entero dedicado dentro de la tabla modelo padre.

El nombre del campo consiste de un  nombre de modelo único seguido por un '_' y 
la palabra 'count':

my_model_count

Digamos que tiene un modelo llamado ImageComment y otro llamado Image. Debería
agregar un campo INT nuevo a la tabla 'images' y nombrarla 'image_comment_count'.  

Más ejemplos:

---------------------------------------------------------------------------
| Modelo    | Modelo Asociado     | Ejemplo                               |
---------------------------------------------------------------------------
| User      | Image               | users.image_count                     |
| Image     | ImageComment        | images.image_comment_count            |
| BlogEntry | BlogEntryComment    | blog_entries.blog_entry_comment_count |
---------------------------------------------------------------------------

Una vez que uno ha agregado el campo counter, activar counter-cache en su asociación
agregando una clave counterCache y fijar el valor a true:

class ImageComment extends AppModel {
  public $belongsTo = array(
    ’Image’ => array(
      ’counterCache’ => true,
    )
  );
}

Desde ahora, cada vez que uno agrega ó quita un ImageComment asociado a Image,
el número dentro de image_comment_count es ajustado automáticamente.

counterScope
............
Puede también especificar counterScope. Esto le permite especificar una 
condición simple que le dice al modelo cuando actualizar (ó cuando no, dependiendo
de como uno lo mire) el valor counter.

Usando nuestro ej. modelo Image, podemos especificarlo como:

class ImageComment extends AppModel {
  public $belongsTo = array(
    ’Image’ => array(
      ’counterCache’ => true,
      // only count if "ImageComment" is active = 1
      ’counterScope’ => array(
        ’ImageComment.active’ => 1
      )
    )
  );
}

counterCache múltiple
.....................
Desde 2.0, CakePHP ha soportado tener counterCache múltiple en una relación de
modelo única. Es también posible definir un counterScope para cada counterCache.
Asumiendo que uno tiene un modelo User y un modelo Message, y quiere ser capaz
de contar la cantidad de mensajes leídos y no leídos para cada usuario. 
 
---------------------------------------------------------------------------
| Modelo   | Campo                 | Descripción          |               |
---------------------------------------------------------------------------
| User    | users.messages_read   | Conteo de lectura de Message          |  
| User    | users.messages_unread | Conteo de no lectura de Message       |
| Message | messages.is_read      | Determina si un Message es leído ó no |
---------------------------------------------------------------------------

Con esta configuración, su belongsTo lucirá como:

class Message extends AppModel {
  public $belongsTo = array(
    ’User’ => array(
      ’counterCache’ => array(
        ’messages_read’ => array(’Message.is_read’ => 1),
        ’messages_unread’ => array(’Message.is_read’ => 0)
      )
    )
  );
}

hasAndBelongsToMany (HABTM)
...........................
Esta asociación se usa cuando tiene 2 modelos que necesitan unirse, repetidamente,
varias veces, de maneras diferentes. La principal diferencia entre hasMany y HABTM
es que un enlace entre modelos en HABTM no es exclusivo.

Ej., vamos a unir (join up) nuestro modelo Recipe con un modelo Ingredient usando
HABTM. Usar tomates como un Ingredient para la receta 'spaghettis de mamá'
no agota (use up) el ingrediente. Puede también usarse para un Recipe de ensalada.

Los enlaces entre objetos hasMany asociados son exclusivos. Si User hasMany Comments,
un comentario es sólo enlazado a un usuario específico.

Necesitaremos configurar una tabla extra en la DB para manejar asociaciones
HABTM. Este nuevo nombre de tabla a unir necesita incluir los nombres de ambos
modelos involucrados, en orden alfabético, y separados con un '_'. Los contenidos
de la tabla deberían ser 2 campos que son claves foráneas (que deberían ser
enteros) apuntando a las claves primarias de los modelos involucrados. Para evitar
problemas, no definir una clave primaria combinada para estos 2 campos. Si su
aplicación requiere un índice único, puede definir uno. Si planea agregar 
cualquier información extra a esta tabla, ó usar un modelo 'with', debería 
agregar un campo clave primaria adicional (por convención 'id').

HABTM requiere una tabla de join que incluye ambos nombres de modelo.

-------------------------------------------------------------------------------
| Relación        | Campos de Tabla HABTM                                     |
-------------------------------------------------------------------------------
| Recipe HABTM    | ingredients_recipes.id, ingredients_recipes.ingredient_id,|
| Ingredient      | ingredients_recipes.recipe_id                             |
| Cake HABTM Fan  | cakes_fans.id, cakes_fans.cake_id, cakes_fans.fan_id      |
| Foo HABTM Bar   | bars_foos.id, bars_foos.foo_id, bars_foos.bar_id          |
-------------------------------------------------------------------------------

Nota: Los nombres de tabla están en orden alfabético por convención. Es posible
definir un nombre de tabla personalizado en la definición de asociación.

Asegurarse que las claves primarias en tablas cakes y recipes tengan campos 'id'
como se asumieron por convención. Si estos son diferentes que los asumidos, 
deben ser cambiados en la primaryKey del modelo.

Una vez que se ha creado esta tabla nueva, podemos definir la asociación HABTM
en los archivos modelo. En la sintaxis de array:

class Recipe extends AppModel {
  public $hasAndBelongsToMany = array(
    ’Ingredient’ =>
    array(
      ’className’ => ’Ingredient’,
      ’joinTable’ => ’ingredients_recipes’,
      ’foreignKey’ => ’recipe_id’,
      ’associationForeignKey’ => ’ingredient_id’,
      ’unique’ => true,
      ’conditions’ => ’’,
      ’fields’ => ’’,
      ’order’ => ’’,
      ’limit’ => ’’,
      ’offset’ => ’’,
      ’finderQuery’ => ’’,
      ’with’ => ’’
    )
  );
}

Posibles claves para los arrays de asociación HABTM incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. 
  Si está definiendo una relación 'Recipe HABTM Ingredient', la clave className
  debería ser igual a 'Ingredient'
   
• joinTable: el nombre de la tabla join usada en esta asociación (si la tabla
  actual no se adhiere a la convención de nombramiento para tablas join HABTM)

• with: define el nombre del modelo para la tabla join. Por defecto CakePHP 
  auto creará un modelo por uno. Usar el ej. sobre esto se llamaría IngredientsRecipe.
  Usando esta clave puede redefinir este nombre por defecto. El modelo de join
  de tabla puede usarse como cualquier modelo 'regular' para acceder a la tabla
  de join directamente. Creando una clase modelo con tal nombre y nombre de archivo,
  puede agregar cualquier comportamiento personalizado a las búsquedas de join 
  de tabla, tal como agregar mas información / columnas a esta

• foreignKey: el nombre de la clave foranea hallada en el modelo actual. Esto es 
  útil si necesita definir múltiples relaciones HABTM. El valor por defecto para
  esta clave es '_', nombre único del modelo actual, con el sufijo '_id'

• associationForeignKey: el nombre de la clave foránea hallada en el otro modelo.
  Útil si necesita definir múltiples relaciones HABTM. El valor por defecto para
  esta clave es '_', nombre único del otro modelo, con el sufijo '_id'       

• unique: boolean ó string keepExisting.

  – Si es true (valor por defecto) cake primero borrará los registros de relación
    existentes en la tabla de claves foráneas antes de insertar nuevas. Las
    asociaciones existentes necesitan pasarse de nuevo cuando se actualizan

  - Si es false, cake insertará el registro de relación, y así no se borran 
    registros de join durante una operación de guardado
  
  - Cuando se fija a keepExisting, este comportamiento es similar a true, pero
    las asociaciones existentes no son borradas

• conditions: un array de condiciones compatibles con find() ó string SQL. Si uno
  tiene condiciones sobre una tabla asociada, debería usar un modelo 'with', y
  definir las asociaciones belongsTo necesarias sobre esta

• fields: una lista de campos a ser recobrados cuando son extraidos los datos del
  modelo asociado. Retorna todos los campos por defecto

• order: un array de cláusulas de orden compatibles con find() ó strings SQL

• limit: el número máximo de filas asociadas que quiere retornar

• offset: el número de filas asociadas a saltarse (skip over) (dadas condiciones
  actuales y orden) antes de extraer y asociar

• finderQuery: una consulta SQL completa que CakePHP puede usar para extraer
  registros de modelo. Debería usarse en situaciones que requieren resultados
  altamente personalizados

Una vez que esta asociación ha sido definida, las operaciones de find en el 
modelo Recipe también extraerán registros relacionados a Tag si estos existen:

// Sample results from a $this->Recipe->find() call.
Array
(
  [Recipe] => Array
    (
      [id] => 2745
      [name] => Chocolate Frosted Sugar Bombs
      [created] => 2007-05-01 10:31:01
      [user_id] => 2346
    )
  [Ingredient] => Array
    (
      [0] => Array
        (
          [id] => 123
          [name] => Chocolate
        )
      [1] => Array
        (
          [id] => 124
          [name] => Sugar
        )
      [2] => Array
        (
          [id] => 125
          [name] => Bombs
        )
    )
)

Recordar definir una asociación HABTM en el modelo Ingredient si uno quiere
recobrar datos Recipe al usar el modelo Ingredient.

Nota: los datos HABTM son tratados como un set completo. Cada vez que es agregada
una nueva asociación de datos, el set de filas asociadas completa en la DB
es borrada (dropped) y recreada así uno siempre necesitará pasar el set de 
datos completo para almacenamiento. 

hasMany through (Modelo Join)
.............................
A veces es deseable almacenar datos adicionales con asociación many-to-many. 
Considerar lo siguiente:

Student hasAndBelongsToMany Course
Course hasAndBelongsToMany Student

Un Student puede tomar varios Courses y un Course puede ser tomado por varios 
Students. Esta es una asociación many-to-many simple que demanda una tabla como

id | student_id | course_id

Que tal si queremos almacenar el número de días que fueron atendidos por el 
estudiante en el curso y su calificación final? La tabla que querríamos:

id | student_id | course_id | days_attended | grade

El problema es, hasAndBelongsToMany no soportará este tipo de escenario ya que
cuando las asociaciones hasAndBelongsToMany son almacenadas, la asociación es
borrada primero. Uno perdería datos extra en las columnas ya que este no es 
reemplazado en el nuevo insert.

Cambiado en v.2.1.

Puede fijar el único ajusta para keepExisting para burlar la pérdida de datos
extra durante la operación de guardado. 

La manera de implementar nuestro requerimiento es usar un modelo join, de otro
modo conocido como un hasMany a través de la asociación. La asociación es un 
modelo en sí mismo. Así, podemos crear un modelo nuevo CourseMembership. Mirar
el siguiente modelo:

// Student.php
class Student extends AppModel {
  public $hasMany = array(
    ’CourseMembership’
  );
}

// Course.php
class Course extends AppModel {
  public $hasMany = array(
    ’CourseMembership’
  );
}

// CourseMembership.php
class CourseMembership extends AppModel {
  public $belongsTo = array(
    ’Student’, ’Course’
  );
}

El modelo join de CourseMembership identifica de forma única una participación de
Student dado en un Course en adición a meta-información extra.

Los modelos join contienen asociaciones hasMany y belongsTo y la característica
saveAll.

Crear y Destruir Asociaciones al vuelo
--------------------------------------
A veces es necesario crear y destruir asociaciones de modelo al vuelo. Esto puede
ser por:

• Quiere reducir la cantidad de datos asociados extraídos, pero todas sus asociaciones
están en el 1er nivel de recursión

• Quiere cambiar el modo que una asociación está definida tal manera de ordenar
(sort) ó filtrar datos asociados

Esta creación y destrucción de asociación es hecha usando el modelo de CakePHP
métodos bindModel() y unbindModel(). Se van a configurar algunos modelos tal que
podamos ver como funcionan bindModel() y unbindModel(). Arrancaremos con 2 
modelos:

class Leader extends AppModel {
  public $hasMany = array(
    ’Follower’ => array(
      ’className’ => ’Follower’,
      ’order’ => ’Follower.rank’
    )
  );
}

class Follower extends AppModel {
  public $name = ’Follower’;
}

Ahora, en el LeadersController, podemos usar el método find() en el modelo 
Leader para extraer un Leader y sus seguidores asociados. El array de asociación
en el modelo Leader define una relación 'Leader hasMany Followers'. Para 
propósitos de demostración, usar unbindModel() para quitar esa asociación en una
acción controlador:
  
public function some_action() {
  // This fetches Leaders, and their associated Followers
  $this->Leader->find(’all’);
  // Let’s remove the hasMany...
  $this->Leader->unbindModel(
    array(’hasMany’ => array(’Follower’))
  );

  // Now using a find function will return
  // Leaders, with no Followers
  $this->Leader->find(’all’);
  // NOTE: unbindModel only affects the very next
  // find function. An additional find call will use
  // the configured association information.
  // We’ve already used find(’all’) after unbindModel(),
  // so this will fetch Leaders with associated
  // Followers once again...
  $this->Leader->find(’all’);
}

Nota: quitar ó agregar asociaciones usando bind- y unbindModel() sólo funciona
para la siguiente operación find a menos que el 2do parámetro haya sido fijado
a false, en cuyo caso el bind permanece en su lugar para el resto del request.

Patrón de uso básico para unbindModel():

$this->Model->unbindModel(
  array(’associationType’ => array(’associatedModelClassName’))
);

Removida exitosamente una asociación al vuelo, se va agregar una. Nuestro Leader
necesita algunos Principles (principios) asociados. El archivo modelo para
nuestro modelo Principle es simple, excepto por la sentencia public $name. Vamos
a asociar algunos Principles a nuestro Leader al vuelo (sólo para la siguiente
operación de find). Esta función aparece en el LeadersController:
 
public function another_action() {
  // There is no Leader hasMany Principles in
  // the leader.php model file, so a find here
  // only fetches Leaders.
  $this->Leader->find(’all’);
  // Let’s use bindModel() to add a new association
  // to the Leader model:
  $this->Leader->bindModel(
    array(’hasMany’ => array(
        ’Principle’ => array(
          ’className’ => ’Principle’
        )
      )
    )
  );
  // Now that we’re associated correctly,
  // we can use a single find function to fetch
  // Leaders with their associated principles:
  $this->Leader->find(’all’);
}

El uso básico para bindModel() es la encapsulación de un array de asociación 
normal dentro de un array cuya clave es nombrada después del tipo de asociación
que uno está tratando de crear:

$this->Model->bindModel(
  array(’associationName’ => array(
      ’associatedModelClassName’ => array(
        // normal association keys go here...
      )
    )
  )
);

Aunque el modelo recientemente ligado (bound) no necesita ningún orden de 
definición de asociación en su archivo modelo, este aún necesitará la clave 
correcta para que la nueva asociación funcione de forma apropiada.

Múltiples relaciones para el mismo modelo
-----------------------------------------
Hay casos donde un Model tiene más que una relación a otro Model. Ej.: Puede 
tener un modelo Message que tiene 2 relaciones al modelo User: una relación al
usuario quién envía el mensaje, y un segundo al usuario quién recibe el mensaje.
La tabla de mensajes tendrá un campo user_id, pero también un campo recipient_id.
Ahora su modelo Message puede lucir como:

class Message extends AppModel {
  public $belongsTo = array(
    ’Sender’ => array(
      ’className’ => ’User’,
      ’foreignKey’ => ’user_id’
    ),
    ’Recipient’ => array(
      ’className’ => ’User’,
      ’foreignKey’ => ’recipient_id’
    )
  );
}

Recipient es un alias para el modelo User. Ahora veamos como luciría el modelo 
User:

class User extends AppModel {
  public $hasMany = array(
    ’MessageSent’ => array(
      ’className’ => ’Message’,
      ’foreignKey’ => ’user_id’
    ),
    ’MessageReceived’ => array(
      ’className’ => ’Message’,
      ’foreignKey’ => ’recipient_id’
    )
  );
}

Es también posible crear auto asociaciones como se muestra abajo:

class Post extends AppModel {
  public $belongsTo = array(
    ’Parent’ => array(
      ’className’ => ’Post’,
      ’foreignKey’ => ’parent_id’
    )
  );

  public $hasMany = array(
    ’Children’ => array(
      ’className’ => ’Post’,
      ’foreignKey’ => ’parent_id’
    )
  );
}

Extraer un array anidado de registros asociados
-----------------------------------------------
Si su tabla tiene un campo parent_id, puede también usar find(‘threaded’) para 
extraer un array anidado de registros usando una única consulta sin la puesta
a punto de ninguna asociación.

Unir (joining) de tablas
........................
En SQL, puede combinar tablas relacionadas usando la sentencia JOIN. Esto le 
permite realizar búsquedas complejas a través de múltiples tablas (ej.: 
buscar posts dadas varias etiquetas (tags)).

En CakePHP, algunas asociaciones (belongsTo y hasOne) realizan joins de forma
automática para recobrar datos, así uno puede emitir consultas para recobrar 
modelos basados en datos en el relacionado.

Pero este no es el caso con asociaciones hasMany y hasAndBelongsToMany. Para 
solucionar esto hay que forzar joins. Uno sólo tiene que definir los joins 
necesarios para combinar tablas y obtener los resultados deseados para su 
consulta.

Nota: Necesita fijar la recursión a -1 para que esto funcione:
$this->Channel->recursive = -1;

Para forzar un join entre tablas, necesita usar la sintaxis 'moderna' para
Model::find(), agregando una clave 'joins' al array $options. Ej.:

$options[’joins’] = array(
  array(’table’ => ’channels’,
    ’alias’ => ’Channel’,
    ’type’ => ’LEFT’,
    ’conditions’ => array(
      ’Channel.id = Item.channel_id’,
    )
  )
);
$Item->find(’all’, $options);

Note: Los arrays 'join' no tienen claves (keyed).

En el ej. de arriba, a un modelo llamado Item se le hace un left join a la tabla
channels. Puede hacer alias de la tabla con el nombre Model, así los datos
recobrados cumplen con la estructura de datos de CakePHP.

Las claves que definen el join son:

• table: Tabla para el join.
• alias: Alias a la tabla. El nombre del modelo asociado con la tabla es la 
  mejor apuesta.
• type: El tipo de join: inner, left ó right.
• conditions: condiciones a realizar el join.

Con joins, podría agregar condiciones basadas en campos de modelo Relacionados:

$options[’joins’] = array(
  array(’table’ => ’channels’,
    ’alias’ => ’Channel’,
    ’type’ => ’LEFT’,
    ’conditions’ => array(
      ’Channel.id = Item.channel_id’,
    )
  )
);

$options[’conditions’] = array(
  ’Channel.private’ => 1
);

$privateItems = $Item->find(’all’, $options);

Podría realizar varios joins como necesite en hasAndBelongsToMany.

Suponer que hay una asociación Book hasAndBelongsToMany Tag. Esta relación usa
una tabla books_tags como una tabla de join, así necesita unir la tabla books
a la tabla books_tags, y esto con la tabla tags:

$options[’joins’] = array(
  array(’table’ => ’books_tags’,
    ’alias’ => ’BooksTag’,
    ’type’ => ’inner’,
    ’conditions’ => array(
      ’Book.id = BooksTag.book_id’
    )
  ),
  array(’table’ => ’tags’,
    ’alias’ => ’Tag’,
    ’type’ => ’inner’,
    ’conditions’ => array(
      ’BooksTag.tag_id = Tag.id’
    )
  )
);

$options[’conditions’] = array(
  ’Tag.tag’ => ’Novel’
);

$books = $Book->find(’all’, $options);

Usar joins le permite tener máxima flexibilidad en como CakePHP maneja asociaciones
y extrae los datos. Pero, puede usar otras herramientas para lograr los mismos
resultados tales como definir asociaciones correctamente, hacer binding de modelos
al vuelo y usar el comportamiento Containable. Esta característica podría llevar
a consultas SQL mal formadas si se combinan con las técnicas de asociación de
modelos.

Recobrar sus datos
------------------
Uno de los roles de la capa Model es obtener datos desde múltiples tipos de
almacenamiento. La clase Model de CakePHP viene con algunas funciones que le 
ayudarán a buscar estos datos, ordenarlos, paginarlos, y filtrarlos. La función
más común que usará en modelos es Model::find().

find
----
find(string $type = ’first’, array $params = array())
.....................................................
Find es el caballo de fuerza multifuncional de todas las funciones de recobramiento
de datos del modelo. $type puede ser ’all’, ’first’, ’count’, ’list’, ’neighbors’ ó 
’threaded’, ó cualquier finder personalizado que uno pueda definir. $type es 
case-sensitive. Usar un caracter mayúsculas (por ej., All) no producirá los
resultados esperados.

$params se usa para pasar todos los parámetros a los tipos variados de find(),
y tiene las siguientes claves posibles por defecto, todas opcionales:

array(
  ’conditions’ => array(’Model.field’ => $thisValue), //array of conditions
  ’recursive’ => 1, //int
  //array of field names
  ’fields’ => array(’Model.field1’, ’DISTINCT Model.field2’),
  //string or array defining order
  ’order’ => array(’Model.created’, ’Model.field3 DESC’),
  ’group’ => array(’Model.field’), //fields to GROUP BY
  ’limit’ => n, //int
  ’page’ => n, //int
  ’offset’ => n, //int
  ’callbacks’ => true //other possible values are false, ’before’, ’after’
)

Es también posible agregar y usar otros parámetro. Algunos tipos de find() y
comportamientos hacen uso de esta habilidad, y sus propios métodos modelos 
también pueden.

Si su operación find() falla en coincidir algún registro, obtendrá un array 
vacío.

find(‘first’)
.............
find(’first’, $params) retornará un resultado. Ej.'s:

public function some_function() {
  // ...
  $semiRandomArticle = $this->Article->find(’first’);
  $lastCreated = $this->Article->find(’first’, array(
    ’order’ => array(’Article.created’ => ’desc’)
  ));
  $specificallyThisOne = $this->Article->find(’first’, array(
    ’conditions’ => array(’Article.id’ => 1)
  ));
  // ...
}

En el 1er ej., no se pasa ningún parámetro al find, así no se usarán ordenamiento
por sort ó condiciones. El formato retornado desde la llamada find('first') es
de la forma:

Array
(
  [ModelName] => Array
  (
    [id] => 83
    [field1] => value1
    [field2] => value2
    [field3] => value3
  )
  [AssociatedModelName] => Array
  (
    [id] => 1
    [field1] => value1
    [field2] => value2
    [field3] => value3
  )
)

find(‘count’)
.............
find(’count’, $params) retorna un valor entero. Abajo hay un par de ejemplos 
simples (código controlador):

public function some_function() {
  // ...
  $total = $this->Article->find(’count’);
  $pending = $this->Article->find(’count’, array(
    ’conditions’ => array(’Article.status’ => ’pending’)
  ));
  $authors = $this->Article->User->find(’count’);
  $publishedAuthors = $this->Article->find(’count’, array(
    ’fields’ => ’DISTINCT Article.user_id’,
    ’conditions’ => array(’Article.status !=’ => ’pending’)
  ));
  // ...
}

Nota: No pase campos como un array a find('count'). Sólo necesitaría especificar
campos para un conteo DISTINCT (ya que de otro modo el conteo es siempre el 
mismo, dictado por las condiciones).

find(‘all’)
...........
find(’all’, $params) retorna un array de potenciales resultados múltiples. Este
es el mecanismo usado por todas las variantes de find(), así como se paginan.
Ej.'s de código controlador simple:

public function some_function() {
  // ...
  $allArticles = $this->Article->find(’all’);
  $pending = $this->Article->find(’all’, array(
    ’conditions’ => array(’Article.status’ => ’pending’)
  ));
  $allAuthors = $this->Article->User->find(’all’);
  $allPublishedAuthors = $this->Article->User->find(’all’, array(
    ’conditions’ => array(’Article.status !=’ => ’pending’)
  ));
  // ...
}

Nota: En el ej. de arriba, $allAuthors contendrá cada usuario en la tabla users.
No habrá condición aplicada al find, ya que no fue pasado nada.

Los resultados de una llamada a find(’all’) será de la forma siguiente:

Array
(
  [0] => Array
  (
    [ModelName] => Array
    (
      [id] => 83
      [field1] => value1
      [field2] => value2
      [field3] => value3
    )
    [AssociatedModelName] => Array
    (
      [id] => 1
      [field1] => value1
      [field2] => value2
      [field3] => value3
    )
  )
)

find(‘list’)
............
find(’list’, $params) retorna un array indexado, útil para cualquier lugar 
donde uno querría una lista, tal como popular cajas select de inputs. Ej.'s
(código controlador):

public function some_function() {
  // ...
  $allArticles = $this->Article->find(’list’);
  $pending = $this->Article->find(’list’, array(
    ’conditions’ => array(’Article.status’ => ’pending’)
  ));
  $allAuthors = $this->Article->User->find(’list’);
  $allPublishedAuthors = $this->Article->find(’list’, array(
    ’fields’ => array(’User.id’, ’User.name’),
    ’conditions’ => array(’Article.status !=’ => ’pending’),
    ’recursive’ => 0
  ));
  // ...
}

Nota: En el ej. de arriba, $allAuthors contendrá cada usuario en la tabla users.
No habrá condición aplicada al find, ya que no se le pasó nada.

Los resultados de una llamada a find(’list’) serán de la forma:

Array
(
  //[id] => ’displayValue’,
  [1] => ’displayValue1’,
  [2] => ’displayValue2’,
  [4] => ’displayValue4’,
  [5] => ’displayValue5’,
  [6] => ’displayValue6’,
  [3] => ’displayValue3’,
)

Al llamar a find(’list’), los campos pasados son usados para determinar que 
debería usarse como clave y valor del array, y opcionalmente que por que agregar
los resultados. Por defecto, la clave primaria para el modelo se usa para la clave,
y el campo de exhibición (display field) (que puede ser configurado usando el 
modelo atributo displayField) se usa para el valor. Ej.'s para clarificar:

public function some_function() {
  // ...
  $justusernames = $this->Article->User->find(’list’, array(
    ’fields’ => array(’User.username’)
  ));
  $usernameMap = $this->Article->User->find(’list’, array(
    ’fields’ => array(’User.username’, ’User.first_name’)
  ));
  $usernameGroups = $this->Article->User->find(’list’, array(
    ’fields’ => array(’User.username’, ’User.first_name’, ’User.group’)
  ));
  // ...
}

Con el código de ejemplo de arriba, las variables resultantes lucirían como:

$justusernames = Array
(
  //[id] => ’username’,
  [213] => ’AD7six’,
  [25] => ’_psychic_’,
  [1] => ’PHPNut’,
  [2] => ’gwoo’,
  [400] => ’jperras’,
)

$usernameMap = Array
(
  //[username] => ’firstname’,
  [’AD7six’] => ’Andy’,
  [’_psychic_’] => ’John’,
  [’PHPNut’] => ’Larry’,
  [’gwoo’] => ’Gwoo’,
  [’jperras’] => ’Joël’,
)

$usernameGroups = Array
(
  [’User’] => Array
  (
    [’PHPNut’] => ’Larry’,
    [’gwoo’] => ’Gwoo’,
  )
  [’Admin’] => Array
  (
    [’_psychic_’] => ’John’,
    [’AD7six’] => ’Andy’,
    [’jperras’] => ’Joël’,
  )
)

find(‘threaded’)
................
find(’threaded’, $params) retorna un array anidado, y es apropiado si uno quiere
usar el campo parent_id de sus datos de modelo para construir resultados anidados.
Abajo hay un par de ejemplos simples (código controlador):

public function some_function() {
  // ...
  $allCategories = $this->Category->find(’threaded’);
  $comments = $this->Comment->find(’threaded’, array(
    ’conditions’ => array(’article_id’ => 50)
  ));
  // ...
}

Consejo: Una manera mejor de tratar con datos anidados es usar el comportamiento
Tree.

En el ej. de código de arriba, $allCategories contendrá un array anidado representando
la estructura de categoría completa. Los resultados de una llamada a find(’threaded’)
será de la forma siguiente:

Array
(
  [0] => Array
  (
    [ModelName] => Array
    (
      [id] => 83
      [parent_id] => null
      [field1] => value1
      [field2] => value2
      [field3] => value3
    )
    [AssociatedModelName] => Array
    (
      [id] => 1
      [field1] => value1
      [field2] => value2
      [field3] => value3
    )
    [children] => Array
    (
      [0] => Array
      (
        [ModelName] => Array
        (
          [id] => 42
          [parent_id] => 83
          [field1] => value1
          [field2] => value2
          [field3] => value3
        ) 
        [AssociatedModelName] => Array
        (
          [id] => 2
          [field1] => value1
          [field2] => value2
          [field3] => value3
        )
        [children] => Array
        (
        )
      )
    ...
    )
  )
)

Puede cambiarse el orden en que aparecen los resultados, ya que este es 
influenciado por el orden de procesamiento. Ej.: si se pasa ’order’ => ’name ASC’
en los parámetros a find(’threaded’), los resultados aparecerán orden de nombre.
Puede usarse cualquier orden; no hay ningún requerimiento incorporado de este 
método para que el resultado de más arriba sea retornado primero.

Advertencia: Si especifica campos (fields), siempre necesita incluir el id y 
parent_id (ó sus alias actuales):

public function some_function() {
  $categories = $this->Category->find(’threaded’, array(
    ’fields’ => array(’id’, ’name’, ’parent_id’)
  ));
}

De otro modo, el array retornado no será de la estructura anidada esperada de
arriba.

find(‘neighbors’)
.................
find(’neighbors’, $params) realizará un find similar a ‘first’, pero retornará
la fila antes y después del que uno peticione. Ej. (código controlador):  

public function some_function() {
  $neighbors = $this->Article->find(
    ’neighbors’,
    array(’field’ => ’id’, ’value’ => 3)
  );
}

Puede ver en este ej. los 2 elementos requeridos del array $params: campo (field) 
y valor. Otros elementos son también permitidos así como con cualquier otro find
(Ej.: Si su modelo actúa como contenible (containable)), puede luego especificar
‘contain’ en $params. El resultado retornado desde una llamada find(’neighbors’)
está en la forma:
  
Array
(
  [prev] => Array
  (
    [ModelName] => Array
    (
      [id] => 2
      [field1] => value1
      [field2] => value2
      ...
    )
    [AssociatedModelName] => Array
    (
      [id] => 151
      [field1] => value1
      [field2] => value2
      ...
    )
  )
  [next] => Array
  (
    [ModelName] => Array
    (
      [id] => 4
      [field1] => value1
      [field2] => value2
      ...
    )
    [AssociatedModelName] => Array
    (
      [id] => 122
      [field1] => value1
      [field2] => value2
      ...
    )
  )
)

Nota: Notar como el resultado siempre contiene sólo 2 elementos raíz: prev y next.
Esta función no hace honor a una variable (var) recursiva por defecto del modelo.

El ajuste recursivo debe ser pasado en los parámetros de cada llamada.

Crear tipos find personalizados
...............................
El método find es lo suficientemente flexible para aceptar sus finders personalizados.
Esto es hecho declarando sus tipos propios en una variable modelo e implementando
una función especial en su clase modelo.

Un Find Model Type es un acceso directo a opciones find(). Ej.: los siguientes
2 finds son equivalentes:

$this->User->find(’first’);
$this->User->find(’all’, array(’limit’ => 1));  
  
Los siguientes son tipos find núcleo:

• first
• all
• count
• list
• threaded
• neighbors

Respecto a los otros tipos, supongamos que quiere un finder para todos los artículos
publicados en su DB. El 1er cambio que necesita es agregar su tipo a la variable
Model::$findMethods en el modelo:

class Article extends AppModel {
  public $findMethods = array(’available’ => true);
}

Basicamente esto le dice a CakePHP que acepte el valor disponible como el 1er
argumento de la función find. El próximo paso es implementar el función 
_findAvailable. Esto es hecho por convención. Si uno quiere implementar un finder
llamado myFancySearch, el método a implementar sería nombrado _findMyFancySearch. 
 
class Article extends AppModel {
  public $findMethods = array(’available’ => true);
  protected function _findAvailable($state, $query, $results = array()) {
    if ($state === ’before’) {
      $query[’conditions’][’Article.published’] = true;
      return $query;
    }
    return $results;
  }
}

Todo esto viene junto al siguiente ejemplo (código controlador):

class ArticlesController extends AppController {
  // Will find all published articles and order them by the created column
  public function index() {
    $articles = $this->Article->find(’available’, array(
      ’order’ => array(’created’ => ’desc’)
    ));
  }
}

Los método _find[Type] especiales reciben 3 argumentos como se mostró arriba.
El primero significa el estado de la ejecución de la consulta, el cual podría
ser ya sea antes ó después. Esto es hecho de esta forma ya que esta función
es sólo un ordenamiento (sort) de función callback que tiene la habilidad de 
modificar la consulta antes que esta esté hecha, ó de modificar los resultados
después que estos son extraídos.

Típicamente lo primero a chequear en su función find personalizada es el estado
de la consulta. El estado 'before' es el momento para modificar la consulta, 
ligar (bind) asociaciones nuevas, aplicar más comportamientos, e interpretar
cualquier clave que es pasada en el 2do argumento de find. Este estado requiere
que uno retorne el argumento $query (modificado ó no).

El estado 'after' es el lugar para inspeccionar los resultados, inyectar datos
nuevos, procesarlos de la forma de retornarlo en otro formato, ó lo que quiera
hacer a los datos extraídos recientemente. Este estado requiere que uno retorne
el array $results (modificado ó no).
 
Puede crear cuantos finders personalizados como uno quiera, y estos son una gran
manera de reutilizar código en su aplicación a través de modelos.

Es también posible paginar vía un tipo find personalizado como sigue:

class ArticlesController extends AppController {
  // Will paginate all published articles
  public function index() {
    $this->paginate = array(’available’);
    $articles = $this->paginate();
    $this->set(compact(’articles’));
  }
}

Fijar la propiedad $this->paginate como arriba en el controlador resultará en el
tipo de find volviéndose disponible, y también le permitirá continuar en modificar
los resultados de find.  

Si su conteo de paginación de página se corrompe, puede necesitarse agregar el
código siguiente a su AppModel, el que arreglaría el conteo de paginación:

class AppModel extends Model {
  /**
  * Removes ’fields’ key from count query on custom finds when it is an array,
  * as it will completely break the Model::_findCount() call
  *
  * @param string $state Either "before" or "after"
  * @param array $query
  * @param array $results
  * @return int The number of records found, or false
  * @access protected
  * @see Model::find()
  */
  protected function _findCount($state, $query, $results = array()) {
    if ($state === ’before’) {
      if (isset($query[’type’]) && isset($this->findMethods[$query[’type’]])) {
        $query = $this->{
          ’_find’ . ucfirst($query[’type’])
        }(’before’, $query);
        if (!empty($query[’fields’]) && is_array($query[’fields’])) {
          if (!preg_match(’/^count/i’, current($query[’fields’]))) {
            unset($query[’fields’]);
          }
        }
      }
    }
    return parent::_findCount($state, $query, $results);
  }
}
?>

Cambiado en v.2.2.

Ya no necesita más redefinir _findCount para arreglar resultados de conteo 
incorrecto. El estado 'before' de su finder personalizado será llamado de vuelta
ahora con $query[’operation’] = ‘count’. El $query retornado será usado en 
_findCount(). Si es necesario, puede distinguir chequeando la clave 'operation'
y retornar un $query diferente:

protected function _findAvailable($state, $query, $results = array()) {
  if ($state === ’before’) {
    $query[’conditions’][’Article.published’] = true;
    if (!empty($query[’operation’]) && $query[’operation’] === ’count’) {
      return $query;
    }
    $query[’joins’] = array(
      //array of required joins
    );
    return $query;
  }
  return $results;
}

Magic Find Types
----------------
Estas funciones mágicas pueden usarse como acceso directo a buscar sus tablas 
por un cierto campo. Sólo agregar el nombre del campo (en formato Camel Case) al
final de estas funciones, y suministrar el criterio para ese campo como el 1er 
parámetro.

Las funciones findAllBy() retornarán los resultados en un formato como find(’all’), 
mientras findBy() retorna en el mismo formato que find(’first’).
   
findAllBy
.........
findAllBy<fieldName>(string $value, array $fields, array $order, int $limit, int $page, int $recursive)  

--------------------------------------------------------------------------------------
| findAllBy<x>                                  | Ej. que corresponde al fragmento SQL |                          |
--------------------------------------------------------------------------------------
| $this->Product->findAllByOrderStatus(’3’);    | Product.order_status = 3           |
|                                               |                                    |
| $this->Recipe->findAllByType(’Cookie’);       | Recipe.type = ’Cookie’             |
|                                               |                                    |
| $this->User->findAllByLastName(’Anderson’);   | User.last_name = ’Anderson’        |
|                                               |                                    |
| $this->Cake->findAllById(7);                  | Cake.id = 7                        |
|                                               |                                    |
| $this->User->findAllByEmailOrUsername(        | User.email = ’jhon’ OR             |
| ’jhon’, ’jhon’);                              | User.username = ’jhon’;            |
|                                               |                                    |
| $this->User->findAllByUsernameAndPassword(    | User.username = ’jhon’ AND         |
| ’jhon’, ’123’);                               | User.password = ’123’;             |
|                                               |                                    |
|  $this->User->findAllByLastName(’psychic’,    | User.last_name = ’psychic’         |
|  array(), array(’User.user_name => ’asc’));   | ORDER BY User.user_name ASC        |
--------------------------------------------------------------------------------------

El resultado retornado es un array formateado sólo como sería desde find(’all’).

findBy
......
findBy<fieldName>(string $value);

Las funciones mágicas findBy también aceptan algunos parámetros opcionales:

findBy<fieldName>(string $value[, mixed $fields[, mixed $order]]);

----------------------------------------------------------------------------------------
| findBy<x>                                     | Ej. que corresponde al fragmento SQL |
----------------------------------------------------------------------------------------
| $this->Product->findByOrderStatus(’3’);       | Product.order_status = 3             |
|                                               |                                      |
| $this->Recipe->findByType(’Cookie’);          | Recipe.type = ’Cookie’               |
|                                               |                                      |
| $this->User->findByLastName(’Anderson’);      | User.last_name = ’Anderson’;         |
|                                               |                                      |
| $this->User->findByEmailOrUsername(           | User.email = ’jhon’ OR               |
| ’jhon’, ’jhon’);                              | User.username = ’jhon’;              |
|                                               |                                      |
| $this->User->findByUsernameAndPassword(       | User.username = ’jhon’ AND           |
| ’jhon’,’123’);                                | User.password = ’123’;               |
|                                               |                                      |
| $this->Cake->findById(7);                     | Cake.id = 7                          |
----------------------------------------------------------------------------------------

Las funciones findBy() retornan resultados como find(’first’).

Model::query()
..............
query(string $query)

Las llamadas SQL que uno no puede ó no quiere hacer vía otros métodos de modelo
pueden hacerse usando el método query() del modelo.

Si uno usa este método, escapar apropiadamente todos los parámetro usando el método
value() en el driver de la DB. Fallar en escapar parámetros creará vulnerabilidades
de inyección SQL.

Nota: query() no hace honor a  $Model->cacheQueries a medida que su funcionalidad
es inherentemente disjunto desde aquel del modelo llamante (calling). Para evitar
las llamadas de caching para consulta (query), suministrar un 2do argumento de 
false, ej.:

query($query, $cachequeries = false)

query() usa el nombre de tabla en la consulta como la clave de array para los
datos retornados, en vez del nombre del modelo. Ej.:

$this->Picture->query("SELECT * FROM pictures LIMIT 2;");

Puede retornar:

Array
(
  [0] => Array
  (
    [pictures] => Array
    (
      [id] => 1304
      [user_id] => 759
    )
  )
  [1] => Array
  (
    [pictures] => Array
    (
      [id] => 1305
      [user_id] => 759
    )
  )
)

Para usar el nombre de modelo como la clave de array , y obtener un resultado
consistente con aquel retornado por los métodos Find, la consulta puede ser
reescrita:

$this->Picture->query("SELECT * FROM pictures AS Picture LIMIT 2;");

Que retorna:

Array
(
  [0] => Array
  (
    [Picture] => Array
    (
      [id] => 1304
      [user_id] => 759
    )
  )
  [1] => Array
  (
    [Picture] => Array
    (
      [id] => 1305
      [user_id] => 759
    )
  )
)

Nota: Esta sintaxis y la estructura de array correspondiente es válido sólo
para MySQL. CakePHP no provee ninguna abstracción de datos al correr las consultas
manualmente, así los resultados exactos variarán entre bases de datos.

Model::field()
..............
field(string $name, array $conditions = null, string $order = null)

Retorna el valor de un campo único, especificado como $name, desde el 1er registro
coincidente por $conditions a medida que se ordena por $order. Si no se pasan 
condiciones y el id del modelo es fijado (set), este retornará el valor del campo
para el resultado del modelo actual. 

Si no se halla ningún registro coincidente, este retorna false.

$this->Post->id = 22;
echo $this->Post->field(’name’); // echo the name for row id 22

// echo the name of the last created instance
echo $this->Post->field(
  ’name’,
  array(’created <’ => date(’Y-m-d H:i:s’)),
  ’created DESC’
);

Model::read()
.............
read($fields, $id)

read() es un método usado para fijar los datos del modelo actual (Model::$data)
- tales como edición - pero este puede usarse también en otras circunstancias
para recobrar un único registro desde la DB.

$fields se usa para pasar un nombre de campo único, ó un array de nombres de campo;
si se deja vacío, todos los campos serán recobrados.

$id especifica la ID del registro a ser leído. Por defecto, se usa el registro 
actualmente seleccionado, especificado por Model::$id. Pasar un valor diferente
a $id causará que el registro sea seleccionado.

read() siempre retorna un array (aún si es peticionado sólo un único nombre de
campo). Usar field para recobrar el valor del campo único.

Advertencia: Ya que el método read sobreescribe cualquier información almacenada
en los datos y propiedad id del modelo, uno debería ser cuidadoso al usar esta
función en general, especialmente usando este en las funciones callback del modelo
tales como beforeValidate y beforeSave. Generalmente la función find provee un
trabajo más fácil y robusto para funcionar con la API que el método read.

Condiciones Find Complejas
--------------------------
La mayoría de las llamadas find del modelo involucran pasar sets de condiciones
en un modo ú otro. En general, CakePHP prefiere usar arrays para expresar 
cualquiera de las condiciones que necesitan ponerse detrás de la cláusula WHERE
en cualquier consulta SQL.

Usar arrays es más fácil y claro de leer, y también hace muy fácil construir 
consultas. Este sintaxis también saca (breaks out) los elementos de su consulta
(campos, valores, operadores, etc.) en partes discretas manipulables. Esto le 
permite a CakePHP generar la consulta más eficiente posible, asegurar la sintaxis
SQL apropiada, y escapar apropiadamente cada 

 each individual part of the query. Using the array syntax also enables CakePHP to secure your queries
against any SQL injection attack.

At its most basic, an array-based query looks like this:

$conditions = array("Post.title" => "This is a post", "Post.author_id" => 1);
// Example usage with a model:
$this->Post->find(’first’, array(’conditions’ => $conditions));

The structure here is fairly self-explanatory: it will find any post where the title equals “This is a post” and
the author id is equal to 1. Note that we could have used just “title” as the field name, but when building
queries, it is good practice to always specify the model name, as it improves the clarity of the code, and
helps prevent collisions in the future, should you choose to change your schema.

What about other types of matches? These are equally simple. Let’s say we wanted to find all the posts
where the title is not “This is a post”:

array("Post.title !=" => "This is a post")

Notice the ‘!=’ that follows the field name. CakePHP can parse out any valid SQL comparison operator,
including match expressions using LIKE, BETWEEN, or REGEX, as long as you leave a space between
field name and the operator. The one exception here is IN (...)-style matches. Let’s say you wanted to find
posts where the title was in a given set of values:

array(
"Post.title" => array("First post", "Second post", "Third post")
)

To do a NOT IN(...) match to find posts where the title is not in the given set of values, do the following:

array(
"NOT" => array(
"Post.title" => array("First post", "Second post", "Third post")
)
)

Adding additional filters to the conditions is as simple as adding additional key/value pairs to the array:

array (
"Post.title" => array("First post", "Second post", "Third post"),
"Post.created >" => date(’Y-m-d’, strtotime("-2 weeks"))
)

You can also create finds that compare two fields in the database:

array("Post.created = Post.modified")

The above example will return posts where the created date is equal to the modified date (that is, it will
return posts that have never been modified).


(240/336)