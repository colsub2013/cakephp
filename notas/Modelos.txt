MODELOS
=======
Las clases del modelo pueden usarse para acceder a:

. Tablas de base de datos
. Archivos
. Web Services externos
. Eventos iCal

Un modelo puede asociarse con otros. Ej.: un Recipe puede asociarse con un Author
como también un Ingredient.

Entender Modelos
----------------
Un modelo representa modelo de datos. 

Ej. de definición de modelo en CakePHP:

App::uses(’AppModel’, ’Model’);
class Ingredient extends AppModel {
  public $name = ’Ingredient’;
}

Con sólo una declaración, el modelo Ingredient es dotado con toda la funcionalidad
que necesita para crear consultas y almacenar y borrar datos. Estos métodos vienen
de la clase Modelo de CakePHP por herencia. El modelo Ingredient extiende 
el modelo de aplicación, AppModel, que a su vez extiende la clase Model interna
de CakePHP. 

Es esta clase Model núcleo que otorga la funcionalidad en su modelo Ingredient.
App::uses(’AppModel’, ’Model’) asegura que el modelo es cargado cuando se
necesite.

La clase intermedia, AppModel, está vacía. Si no la ha creado, se tomará de la
carpeta núcleo de CakePHP. Redefinir el AppModel le permite definir funcionalidad
que debería estar disponible a todos los modelos dentro de su aplicación. Para
hacerlo, necesita crear su propio archivo AppModel.php que reside en la carpeta
Model, como lo hace con todos los otros modelos de su aplicación. Crear un proyecto
usando Bake generará automáticamente este archivo por uno.

De vuelta en el modelo Ingredient, crear el archivo PHP en el directorio /app/Model/.
Por convención, este debería tener el mismo nombre que la clase, que para este ej.
es Ingredient.php.

Nota: CakePHP creará dinámicamente un objeto modelo para uno si este no puede 
hallar un archivo correspondiente en /app/Model. Esto significa que si su 
archivo modelo no se nombra correctamente (ej., se nombra ingredient.php ó 
Ingredients.php en vez de Ingredient.php), CakePHP usará una instancia de AppModel
en vez de su archivo modelo (que CakePHP asume perdido). Si uno intenta usar 
un método que ha definido en su modelo, ó un comportamiento unido a su modelo,
y uno está obteniendo errores SQL que que son el nombre del método que uno está
llamando, es una señal segura que CakePHP no puede hallar su modelo y necesita
chequear los nombres de archivo, su caché de aplicación, ó ambos.

Nota: Algunos nombres de clase no son útiles para nombres de modelo. Ej.: 'File'
no puede usarse, ya que 'File' es una clase que ya existe en el núcleo CakePHP.

Definido su modelo, este puede ser accedido desde dentro de su Controller. CakePHP
hará al modelo disponible automáticamente para acceso cuando su nombre coincida
con el del controlador. Ej.: un controlador llamado IngredientsController inicializará
automáticamente el modelo Ingredient y lo anexará al controlador en $this->Ingredient:

class IngredientsController extends AppController {
  public function index() {
    //grab all ingredients and pass it to the view:
    $ingredients = $this->Ingredient->find(’all’);
    $this->set(’ingredients’, $ingredients);
  }
}

Los modelos asociados están disponibles a través del modelo principal. En el 
siguiente ej., Recipe tiene una asociación con el modelo Ingredient:

class Recipe extends AppModel {
  public function steakRecipes() {
    $ingredient = $this->Ingredient->findByName(’Steak’);
    return $this->findAllByMainIngredient($ingredient[’Ingredient’][’id’]);
  }
}

Este muestra como usar modelos que ya están enlazados (linked).

Más sobre modelos
-----------------

Asociaciones: Enlazar modelos
-----------------------------
En CakePHP, los enlaces entre modelos son manejados a través de asociaciones.

Definir relaciones entre objetos diferentes en su aplicación debería ser un 
proceso natural. Ej.: en una DB recipe (receta), una receta puede tener varias
reseñas (reviews), las reseñas pueden tener un único autor, y los autores pueden
tener varias recetas.

Relationship Types
..................
Los 4 tipos de asociación en CakePHP son: hasOne, hasMany, belongsTo, y hasAndBelongsToMany
(HABTM).

---------------------------------------------------------------------------------------------------
| Relación       | Tipo de asociación  | Ejemplo                                                  |
---------------------------------------------------------------------------------------------------
| one to one     | hasOne              | Un usuario tiene un único perfil.                        |
| one to many    | hasMany             | Un usuario puede tener múltiples recetas.                |
| many to one    | belongsTo           | Muchas recetas pueden pertenecer a un usuario.           |
| many to many   | hasAndBelongsToMany | Las recetas tienen, y pertenecen a varios ingredientes.  |
---------------------------------------------------------------------------------------------------

Las asociaciones son definidas creando una variable de clase nombrada después de la 
asociación que uno está definiendo. La variable de clase puede ser tanto un
string como un array multidimensional usado para definir cosas específicas de 
asociación.

class User extends AppModel {
  public $hasOne = ’Profile’;
  public $hasMany = array(
    ’Recipe’ => array(
      ’className’ => ’Recipe’,
      ’conditions’ => array(’Recipe.approved’ => ’1’),
      ’order’ => ’Recipe.created DESC’
    )
  );
}

En el ej. de arriba, la 1ra instancia de la palabra 'Recipe' es lo que se denomina
un 'Alias'. Este es un identificador para la relación, y puede ser cualquiera que
elija. Usualmente, uno eligirá el mismo nombre que la clase que este referencia.
Pero, los alias para cada modelo deben ser únicos a través de la aplicación. 
Ej.: es apropiado tener:

class User extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’MemberOf’ => array(
      ’className’ => ’Group’,
    )
  );
  
}

class Group extends AppModel {
  
  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’User’,
    )
  );
}

pero lo siguiente no funcionará bien en todas las circunstancias:

class User extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’Group’,
    )
  );

}

class Group extends AppModel {

  public $hasMany = array(
    ’MyRecipe’ => array(
      ’className’ => ’Recipe’,
    )
  );

  public $hasAndBelongsToMany = array(
    ’Member’ => array(
      ’className’ => ’User’,
    )
  );

}

debido a que aquí tenemos el alias 'Member' que se refiere a ambos User (en Group)
y el modelo Group (en User) en las asociaciones HABTM. Elegir nombres no únicos
para alias de modelo a través de modelos pueden originar un comportamiento
inesperado. 

CakePHP creará automáticamente enlaces entre los objetos modelo asociados. Ej.: 
en su modelo User uno puede acceder al modelo Recipe como:

$this->Recipe->someFunction();

Similarmente en su controlador uno puede acceder a un modelo asociado simplemente
siguiendo sus asociaciones de modelo:

$this->User->Recipe->someFunction();

Nota: las asociaciones son definidas en 'un sentido'. Si define User hasMany Recipe,
esto no tiene efecto en el Modelo Recipe. Necesita definir Recipe belongsTo User 
para ser capaz de acceder al modelo User desde su modelo Recipe.

hasOne
......
Se va a configurar un modelo User con una relación hasOne para un modelo Profile.

Primero, sus tablas en la DB necesitan tener las claves correctamente. Para que 
funcione una relación hasOne, una tabla tiene que contener una clave foránea
que apunta a un registro en la otra. En este caso, la tabla profiles contendrá
un campo llamado user_id. El patrón básico:

hasOne: el otro modelo contiene la clave foránea.
°°°°°°
---------------------------------------------
| Relación              | Esquema           | 
---------------------------------------------
| Apple hasOne Banana   | bananas.apple_id  |
| User hasOne Profile   | profiles.user_id  |
| Doctor hasOne Mentor  | mentors.doctor_id |
---------------------------------------------

Nota: no es obligatorio seguir las convenciones CakePHP. Puede redefinir el uso
de cualquier clave foránea en sus definiciones de asociaciones.

El archivo modelo User será almacenado en /app/Model/User.php. Para definir la 
asociación ‘User hasOne Profile’, agregar la propiedad $hasOne a la clase modelo.
Recordar tener un modelo Profile en /app/Model/Profile.php, ó la asociación no
funcionará: 
 
class User extends AppModel {
  public $hasOne = ’Profile’;
}

Hay 2 modos de describir esta relación en sus archivos modelo. El método más
simple es fijar el atributo $hasOne a un string que contiene el nombre de clase
del modelo asociado, como se ha hecho arriba.

Si necesita más control, puede definir sus asociaciones usando sintaxis de array.
Ej.: puede querer limitar la asociación para incluir sólo ciertos registros.

class User extends AppModel {
  public $hasOne = array(
    ’Profile’ => array(
      ’className’ => ’Profile’,
      ’conditions’ => array(’Profile.published’ => ’1’),
      ’dependent’ => true
    )
  );
}

Las claves posibles para los arrays de asociación hasOne incluyen:

• className: el nombre de clase del modelo siendo asociado al modelo actual. Si 
uno está definiendo una relación ‘User hasOne Profile’, la clave className sería
igual a ‘Profile’. 

• foreignKey: el nombre de la clave foránea hallada en el otro modelo. Esto es
útil si necesita definir relaciones hasOne múltiples. El valor por defecto para 
esta clave es el '_', el nombre único del modelo actual, con sufijo ‘_id’. En el
ej. de arriba, este sería por defecto ‘user_id’.

• conditions: un array de condiciones compatibles con find() ó strings SQL como  
array(‘Profile.approved’ => true).

• fields: una lista de campos a ser recobrados cuando son extraídos los datos de
modelo asociados. Retorna todos los campos por defecto.

• order: un array de cláusulas de orden compatibles con find() ó strings SQL como
array(‘Profile.last_name’ => ‘ASC’).

• dependent: cuando se fija a true la clave dependent, y el método delete() del 
modelo es llamado con el parámetro cascade fijado a true, los registros de modelo
asociado también son borrados. En este caso, se lo fija a true tal que borrar
un User también borrará su Profile asociado.
 
Definida esta asociación, las operaciones de find en el modelo User también 
extraerá un registro relacionado a Profile si este existe:

//Sample results from a $this->User->find() call.
Array
(
  [User] => Array
  (
    [id] => 121
    [name] => Gwoo the Kungwoo
    [created] => 2007-05-01 10:31:01
  )
  [Profile] => Array
  (
    [id] => 12
    [user_id] => 121
    [skill] => Baking Cakes
    [created] => 2007-05-01 10:31:01
  )
)

belongsTo
.........

SEGUIR(211)