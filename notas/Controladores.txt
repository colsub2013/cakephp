CONTROLADORES
=============
Un controlador suele usarse para gestiona la lógica alrededor de un modelo único.
Ej.: si uno construye un sitio para una panadería (bakery) online, uno puede tener
un RecipesController que gestione sus recetas y un IngredientsController que 
gestione sus ingredientes. Se pueden tener también controladores que funcionen con
más de un modelo. En CakePHP, un controlador se nombra después del modelo primario
que maneja.

Sus controladores de aplicación extienden la clase AppController, que extiende
la clase Controller núcleo. La clase AppController puede definirse en  
/app/Controller/AppController.php y este debería contener métodos que son 
compartidos entre todos los controladores de su aplicación.

Los controladores proveen un número de métodos que manejan peticiones. Estas son
llamadas acciones. Por defecto, cada método público en un controlador es una
acción, y es accesible desde una URL. Una acción es responsable de interpretar
la petición y crear la respuesta. Usualmente las respuestas están en la forma
de vista renderizada, pero también hay otros modos de crear respuestas.
................................................................................

El App Controller
-----------------
La clase AppController es la clase padre de todos sus controladores de aplicación.
AppController mismo extiende la clase Controller incluída en la librería núcleo
de CakePHP. AppController está definia en /app/Controller/AppController.php como
sigue:  

class AppController extends Controller {
}

Los atributos y métodos Controller creados en su AppController estarán disponibles
para todos sus controladores de la aplicación. 

Mientras que las reglas de herencia orientadas a objeto normales aplican, CakePHP
hace trabajo adicional cuando se vienen atributos controlador especiales. Para los 
componentes y helpers usados por un controlador, los arrays de valor AppController
son mergeados con arreglos de clase controlador hijos. Los valores en la clase
hijo siempre redefinirán aquellos en AppController.  

Nota: CakePHP mergea las siguientes variables desde el AppController en sus controladores
de aplicación:

• $components
• $helpers
• $uses

Hay que agregar los helpers de formulario y Html por defecto si uno define la
propiedad $helpers en su AppController.

También llamar a los callbacks de AppController dentro de los callbacks controlador
hijos para mejorar los resultados:

public function beforeFilter() {
  parent::beforeFilter();
}

Parámetros de request
---------------------
Cuando es hecha una petición a una aplicación CakePHP, las clases Router y Dispatcher
de CakePHP usan la configuración de Enrutamiento para hallar y crear el controlador
correcto. Los datos de petición son encapsulados en un objeto request. CakePHP 
pone toda la información de request importante en la propiedad $this->request.

Acciones Controller
-------------------
Las acciones Controller son responsables de convertir los parámetros de petición 
en una respuesta para el usuario / navegador que hace la petición. CakePHP usa
convenciones para automatizar este proceso y quitar algún código repetitivo
que de otro modo necesitaría escribir.

Por convención, CakePHP renderiza una vista con una versión inclinada del nombre
de acción. Volviendo al ej. de la panadería online, nuestro RecipesController 
puede contener las acciones view(), share(), y search(). El controlador 
estaría ubicado en /app/Controller/RecipesController.php y contiene:   

# /app/Controller/RecipesController.php
class RecipesController extends AppController {
  public function view($id) {
    //action logic goes here..
  }
  
  public function share($customerId, $recipeId) {
    //action logic goes here.. 
  }
  
  public function search($query) {
    //action logic goes here..
  }
}

Los archivos de vista para estas acciones serían app/View/Recipes/view.ctp,
app/View/Recipes/share.ctp, y app/View/Recipes/search.ctp. El nombre de archivo
de vista convencional es la versión en minúsculas y subrayada del nombre de 
acción.

Las acciones Controller usan generalmente set() para crear un contexto que usa View
para renderizar la vista. Debido a la convención que usa CakePHP, no necesita
crear y renderizar la vista manualmente. En vez de eso, una vez que la acción 
controlador se ha completado, CakePHP manejará la renderización y entregará la
View. 

Si uno quiere esquivar el comportamiento por defecto la cual es hacer un desvío
de la renderización de vista.

. Si retorna un string, o un objeto que puede ser convertido a un string desde su
acción controlador, este será usado como el cuerpo de respuesta

. Puede retornar un objeto CakeResponse con la respuesta creada completamente

Cuando uno usa métodos controlador con requestAction(), con frecuencia querrá
retornar datos que no son un string. Si tiene métodos controlador que son usados
para peticiones web normales + requestAction, debería chequear el tipo de 
petición antes de retornar:

class RecipesController extends AppController {
  public function popular() {
    $popular = $this->Recipe->popular();
    if (!empty($this->request->params[’requested’])) {
      return $popular;
    }
    $this->set(’popular’, $popular);
  }
}

La acción controlador de arriba es un ej. de como puede usarse un método con
requestAction() y peticiones normales. Retornar datos de array a una petición
no-requestAction causará errores y debería evitarse.
................................................................................
Callbacks de petición Ciclo de vida
-----------------------------------
Clase Controller
................
Los controladores CakePHP vienen ajustados con callbacks que puede usar para 
insertar lógica sobre la petición del ciclo de vida:
 
Controller::beforeFilter()

Esta función es ejecutada antes de cada acción en el controlador. Es bueno 
chequear por una sesión activa ó inspeccionar permisos de usuario.

Note: The beforeFilter() method will be called for missing actions, and scaffolded actions.

Controller::beforeRender()

Llamado después de la lógica acción controlador, pero antes que la vista sea
renderizada. Este callback no se usa con frecuencia, pero pueden ser necesario
si uno llama manualmente a render() antes de finalizar una acción dada.

Controller::afterFilter()

Llamado después de cada acción controlador, y después que se completa la renderización.
Este es el último método controlador a ejecutar.

En adición a callbacks controlador de ciclo de vida, los componentes también
proveen un set similar de callbacks.

Métodos Controlador
-------------------
Interacción con Views
.....................
Los controladores interactúan con vistas en varias formas. Primero, son capaces
de pasar datos a las vistas, usando set(). Puede también decidir que clase de 
vista usar, y que archivo de vista debería ser renderizado desde el controlador.
 
Controller::set(string $var, mixed $value)

El método set() es el modo principal de enviar datos desde su controlador a su
vista. Usado set(), la variable puede ser accedida en su vista:

// Primero pasar datos desde el controlador:
$this->set(’color’, ’pink’);
// Luego, en la vista puede utilizar los datos:
?>
You have selected <?php echo $color; ?> icing for the cake.

El método set() también toma un array asociativo como su primer parámetro. Esto
puede con frecuencia un modo rápido de asignar un set de información a la vista:

$data = array(
  ’color’ => ’pink’,
  ’type’ => ’sugar’,
  ’base_price’ => 23.95
);
// make $color, $type, and $base_price available to the view:

$this->set($data);

El atributo $pageTitle ya no existe. Usar set() para fijar el título:

$this->set(’title_for_layout’, ’This is the page title’);

Controller::render(string $view, string $layout)

El método render() es llamado automáticamente al final de cada acción controlador
peticionada. Este método realiza toda la lógica de vista (usando los datos que ha
enviado usando el método set()), pone la vista dentro de su $layout, y lo sirve
de vuelta al usuario final.  

La archivo vista por defecto usado para renderizar es determinado por convención.
Si es peticionada la acción search() del RecipesController, el archivo de vista
en /app/View/Recipes/search.ctp será renderizado:

class RecipesController extends AppController {
  // ...
  public function search() {
    // Render the view in /View/Recipes/search.ctp
    $this->render();
  }
  // ...
}

Aunque CakePHP lo llamará automáticamente después de cada lógica de la acción
(a menos que haya seteado $this->autoRender a false), puede usarlo para especificar
un archivo de vista alternativo especificando un nombre de acción en el controlador
usando $action.

Si $view comienza con ‘/’, se asume ser una archivo elemento ó vista relativo a 
la carpeta /app/View. Esto permite renderización directa de elementos, muy útil
en llamadas AJAX.

// Renderiza el elemento en /View/Elements/ajaxreturn.ctp
$this->render(’/Elements/ajaxreturn’);

El parámetro $layout le permite especificar el layout con el cual se renderiza
la vista.

Renderizar una vista específica
...............................
En su controlador, puede querer renderizar una vista diferente que la convencional.
Puede hacer esto llamando directamente a render(). Una vez que ha llamado a 
render(), CakePHP no intentará re-renderizar la vista:

class PostsController extends AppController {
  public function my_action() {
    $this->render(’custom_file’);
  }
}

Esto renderizaría app/View/Posts/custom_file.ctp en vez de 
app/View/Posts/my_action.ctp

Puede también renderizar vistas dentro de plugins usando la sintaxis:
$this->render(’PluginName.PluginController/custom_file’). Ej.:

class PostsController extends AppController {
  public function my_action() {
    $this->render(’Users.UserDetails/custom_file’);
  }
}

Esto renderizaría app/Plugin/Users/View/UserDetails/custom_file.ctp

Control de flujo
----------------
Controller::redirect(mixed $url, integer $status, boolean $exit)
################################################################
El método control de flujo que usará con mayor frecuencia es redirect(). Este 
método toma su primer parámetro en la forma de una URL relativa de CakePHP. 
Cuando un usuario ha hecho una orden exitosamente, puede desear redireccionarlas
a una pantalla de recepción:

public function place_order() {
  // La lógica para finalizar la orden va aquí
  if ($success) {
    return $this->redirect(
      array(’controller’ => ’orders’, ’action’ => ’thanks’)
    );
  }
  return $this->redirect(
    array(’controller’ => ’orders’, ’action’ => ’confirm’)
  );
}

Puede también usar una URL absoluta ó relativa como el argumento $url:

$this->redirect(’/orders/thanks’);
$this->redirect(’http://www.example.com’);

Puede también pasar datos a la acción:

$this->redirect(array(’action’ => ’edit’, $id));

El segundo parámetro de redirect() le permite definir un código de estado HTTP 
para acompañar la redirección. Puede querer usar 301 (movido permanentemente) ó
303 (ver otro), dependiendo de la naturaleza de la redirección.

El método expedirá un exit() después del redirect a menos que uno setee el 3er
parámetro a false.

Si uno necesita redireccionar a la página de referencia puede usar:

$this->redirect($this->referer());

El método también soporta parámetros basados en nombre. Si quiere redireccionar
a una URL como: 

http://www.example.com/orders/confirm/product:pizza/quantity:5

Puede usar:

$this->redirect(array(
  ’controller’ => ’orders’,
  ’action’ => ’confirm’,
  ’product’ => ’pizza’,
  ’quantity’ => 5)
);

Un ejemplo de usar query strings y hash luciría:

$this->redirect(array(
  ’controller’ => ’orders’,
  ’action’ => ’confirm’,
  ’?’ => array(
    ’product’ => ’pizza’,
    ’quantity’ => 5
  ),
  ’#’ => ’top’)
);

La URL generada sería:

http://www.example.com/orders/confirm?product=pizza&quantity=5#top

Controller::flash(string $message, string|array $url, integer $pause, string $layout)
#####################################################################################
Como redirect(), el método flash() se usa para redireccionar un usuario a una 
página nueva después de una operación. El método flash() es diferente en que
muestra un mensaje antes de pasar a otra URL.

El 1er parámetro debería contener el mensaje a exhibirse, y el 2do parámetro
es una URL relativa de CakePHP. CakePHP exhibirá el $message por $pause segundos
antes de hacer un forward al usuario.

Si hay una plantilla particular en que querría que use su mensaje flasheado,
puede especificar el nombre de ese layout en el parámetro $layout.

Para mensajes de flash en página, fijarse en el método SessionComponent::setFlash().

Callbacks
---------
Además de los callback de Request de ciclo de vida, CakePHP también soporta callbacks
relacionados a scaffolding (andamio).

Controller::beforeScaffold($method)
  $method es el nombre del método llamado por ej. index, edit, etc.
  
Controller::afterScaffoldSave($method)
  $method es el nombre del método llamado ya sea edit ó update.

Controller::afterScaffoldSaveError($method)
  $method es el nombre del método llamado ya sea edit ó update.

Controller::scaffoldError($method)
  $method es el nombre del método llamado por ej. index, edit, etc.

Otros métodos útiles
--------------------

Controller::constructClasses()
##############################
Este método carga los modelos requeridos por un controlador. Este proceso de 
carga es normalmente hecho por CakePHP, pero este método es útil tener cuando
se accede a controladores desde una perspectiva diferente. Si necesita CakePHP
en un script de línea de comandos ó algún otro uso externo, puede usar
constructClasses().

Controller::referer(mixed $default = null, boolean $local = false)
##################################################################
Retorna la URL de referencia para la petición actual. Puede usarse el parámetro
$default para suministrar una URL por defecto a usar si HTTP_REFERER no puede 
ser leído desde headers. Así, en vez de hacer esto:

class UserController extends AppController {
  public function delete($id) {
    // delete code goes here, and then...
    if ($this->referer() != ’/’) {
      return $this->redirect($this->referer());
    }
    return $this->redirect(array(’action’ => ’index’));
  }
}

puede hacer lo siguiente:

class UserController extends AppController {
  public function delete($id) {
    // delete code goes here, and then...
    return $this->redirect(
      $this->referer(array(’action’ => ’index’))
    );
  }
}

Si no se setea $default, la función va por defecto a la raíz de su dominio - ‘/’.

Si el parámetro $local se fija a true, restringe las URLs referentes al servidor
local.  

Controller::disableCache()
##########################
Usado para decirle al navegador del usuario no cachear los resultados de la
petición actual. Esto es diferente que el cacheo de vista.

Los headers enviados a este efecto son:

Expires: Mon, 26 Jul 1997 05:00:00 GMT
Last-Modified: [current datetime] GMT
Cache-Control: no-store, no-cache, must-revalidate
Cache-Control: post-check=0, pre-check=0
Pragma: no-cache

Controller::postConditions(array $data, mixed $op, string $bool, boolean $exclusive)
####################################################################################
Usar este método para convertir un set de datos de modelo POSTed (de entradas 
HtmlHelper-compatible) en un set de de condiciones de find para un modelo.
Esta función ofrece un atajo al construir lógica de búsqueda. Ej.: un usuario
administrativo puede querer ser capaz de buscar órdenes en orden para saber que
items necesitan empaquetarse. Puede usar FormHelper y HtmlHelper de CakePHP
para crear un formulario rápido basado en el modelo Order. Luego una acción 
controlador puede usar los datos posteados desde aquel formulario para las 
condiciones de escenario de find:  

public function index() {
  $conditions = $this->postConditions($this->request->data);
  $orders = $this->Order->find(’all’, compact(’conditions’));
  $this->set(’orders’, $orders);
}

Si $this->request->data[’Order’][’destination’] equivale a “Old Towne Bakery”,
postConditions convierte esa condición a un array compatible para usar en un 
método Model->find(). En este caso, array(’Order.destination’ => ’Old Towne Bakery’).

Si quiere usar un operador SQL diferente entre condiciones, suministrarla usando
el 2do parámetro:

/*
Contents of $this->request->data
array(
  ’Order’ => array(
    ’num_items’ => ’4’,
    ’referrer’ => ’Ye Olde’
  )
)
*/

// Se obtienen órdenes que tienen al menos 4 items y contienen ’Ye Olde’
$conditions = $this->postConditions(
  $this->request->data,
  array(
    ’num_items’ => ’>=’,
    ’referrer’ => ’LIKE’
  )
);
$orders = $this->Order->find(’all’, compact(’conditions’));

El 3er parámetro le permite decirle a CakePHP que operador boolean SQL usar entre
las condiciones de find. Los strings como  ‘AND’, ‘OR’ and ‘XOR’ son todos 
valores válidos.

Si el último parámetro se fija a true, y el parámetro $op es un array, los campos
no incluidos en $op no serán incluidos en las condiciones retornadas.

Controller::paginate()
......................
Método usado para resultados de paginación extraidos por sus modelos. Puede 
especificar tamaños de página, condiciones de find del modelo y más. 


Controller::requestAction(string $url, array $options)
......................................................
Esta función llama a una acción de controlador desde cualquier ubicación y retorna
datos de la acción. El $url pasado es una URL relativa de CakePHP 
(/nombrecontrolador/nombreaccion/parametros). Para pasar datos extra a la acción
controlador de recepción agregarlo al array $options.

Nota: Puede usar requestAction() para recobrar una vista completamente renderizada
pasando 'return' en options: requestAction($url, array(’return’));. Hacer un 
requestAction() usando return desde un método controlador puede causar que las
etiquetas script y CSS no funcionen correctamente.

Advertencia: si se usa requestAction() sin cacheo puede resultar en baja
performance. No suele ser apropiado usarlo en un controlador ó modelo.

requestAction() se usa mejor en conjunción con elementos (cacheados) - como un 
modo de recobrar datos para un elemento antes de renderizar. Usar el ej. de 
poner un elemento "últimos comentarios" en el layout. Primero necesitamos crear
una función controlador que retornará los datos:

// Controller/CommentsController.php
class CommentsController extends AppController {
  public function latest() {
    if (empty($this->request->params[’requested’])) {
      throw new ForbiddenException();
    }
    return $this->Comment->find(
      ’all’,
      array(’order’ => ’Comment.created DESC’, ’limit’ => 10)
    );
  }
}

Uno siempre debería incluir chequeos para asegurarse que sus métodos requestAction()
efectivamente son originados desde requestAction(). Fallar en hacer esto le 
permitirá a los métodos requestAction() ser accesibles directamente desde una
URL, lo que es indeseable.

Si creamos un elemento simple para llamar a esa función:

// View/Elements/latest_comments.ctp
$comments = $this->requestAction(’/comments/latest’);
foreach ($comments as $comment) {
  echo $comment[’Comment’][’title’];
}

Podemos poner ese elemento en cualquier lado para obtener la salida usando:

echo $this->element(’latest_comments’);

Escrito de este modo, siempre y cuando el elemento se renderize, se hará una 
petición al controlador para obtner los datos, los datos serán procesados, y 
retornados. Pero lo mejor es usar el cacheo de elemento para evitar procesamiento
innecesario. Modificar la llamada a element para lucir como:

echo $this->element(’latest_comments’, array(), array(’cache’ => true));

La llamada requestAction() no será hecha mientras el archivo vista elemento 
cacheado exista y sea válido.

Adicionalmente, requestAction() toma URLs de estilo cake basados en array:

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’featured’),
  array(’return’)
);

Esto le permite a la llamada requestAction() saltear el uso de Router::url() que
puede incrementar la performance. Los arrays basados en url son los mismos que
los que usa HtmlHelper::link() con una diferencia - si uno está usando parámetros
nombrados ó pasados, debe ponerlos en un 2do array y envolverlos con la clave 
correcta. Esto es debido a que requestAction() mergea el array de args nombrado
(2do parámetro de requestAction) con el array miembro Controller::params y no
ubica explícitamente el array nombrado args en la clave 'named'; también estarán
disponibles miembros adicionales en el array $option en el array Controller::params
de la acción peticionada:

echo $this->requestAction(’/articles/featured/limit:3’);
echo $this->requestAction(’/articles/view/5’);

Como un array en requestAction() sería:

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’featured’),
  array(’named’ => array(’limit’ => 3))
);

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’view’),
  array(’pass’ => array(5))
);

Nota: A diferencia de otros lugares donde URLs de array son análogos a URLs de 
string, requestAction() los trata de forma diferente.

Al usar una url array en conjunción con requestAction() debe especificar todos
los parámetros que necesitará en la acción peticionada. Esto incluye parámetros
como $this->request->data. En adición a pasar todos los parámetros requeridos
los parámetros nombrados y de paso deben ser hechos en el 2do array.

Controller::loadModel(string $modelClass, mixed $id)
....................................................
La función loadModel() es provechosa cuando necesita usar un modelo que no es
el modelo por defecto del controlador ó su modelo asociado:

$this->loadModel(’Article’);
$recentArticles = 
  $this->Article->find(
    ’all’,
    array(
      ’limit’ => 5, 
      ’order’ => ’Article.created DESC’
    )
  );
$this->loadModel(’User’, 2);
$user = $this->User->read();

Atributos de Controlador
------------------------

propiedad Controller::$name
...........................
El atributo $name debería fijarse a el nombre del controlador. Esta es la forma
plural del modelo primario que usa el controlador. Esta propiedad puede omitirse,
pero salvaguarda a CakePHP de declinarla (inflecting):

// $name controller attribute usage example
class RecipesController extends AppController {
  public $name = ’Recipes’;
}

$components, $helpers y $uses
-----------------------------
Los próximos atributos controlador usados con más frecuencia le dicen a CakePHP
que  $helpers, $components, y modelos uno estará usando en conjunción con el
controlador actual. Usar estos atributos hace a las clases MVC dadas por $components
y $uses disponibles al controlador como variables de clase ($this->ModelName, 
por ej.) y aquellos dados por $helpers a la vista como una variable de referencia
a objeto ($this->{$helpername}).

Nota: cada controlador tiene alguna de estas clases disponibles por defecto, 
así uno puede no necesitar configurar su controlador para nada.

Propiedad Controller::$uses
...........................
Los controladores tienen acceso a su modelo primario disponible por defecto. 
Nuestro RecipesController tendrá la clase modelo Recipe disponible en $this->Recipe, 
y nuestro ProductsController ofrece también el modelo Product en $this->Product.
Pero, al permitir a un controlador acceder a modelos adicionales a través de
la variable $uses, el nombre del modelo controlador actual también debe ser 
incluído. Esto se ilustra en el ej. de abajo.

Si no desea usar un Model en su controlador, establecer public $uses = array().
Esto le permitirá usar un controlador sin necesidad de un archivo Model
correspondiente. Pero, los modelos definidos en el AppController aún serán 
cargados. Puede también usar false para no cargar ningún modelo. Aún aquellos
definidos en el AppController.

Cambiado en v.2.1: $uses tiene ahora un nuevo valor por defecto, este también 
maneja false de forma diferente.

Propiedad Controller::$helpers
..............................
El HtmlHelper, FormHelper, y SessionHelper están disponibles por defecto, 
ya que es el SessionComponent. Pero si uno elige definir su propio array $helpers
en AppController, asegurarse de incluir HtmlHelper y FormHelper si uno quiere
que ellos estén aún disponibles por defecto en sus Controllers. 

Se ve como decirle a un Controller CakePHP que uno planea usar clases MVC 
adicionales:

class RecipesController extends AppController {
  public $uses = array(’Recipe’, ’User’);
  public $helpers = array(’Js’);
  public $components = array(’RequestHandler’);
}

Cada una de estas variables son mergeadas con sus valores heredados, así no es
necesario (por ej.) redeclarar el FormHelper, ó cualquier cosa que está declarada
en su AppController.

Propiedad Controller::$components
.................................
El array components le permite fijar que Components usará un controlador. Como
los componentes $helpers y $uses en sus controladores son mergeados con aquellos
en AppController. Como con $helpers uno puede pasar ajustes (settings) en
$components.  

Otros atributos
---------------

property Controller::$cacheAction
.................................
El atributo cacheAction se usa para definir la duración y otra información sobre
el caching de página completa. 

property Controller::$paginate
..............................
El atributo paginate es un propiedad de compatibilidad deprecada. Usar esta 
carga y configura el PaginatorComponent. Se recomienda que actualice su código
para usar ajustes de componente normales:

class ArticlesController extends AppController {
  public $components = array(
    ’Paginator’ => array(
      ’Article’ => array(
        ’conditions’ => array(’published’ => 1)
      )
    )
  );
}

Mas sobre controladores
-----------------------

Objetos de petición y respuesta
...............................
Es nuevo en CakePHP 2.0. En versiones anteriores, estos objetos fueron representados
a través de arrays, y los métodos relacionados fueron expandidos a través de 
RequestHandlerComponent, Router, Dispatcher y Controller. No hubo objeto
autoritativo sobre que información contuvo la petición. Para 2.0, se usaron para
esto CakeRequest y CakeResponse.

CakeRequest
...........
Es el objeto de petición por defecto usado en CakePHP. Centraliza un número de
características para interrogar e interactuar con datos de petición. En cada
petición, es creado un CakeRequest y luego pasado por referencia a las capas 
varias de una aplicación que usa datos de petición. Por defecto, CakeRequest
es asignada a $this->request, y está disponible en Controllers, Views y Helpers.
Puede también acceder a este en Components usando la referencia controlador. 
Algunos deberes que realiza CakeRequest:

• Procesa arrays GET, POST, y FILES dentro de estructuras de datos con los que
  es familiar

• Provee introspección de ambiente perteneciente a la petición. Cosas como 
  los headers enviados, la dirección IP del cliente, y la información de
  subdominio / dominio sobre la aplicación que el servidor está corriendo

• Provee acceso a parámetros de request ambos como índices de array y propiedades
  de objeto

Acceder parámetros de request
.............................
CakeRequest expone varias interfaces para acceso de parámetros de request. El 
1ro usa propiedades de objeto, el 2do usa índices de array, y el 3ro usa 
$this->request->params:

$this->request->controller;
$this->request[’controller’];
$this->request->params[’controller’];

Todo lo de arriba accederá al mismo valor. Todos los elementos Route son accedidos
a través de esta interfaz.

Adicionalmente a los elementos Route, uno con frecuencia necesita acceso a 
'argumentos pasados' y 'parámetros Nombrados'.

// Passed arguments
$this->request->pass;
$this->request[’pass’];
$this->request->params[’pass’];

// named parameters
$this->request->named;
$this->request[’named’];
$this->request->params[’named’];

Todos estos le proveerán de acceso a los argumentos pasados y parámetros nombrados.
Hay varios parámetros que CakePHP usa internamente. Todos estos se encuentran
en los parámetros de request:

• plugin      El plugin que maneja la petición. Será null cuando no hay plugin
• controller  El controlador que maneja la petición actual
• action      La acción que maneja la petición actual
• prefix      El prefijo para la acción actual
• bare        Presente cuando la petición vino del requestAction() e incluyó la
              opción bare. Las peticiones bare no tienen layouts renderizados
• requested   Presente y puesto a true cuando la acción vino de requestAction()               

Acceder a parámetros Querystring
................................
Los parámetros de Querystring pueden leerse usando CakeRequest::$query:

// URL is /posts/index?page=1&sort=title
$this->request->query[’page’];

// You can also access it via an array
// Note: BC accessor, will be deprecated in future versions
$this->request[’url’][’page’];

Uno puede ya sea acceder directamente a la propiedad $query, ó puede usar
CakeRequest::query() para leer el array de consulta URL en una manera libre de
errores. Cuaquiera de las claves que no existen retornarán null:

$foo = $this->request->query(’value_that_does_not_exist’);
// $foo === null

Acceder a datos POST
....................
Todos los datos POST pueden ser accedidos usando CakeRequest::$data. Cualquier
dato de formulario que contiene un prefijo de datos tendrá ese prefijo de datos
removido. Ej.:

// An input with a name attribute equal to ’data[MyModel][title]’
// is accessible at
$this->request->data[’MyModel’][’title’];

Uno puede ya sea acceder directamente a la propiedad $data, ó puede usar
CakeRequest::data() para leer el array de datos de una manera libre de errores.
Cualquiera de las claves que no existan retornarán null:

$foo = $this->request->data(’Value.that.does.not.exist’);
// $foo == null

Acceder a datos PUT ó POST
..........................
Nuevo en v.2.2.

Al construir servicios REST, con frecuencia acepta datos de petición sobre peticiones
PUT y DELETE. En v.2.2, cualquier dato de cuerpo de la petición application/x-www-form-urlencoded 
será parseado automáticamente y fijado a $this->data para peticiones PUT y DELETE.

Acceder datos XML ó JSON
........................
Las aplicaciones que emplean REST con frecuencia intercambian datos en cuerpos
post no codificados por URL. Puede leer datos de entrada en cualquier formato
usando CakeRequest::input(). Proveyendo una función de decodificación, 
puede recibir el contenido en un formato deserializado:

// Get JSON encoded data submitted to a PUT/POST action
$data = $this->request->input(’json_decode’);

Algunos métodos de deserialización requieren parámetros adicionales cuando son
llamados, tales como el parámetro 'as array' en json_decode. Si uno quiere XML
convertido en un objeto DOMDocument, CakeRequest::input() soporta pasar también
parámetros adicionales:

// Get Xml encoded data submitted to a PUT/POST action
$data = $this->request->input(’Xml::build’, array(’return’ => ’domdocument’));

Acceder a información de ruta
.............................
CakeRequest también provee información sobre las rutas en su aplicación.
CakeRequest::$base y CakeRequest::$webroot son útiles para generar URL's, y
determinar si su aplicación está ó no en un subdirectorio.

Inspeccionar la petición
........................
Detectar varias condiciones de request solían requerir usar RequestHandlerComponent.
Estos métodos han sido movidos a CakeRequest, y ofrecen una interfaz nueva junto
a un uso más compatible hacia atrás:

$this->request->is(’post’);
$this->request->isPost(); // deprecated

Ambas llamadas a método retornarán el mismo valor. Actualmente, los métodos 
están deprecados. Puede extender los detectores de request que están disponibles
usando CakeRequest::addDetector() para crear clases de detectores nuevas. Hay 4 
tipos diferentes de detectores que uno puede crear:

• Comparación de valor de ambiente - Compara un valor extraído desde env() para
  equivalencia con el valor provisto

• Comparación de valor de patrón - Le permite comparar un valor extraído desde 
  env() para una expresión regular
    
• Comparación basada en opción - Usan una lista de opciones para crear una 
  expresión regular. Las llamadas posteriores a agregar un detector de opciones
  ya definido mergeará las opciones
    
• Detectores de callback - Le permiten proveer un tipo de 'callback' para manejar
  el chequeo. El callback recibirá el objeto request como su único parámetro
  
Algunos ej.'s serían:

// Add an environment detector.
$this->request->addDetector(
  ’post’,
  array(’env’ => ’REQUEST_METHOD’, ’value’ => ’POST’)
);

// Add a pattern value detector.
$this->request->addDetector(
  ’iphone’,
  array(’env’ => ’HTTP_USER_AGENT’, ’pattern’ => ’/iPhone/i’)
);

// Add an option detector.
$this->request->addDetector(’internalIp’, array(
  ’env’ => ’CLIENT_IP’,
  ’options’ => array(’192.168.0.101’, ’192.168.0.100’)
));

// Add a callback detector. Can either be an anonymous function
// or a regular callable.
$this->request->addDetector(
  ’awesome’,
  array(’callback’ => function ($request) {
    return isset($request->awesome);
  })
);

CakeRequest también incluye métodos como CakeRequest::domain(),
CakeRequest::subdomains() y CakeRequest::host() para ayudar en aplicaciones
con subdominios.

Hay varios detectores incorporados que puede usar:

• is(’get’) Chequea para ver si la petición actual es un GET.
• is(’put’) Chequea para ver si la petición actual es un PUT.
• is(’post’) Chequea para ver si la petición actual es un  POST.
• is(’delete’) Chequea para ver si la petición actual es un  DELETE.
• is(’head’) Chequea para ver si la petición actual es un  HEAD.
• is(’options’) Chequea para ver si la petición actual es un  OPTIONS.
• is(’ajax’) Chequea para ver si la petición actual vino con X-Requested-with = XmlHttpRequest.
• is(’ssl’) Chequea para ver si la petición es via SSL
• is(’flash’) Chequea para ver si la petición tiene un User-Agent de Flash
• is(’mobile’) Chequea para ver si la petición vino desde una lista común de agentes móviles

CakeRequest y RequestHandlerComponent
.....................................
Ya que varias de las características ofrecidos de CakeRequest solían ser del
reinado de RequestHandlerComponent. Para 2.0, RequestHandlerComponent proveen
una capa de azucar, tal como conmutar layouts y vistas basadas en contenido, 
en la parte superior de la utilidad que CakeRequest afronta.

Interactuar con otros aspectos del request
..........................................
Puede usar CakeRequest para instropección de una variedad de cosas sobre el
request. Mas allá de los detectores, puede también hallar otra información 
desde varias propiedades y métodos.

• $this->request->webroot contains the webroot directory.
• $this->request->base contains the base path.
• $this->request->here contains the full address to the current request.
• $this->request->query contains the query string parameters.

API CakeRequest 
---------------

clase CakeRequest
.................
CakeRequest encapsula instrospección y manejo de parámetro del request

CakeRequest::domain($tldLength = 1)
...................................
Retorna el nombre de dominio que está corriendo su aplicación

CakeRequest::subdomains($tldLength = 1)
.......................................
Retorna los subdominios que su aplicación está corriendo como un array

CakeRequest::host()
...................
Retorna el host de la aplicación que corre

CakeRequest::method()
.....................
Retorna el método HTTP con que fue hecho el request

CakeRequest::onlyAllow($methods)
................................
Fija métodos HTTP permitidos. Si no coincidió, arrojará MethodNotAllowedException. 
La respuesta 405 incluirá el header requerido Allow con los métodos pasados.

Nuevo en v.2.3

Deprecado en v.2.5: usar en vez de eso CakeRequest::allowMethod().

CakeRequest::allowMethod($methods)
..................................
Fija los métodos HTTP permitidos. Si no coincidió arrojará MethodNotAllowedException.
La respuesta 405 incluirá el header Allow requerido con los métodos pasados.

Nuevo en v.2.5.

CakeRequest::referer($local = false)
....................................
Retorna la dirección referida para la petición.

CakeRequest::clientIp($safe = true)
...................................
Retorna la dirección IP del visitante actual.

CakeRequest::header($name)
..........................
Le permite acceder a cualquiera de los headers HTTP_* que fueron usados para el
request. Ej.:
 
$this->request->header(’User-Agent’);

retornaría el user agent usado para el request.

CakeRequest::input($callback[, $options ])
..........................................
Recobra los datos de entrada para un request, y lo pasa opcionalmente a través 
de una función de decodificación. Útil al interactuar con el contenido del body
de la petición XML ó JSON. Los parámetros adicionales para la función de 
decodificación pueden pasarse como argumentos a input():

$this->request->input(’json_decode’);

CakeRequest::data($name)
........................
Provee acceso con notación de '.' a los datos de request. Permite a los datos
de request ser leídos y modificados. Las llamadas pueden ser encadenadas también 
en forma conjunta:
 
// Modify some request data, so you can prepopulate some form fields.
$this->request->data(’Post.title’, ’New post’)
  ->data(’Comment.1.author’, ’Mark’);

// You can also read out data.
$value = $this->request->data(’Post.title’);

CakeRequest::query($name)
.........................
Provee acceso de notación de '.' a los datos query de URL:

// URL is /posts/index?page=1&sort=title
$value = $this->request->query(’page’);

Nuevo en v.2.3.

CakeRequest::is($type)
......................
Chequear si un Request coincide ó no con cierto criterio. Usa reglas de detección
incorporadas así como cualquiera de las reglas adicionales definidas con 
CakeRequest::addDetector().
  
CakeRequest::addDetector($name, $options)
.........................................
Agrega un detector a ser usado con CakeRequest::is().

CakeRequest::accepts($type = null)
..................................
Halla que content types acepta el cliente, ó chequea si este acepta un tipo de
contenido particular.

Obtiene todos los tipos:

$this->request->accepts();

Chequea por un tipo único:

$this->request->accepts(’application/json’);

static CakeRequest::acceptLanguage($language = null)
....................................................
Obtiene todos los lenguajes aceptados por el cliente, ó chequea si es aceptado 
un lenguaje específico.

Obtiene la lista de lenguajes aceptados:

CakeRequest::acceptLanguage();

Chequea si es aceptado un lenguaje específico:

CakeRequest::acceptLanguage(’es-es’);

CakeRequest::param($name)
.........................
Lee valores de forma segura en $request->params. Esto quita la necesidad de
llamar a isset() ó empty() antes de usar los valores param.

Nuevo en v.2.4.

Propiedad CakeRequest::$data
............................
Un array de datos POST. Puede usar CakeRequest::data() para leer esta propiedad
en un modo que suprime los errores de notificación.

Propiedad CakeRequest::$query
.............................
Un array de parámetros de query string.

Propiedad CakeRequest::$params
..............................
Un array de elementos de ruta y parámetros de request.

Propiedad CakeRequest::$here
............................
Retorna la uri de request actual.

Propiedad CakeRequest::$base
............................
La ruta base a la aplicación, usualmente / a menos que su aplicación esté en un
subdirectorio.

property CakeRequest::$webroot
..............................
El webroot actual.

CakeResponse
------------
CakeResponse es la clase response por defecto en CakePHP. Este encapsula un número
de características y funcionalidad para generar respuestas HTTP en su aplicación.
Este encapsula un número de características y funcionalidad para generar 
respuestas HTTP en su aplicación. Este también ayuda en testeo, ya que puede 
ser mocked/stubbed permitiendo a uno inspeccionar los headers que serán 
enviados. Como CakeRequest, CakeResponse consolida un número de métodos 
anteriormente hallados en Controller, RequestHandlerComponent y Dispatcher.

CakeResponse provee una interfaz para envolver las tareas comunes relacionadas
a la respuesta como:

• Enviar headers para redireccionamiento.
• Enviar headers de content type.
• Enviar cualquier header.
• Enviar el body de respuesta.

Cambiar la clase response
-------------------------
CakePHP usa CakeResponse por defecto. CakeResponse es una clase transparente y
flexible. Si necesita redefinirla con su propia clase específica de la aplicación,
puede reemplazar CakeResponse en app/webroot/index.php. Esto hará que todos los
controladores en su aplicación usen CustomResponse en vez de CakeResponse. Puede
también reemplazar la instancia de respuesta ajustando $this->response en sus
controladores. Redefinir el objeto response es útil en testing, ya que le 
permite un stub out de métodos que interactúan con header().

Tratar con content types
------------------------
Puede controlar el Content-Type de sus respuestas de aplicación con CakeResponse::type().
Si su aplicación necesita tratar con content types que no están construidos dentro
de CakeResponse, puede mapearlos también con CakeResponse::type():

// Add a vCard type
$this->response->type(array(’vcf’ => ’text/v-card’));

// Set the response Content-Type to vcard.
$this->response->type(’vcf’);

Usualmente, uno querrá mapear content types adicionales en su callback de controlador 
beforeFilter(), así uno puede impulsar las características de conmutación de 
vista automáticas de RequestHandlerComponent si uno lo está usando.

Enviar archivos
---------------
Hay veces que uno quiere enviar archivos como respuestas para sus requests. 
Anterior a v.2.3, puede usar MediaView. Desde v.2.3, use CakeResponse::file() en
su lugar para enviar un archivo como respuesta:

public function sendFile($id) {
  $file = $this->Attachment->getFile($id);
  $this->response->file($file[’path’]);
  // Return response object to prevent controller from trying to render
  // a view
  return $this->response;
}

Del ej. de arriba, debe pasar la ruta de archivo al método. CakePHP enviará
un header de content type apropiado si este es un tipo de archivo conocido 
listado en CakeResponse::$_mimeTypes. Puede agregar tipos nuevos antes de llamar
a CakeResponse::file() usando el método CakeResponse::type().

Si quiere, puede también forzar un archivo para ser descargado en vez de 
ser exhibido en el navegador especificando las opciones: 

$this->response->file(
  $file[’path’],
  array(’download’ => true, ’name’ => ’foo’)
);

Enviar un string como archivo
-----------------------------
Puede responder con un archivo que no existe en el disco, tal como un pdf ó un
ics generado al vuelo desde un string:

public function sendIcs() {
  $icsString = $this->Calendar->generateIcs();
  $this->response->body($icsString);
  $this->response->type(’ics’);
  //Optionally force file download
  $this->response->download(’filename_for_download.ics’);
  // Return response object to prevent controller from trying to render a view
  return $this->response;
}

Ajustar headers
---------------
El ajuste de parámetro es hecho con el método CakeResponse::header(). Este puede
ser llamado con algunas configuraciones de parámetros:

// Set a single header
$this->response->header(’Location’, ’http://example.com’);

// Set multiple headers
$this->response->header(array(
  ’Location’ => ’http://example.com’,
  ’X-Extra’ => ’My header’
));

$this->response->header(array(
  ’WWW-Authenticate: Negotiate’,
  ’Content-type: application/pdf’
));

Ajustar el mismo header() en múltiples ocasiones resultará en sobreescribir 
los valores anteriores, así como lo hacen las llamadas a header regulares. Los
headers no son enviados cuando es llamado CakeResponse::header(); en vez de eso
estos son buffered hasta que la respuesta es verdaderamente enviada.

Nuevo en v.2.4.

Puede ahora usar el método de conveniencia CakeResponse::location() para fijar
ú obtener el header de localización de redirección.

Interactuar con cacheo de navegador
-----------------------------------
Puede a veces necesitar forzar a los navegadores a no cachear los resultados de
una acción controlador. Para esto se usa CakeResponse::disableCache():

public function index() {
  // do something.
  $this->response->disableCache();
}

Advertencia: Usar disableCache() con descargas desde dominios SSL mientras intenta
enviar archivos a IE puede resultar en errores.

Puede también decirle a los clientes que quiere que ellos cacheen las respuestas.
Usando CakeResponse::cache():

public function index() {
  //do something
  $this->response->cache(’-1 minute’, ’+5 days’);
}

Lo de arriba le diría a los clientes a cachear la respuesta resultante por 5 días,
acelerando la experiencia de velocidad de su visitante. CakeResponse::cache()
fija al valor Last-Modified al 1er argumento. El header Expires y la directiva 
max-age son fijadas basadas en el 2do parámetro. También es seteada la directiva
public de Cache-Control.

Sintonía fina de cache HTTP
---------------------------
Esto ayuda a acelerar su aplicación. Bajo este modelo de cacheo, solo se requiere
que ayude a los clientes a decidir si ellos deberían usar una copia cacheada de
la respuesta ajustando algunos headers tales como tiempo modificado y etiqueta
entidad de respuesta.

En vez de forzar a uno a codificar la lógica para cacheo y para invalidarlo 
(refrescar) una vez que los datos han cambiado, HTTP usa 2 modelos, expiración y
validación.

Aparte de usar CakeResponse::cache(), puede también usar algunos otros métodos
para headers de caché HTTP de sintonía fina para tomar ventaja del navegador ó 
cacheo de proxy inverso.

El header Cache Control 
.......................

Nuevo en v.2.1.

Usado bajo el modelo de expiración, este header contiene indicadores múltiples
que pueden cambiar el modo en que los navegadores ó proxies usan el contenido
cacheado. Un header Cache-Control puede lucir como:

Cache-Control: private, max-age=3600, must-revalidate

La clase CakeResponse le ayuda a fijar este header con algunos métodos que 
producirán un header Cache-Control válido. El 1ro es CakeResponse::sharable(). que
indica si una respuesta es considerada compartible a través de usuarios ó clientes
diferentes. Este método verdaderamente controla la parte private ó public de 
este header. Fijar una respuesta como private indica que todas las partes de 
esta es pretendida para un único usuario. Para tomar ventaja de caches compartidos,
la directiva control debe fijarse como public.

El 2do parámetro de este método se usa para especificar un max-age para la caché,
que es el número de segundos después del cual la respuesta ya no es considerada
fresca:

public function view() {
  ...
  // set the Cache-Control as public for 3600 seconds
  $this->response->sharable(true, 3600);
}

public function my_data() {
  ...
  // set the Cache-Control as private for 3600 seconds
  $this->response->sharable(false, 3600);
}

CakeResponse expone métodos separados para ajustar cada una de las directivas
en el header Cache-Control.

Header de expiración
--------------------
Nuevo en v.2.1.

Puede fijar el header Expires a un tiempo y hora después del cual la respuesta
ya no es considerada fresca. Este header puede fijarse usando el método
CakeResponse::expires():

public function view() {
  $this->response->expires(’+5 days’);
}

Este método también acepta una instancia DateTime ó cualquier string que puede
ser parseado por la clase DateTime.

El header Etag
--------------
Nuevo en v.2.1.

La validación de caché en HTTP se usa con frecuencia cuando el contenido está
cambiando constantemente, y le pide a la aplicación sólo generar los contenidos
de respuesta si la cache no está más fresca. Bajo este modelo, el cliente 
continúa almacenando páginas en la caché, pero esta le pregunta a la aplicación
cada vez si el recurso ha cambiado, en vez de usarlo directamente. Esto se usa
comunmente con recursos estáticos tales como imágenes y otros haberes.

El método etag() (llamado entity tag) es un string que identifica únicamente 
el recurso peticionado, como un checksum lo hace para un archivo, para determinar
si este coincide con un recurso cacheado. 

Para tomar ventaja de este header, debe ya sea llamar al método
CakeResponse::checkNotModified() manualmente ó incluir el RequestHandlerComponent 
en su controlador:

public function index() {
  $articles = $this->Article->find(’all’);
  $this->response->etag($this->Article->generateHash($articles));
  if ($this->response->checkNotModified($this->request)) {
    return $this->response;
  }
  ...
}

El header Last Modified
-----------------------

Nuevo en v.2.1.

Bajo el modelo de validación de cache HTTP, puede también fijar el header
Last-Modified para indicar la hora y tiempo en que el recurso fue modificado
por última vez. Enviar este header le ayuda a CakePHP a decir a los clientes
de cacheo si la respuesta fue modificada ó no basada en sus caches.

Para tomar ventaja de este header, debe ya sea llamar manualmente al método
CakeResponse::checkNotModified() ó incluir el RequestHandlerComponent en su
controlador:

public function view() {
  $article = $this->Article->find(’first’);
  $this->response->modified($article[’Article’][’modified’]);
  if ($this->response->checkNotModified($this->request)) {
    return $this->response;
  }
  ...
}

El header Vary 
--------------
En algunos casos, puede querer servir un contenido diferente usando la misma URL.
Este es con frecuencia el caso de que uno tiene una página multilingue ó responde
con un HTML diferente dependiendo del navegador. Bajo algunas circunstancias
puede usar el header Vary: 

$this->response->vary(’User-Agent’);
$this->response->vary(’Accept-Encoding’, ’User-Agent’);
$this->response->vary(’Accept-Language’);

CakeResponse y testeo
---------------------
Uno sólo tiene que hacer un mock de un único objeto, ya que los controladores y
componentes delegan a CakeResponse. Esto le ayuda a acercarse a un unit test y
facilita el testeo de controladores:

public function testSomething() {
  $this->controller->response = $this->getMock(’CakeResponse’);
  $this->controller->response->expects($this->once())->method(’header’);
  // ...
}

Adicionalmente, puede correr testeos desde la línea de comandos fácilmente, ya
que puede usar mocks para evitar errores de 'headers enviados' que pueden 
ocurrir cuando intenta fijar headers en CLI.

API CakeResponse 
----------------

clase CakeResponse
------------------

CakeResponse::header($header = null, $value = null)
...................................................
Le permite a uno fijar directamente uno ó más headers a ser enviados con el 
response.

CakeResponse::location($url = null)
...................................
Le permite fijar directamente el header de ubicación de redirección a ser enviado
con la respuesta:

// Set the redirect location
$this->response->location(’http://example.com’);

// Get the current redirect location header
$location = $this->response->location();

Nuevo en v.2.4.

CakeResponse::charset($charset = null)
......................................
Fija el charset que será usado en la respuesta.

CakeResponse::type($contentType = null)
.......................................
Fija el content type de la respuesta. Puede usar ya sea un alias de content type
conocido ó el nombre de content type completo.

CakeResponse::cache($since, $time = ‘+1 day’)
.............................................
Le permite fijar los headers de cacheo en la respuesta.

CakeResponse::disableCache()
............................
Permite a los headers inhabilitar el cacheo de cliente para la respuesta.

CakeResponse::sharable($public = null, $time = null)
....................................................
Fija el header Cache-Control para ser ya sea público ó privado y opcionalmente
fija una directiva max-age del recurso.

Nuevo en v.2.1.

CakeResponse::expires($time = null)
...................................
Permite al header Expires ser fijado a una fecha específica.

Nuevo en v.2.1.

CakeResponse::etag($tag = null, $weak = false)
..............................................
Fija el header Etag para identificar únicamente un recurso de respuesta.

Nuevo en v.2.1.

CakeResponse::modified($time = null)
....................................
Fija el header Last-Modified a una fecha y hora específica en el formato 
correcto.

Nuevo en v.2.1.

CakeResponse::checkNotModified(CakeRequest $request)
....................................................
Compara los headers de cache para el objeto request con el header de cache desde
la respuesta y determina si este puede aún ser considerado fresco. Si es así,
borra el contenido del response, y envía el 304 'header no modificado'.

Nuevo en v.2.1.

CakeResponse::compress()
........................
Enciende compresión GZIP para el request.

CakeResponse::download($filename)
.................................
Le permite enviar una respuesta como un adjunto, y establece su nombre de archivo.

CakeResponse::statusCode($code = null)
......................................
Le permite fijar el código de estado de la respuesta.

CakeResponse::body($content = null)
...................................
Fija el cuerpo de contenido de la respuesta.

CakeResponse::send()
....................
Una vez que ha terminado de crear una respuesta, llamar a send() enviará todo el
set de headers así como el cuerpo. Este es hecho automáticamente al final de 
cada request por Dispatcher.

CakeResponse::file($path, $options = array())
.............................................
Le permite fijar el header Content-Disposition de un archivo ya sea para exhibir
ó para descargar.

Nuevo en v.2.3.

Scaffolding
-----------
Deprecado desde v.2.5: el scaffolding dinámico será quitado y reemplazado en 3.0.

Un scaffolding de aplicación es una técnica que le permite a un desarrollador
definir y crear una aplicación básica que puede crear, recobrar, actualizar y 
borrar objetos. Scaffolding en CakePHP también permite a los desarrolladores
definir como los objetos son relacionados el uno al otro, y para crear y 
romper aquellos enlaces.

Todo lo que se necesita para crear un scaffold es un modelo y su controlador. 
Una vez que uno ha fijado la variable $scaffold en el controlador, está listo.

El scaffolding de CakePHP le permite obtener una aplicación CRUD básica andando
en minutos.

Scaffolding permite obtener la primeras partes de desarrollo al arrancar una
aplicación web. Los 1ros schemas de DB están sujetos a cambios, que es normal 
en la 1ra parte del proceso de diseño. Scaffolding analiza sus tablas de DB
y crea listas estándar con botones 'agregar', 'editar' y 'borrar', formularios
estandar para editar y vistas estandar para inspeccionar un único item en la DB.

Para agregar scaffolding a su aplicación, en el controlador, agregar la variable
$scaffold:

class CategoriesController extends AppController {
  public $scaffold;
}

Asumiendo que uno ha creado aún el archivo de clase modelo básico Category 
(en app/Model/Category.php) ya está lista para arrancar. Visite 
http://example.com/categories para ver su nuevo scaffolding.

Nota: Crear métodos en controladores pueden causar resultados no buscados. Ej.:
si uno crea un método index() en un controlador scaffolded, su método index será
renderizado en vez de la funcionalidad de scaffolding.

Scaffolding es consciente de asociaciones del modelo; así, si su modelo Category 
belongsTo User, uno verá User IDs en los listados Category. Mientras que 
scaffolding sabe sobre asociaciones del modelo, no verá ninguno de los registros
relacionados en las vistas scaffold hasta que uno agregue manualmente el código
de asociación al modelo. Ej.: si Group hasMany User y User belongsTo Group, uno
tiene que agregar manualmente el siguiente código a sus modelos User y Group.

Antes de hacerlo, la vista exhibe un input de selección vacío para Group en
el formulario de Nuevo Usuario; después - populado con ID's ó nombres desde la
tabla Group en el formulario Nuevo Usuario:

// In Group.php
public $hasMany = ’User’;

// In User.php
public $belongsTo = ’Group’;

Si uno prefiere ver algo además de una ID (como el 1er nombre del usuario), puede
fijar la variable $displayField en el modelo. Vamos a fijar la variable $displayField
en nuestra clase User tal que los usuarios relacionados a categorías serán 
mostrados por el 1er nombre en vez de sólo por el ID en scaffolding. Esta 
característica hace al scaffolding más legible:

class User extends AppModel {
  public $displayField = ’first_name’;
}

Crear una interfaz admin única con scaffolding
----------------------------------------------
Si ha habilitado enrutamiento admin en su app/Config/core.php con 
Configure::write(’Routing.prefixes’, array(’admin’));, puede usar scaffolding
para generar una interfaz admin.

Una vez que ha habilitado enrutamiento admin, asignar su prefijo admin a la
variable scaffolding:

public $scaffold = ’admin’;

Ahora será capaz de acceder a las acciones scaffolded admin:

http://example.com/admin/controller/index
http://example.com/admin/controller/view
http://example.com/admin/controller/edit
http://example.com/admin/controller/add
http://example.com/admin/controller/delete

Este es un modo de crear una interfaz simple de backend de forma rápida. Uno
no puede tener ambos métodos admin y non-admin scaffolded al mismo tiempo. 
Puede redefinir métodos individuales y reemplazarlos con los propios:

public function admin_view($id = null) {
  // custom code here
}

Una vez que ha reemplazado una acción scaffolded, necesitará crear también un
archivo de vista para la acción.

Personalizar Vistas Scaffold
----------------------------

If you’re looking for something a little different in your scaffolded views, you can create templates.

Custom scaffolding views for a specific controller (PostsController in this example) should be placed like
so:

app/View/Posts/scaffold.index.ctp
app/View/Posts/scaffold.form.ctp
app/View/Posts/scaffold.view.ctp

Custom scaffolding views for all controllers should be placed like so:

app/View/Scaffolds/index.ctp
app/View/Scaffolds/form.ctp
app/View/Scaffolds/view.ctp

El Controller Pages
-------------------
CakePHP se embarca con un controlador por defecto PagesController.php. Este es un
controlador opcional para servir contenido estático. La página de inicio que 
uno ve después de la instalación es generada usando este controlador.  

Si hace el archivo de vista app/View/Pages/about_us.ctp puede accederlo usando la
url http://example.com/pages/about_us. Uno es libre de modificar el Controller
Pages para cumplir con sus necesidades.

Al hornear ('bake') una aplicación usando la utilidad consola de CakePHP el 
Controller Pages es creado en su carpeta app/Controller/. Puede también copiar
el archivo desde lib/Cake/Console/Templates/skel/Controller/PagesController.php.

Con CakePHP 2.0 el Controller Pages fue parte de lib/Cake. Desde 2.1 el Controller
Pages ya no es parte del núcleo pero se envía en la carpeta app.

Components
----------
Los Components son paquetes de lógica que son compartidos entre controladores.
Puede también crear sus propios componentes. Si se halla a uno mismo buscando
copiar y pegar cosas entre controladores, debería considerar crear su propio
componente para contener la funcionalidad.

Configurar Components
---------------------
Algunos de los componentes núcleo requieren configuración. Algunos ejemplos de
componentes que requieren configuración son Authentication y Cookie. La
configuración para estos componentes, y para componentes en general, es hecho en
el array $components de su método de controlador beforeFilter():

class PostsController extends AppController {
  public $components = array(
    ’Auth’ => array(
      ’authorize’ => array(’controller’),
      ’loginAction’ => array(
        ’controller’ => ’users’,
        ’action’ => ’login’
      )
    ),
    ’Cookie’ => array(’name’ => ’CookieMonster’)
  );

El fragmento previo de código sería un ejemplo de configurar un componente con
el array $components. Todos los componentes núcleo permiten que sus ajustes de
configuración se fijen de este modo. También puede configurar componentes en
su método beforeFilter() del controlador. Esto es útil cuando necesita asignar
los resultados de una función a una propiedad component. Lo de arriba podría
ser expresado como:  

public function beforeFilter() {
  $this->Auth->authorize = array(’controller’);
  $this->Auth->loginAction = array(
    ’controller’ => ’users’,
    ’action’ => ’login’
  );
  $this->Cookie->name = ’CookieMonster’;
}

Es posible que un componente requiera ciertas opciones de configuración para ser
fijadas antes que corra beforeFilter() del controlador. Para este fin, algunos
componentes permiten que se fijen opciones de configuración en el array 
$components:

public $components = array(
  ’DebugKit.Toolbar’ => array(’panels’ => array(’history’, ’session’))
);

Una configuración común a usar es la opción className, que le permite a uno
alias de componentes. Esta característica es útil cuando quiere reemplazar 
$this->Auth ú otra referencia Component común con una implementación personalizada:

// app/Controller/PostsController.php
class PostsController extends AppController {
  public $components = array(
    ’Auth’ => array(
      ’className’ => ’MyAuth’
    )
  );
}

// app/Controller/Component/MyAuthComponent.php
App::uses(’AuthComponent’, ’Controller/Component’);
class MyAuthComponent extends AuthComponent {
  // Add your code to override the core AuthComponent
}

Lo de arriba haría un alias MyAuthComponent a $this->Auth en sus controladores.

Note: Aliasing a component replaces that instance anywhere that component is used, including inside other
Components.

Usar Components
---------------
Una vez que ha incluido algunos componentes en su controlador, cada componente que
uno usa es expuesto como una propiedad en su controlador. Si uno ha grabado el
SessionComponent y el CookieComponent en su controlador, los podría acceder como:

class PostsController extends AppController {
  public $components = array(’Session’, ’Cookie’);
  public function delete() {
    if ($this->Post->delete($this->request->data(’Post.id’)) {
      $this->Session->setFlash(’Post deleted.’);
      return $this->redirect(array(’action’ => ’index’));
    }
  }

Nota: Ya que ambos Models y Components son agregados a Controllers como propiedades
ellos comparten el mismo ‘namespace’. Asegúrese de no dar a un componente y a un
modelo el mismo nombre.

Cargar componentes al vuelo
---------------------------
Puede no necesitar todos sus componentes disponibles en cada acción controlador.
En situaciones como esta uno puede cargar un componente en tiempo de ejecución
usando Component Collection. Desde dentro de un método de controlador uno 
puede hacer lo siguiente:

$this->OneTimer = $this->Components->load(’OneTimer’);
$this->OneTimer->getTime();

Nota: Cargar un componente al vuelo no llamará a su método initialize. Si el 
componente que uno está llamando tiene este método necesitará llamarlo 
manualmente después de cargarlo.

Callbacks Component 
-------------------
Los Components también ofrecen algunos callbacks de request de ciclo de vida que
les permiten aumentar el ciclo de request. 

Crear un Component
------------------
Suponer que nuestra aplicación online necesita realizar una operación matemática
compleja en varias partes de la aplicación. Podríamos crear un componente para
hospedar esta lógica compartida para usarse en varios controladores diferentes.

Lo 1ro es crear un archivo y clase componente nuevo. Crear el archivo en 
app/Controller/Component/MathComponent.php. Estructura básica para el componente:

App::uses(’Component’, ’Controller’);
class MathComponent extends Component {
  public function doComplexOperation($amount1, $amount2) {
    return $amount1 + $amount2;
  }
}

Nota: Todos los componentes deben extender Component. Fallar en hacer esto
gatillará una excepción.

Incluir su componente en sus controladores
------------------------------------------
Finalizado nuestro componente, podemos usarlo en controladores de la aplicación
poniendo el nombre del componente (sin la parte 'Component') en el array de 
controlador $components. El controlador se le dará automáticamente un atributo
nombrado después el componente, a través del cual podemos acceder a una instancia
de éste:

/* Make the new component available at $this->Math, as well as the standard $this->Session */
public $components = array(’Math’, ’Session’);

Los componentes declarados en AppController serán mergeados con aquellos en sus
otros controladores. Así no hay necesidad de redeclarar el mismo componente 2 veces.

Al incluir Components en un Controller puede también declarar un set de parámetros
que serán pasados al constructor de Component. Estos parámetros pueden luego ser
manejados por Component:

public $components = array(
  ’Math’ => array(
    ’precision’ => 2,
    ’randomGenerator’ => ’srand’
  ),
  ’Session’, ’Auth’
);

Lo de arriba pasaría el array que contiene precision y randomGenerator a 
MathComponent::__construct() como el 2do parámetro. Por convención, si las claves
de array coinciden con las propiedades public del componente, las propiedades
se fijarán a los valores de estas claves.

Usar otros Components en su Component
-------------------------------------
A veces uno de sus componentes puede necesitar usar otro componente. En este caso
puede incluir otros componentes en su componente del mismo modo que puede incluirlos
en controladores - usando la variable $components:

// app/Controller/Component/CustomComponent.php
App::uses(’Component’, ’Controller’);
class CustomComponent extends Component {
  // the other component your component uses
  public $components = array(’Existing’);
  public function initialize(Controller $controller) {
    $this->Existing->foo();
  }
  public function bar() {
    // ...
  }
}

// app/Controller/Component/ExistingComponent.php
App::uses(’Component’, ’Controller’);
class ExistingComponent extends Component {
  public function foo() {
    // ...
  }
}

Nota: En contraste a un componente incluido en un controlador no serán disparados
callbacks sobre un componente del componente.

API de Component
----------------

clase Component
...............
La clase base Component ofrece algunos métodos para cargar de forma 'perezosa'
otros Components a través de ComponentCollection así como tratar con manejo 
común de ajustes. Esto también provee prototipos para todos los callbacks de 
componente.

Component::__construct(ComponentCollection $collection, $settings = array())
............................................................................
Constructor para la clase base componente. Todos los $settings que son también
propiedades public tendrán sus valores cambiados al valor coincidente en 
$settings.

Callbacks
---------
Component::initialize(Controller $controller)
.............................................
Es llamado antes del método beforeFilter del controlador.

Component::startup(Controller $controller)
..........................................
Es llamado después del método beforeFilter del controlador pero antes que el 
controlador ejecute el manejo de la acción actual.

Component::beforeRender(Controller $controller)
...............................................
Es llamado después que el controlador ejecute la lógica de acción peticionada,
pero antes que las renderizaciones de vistas y layout del controlador.

Component::shutdown(Controller $controller)
...........................................
Es llamado antes que la salida sea enviada al navegador.

Component::beforeRedirect(Controller $controller, $url, $status=null, $exit=true)
.................................................................................
Es invocado cuando el método redirect del controlador es llamado pero antes que
cualquier acción adicional. Si este método retorna false el controlador no 
continuará la redirección de la petición. Las variables $url, $status y $exit
tienen el mismo significado que para el método del controlador. Uno puede también
retornar un string el cual será interpretado como la URL a redireccionar ó 
retorna un array asociativo con la clave 'url' y opcionalmente 'status' y 'exit'.