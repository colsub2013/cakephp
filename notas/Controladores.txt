CONTROLADORES
=============
Un controlador suele usarse para gestiona la lógica alrededor de un modelo único.
Ej.: si uno construye un sitio para una panadería (bakery) online, uno puede tener
un RecipesController que gestione sus recetas y un IngredientsController que 
gestione sus ingredientes. Se pueden tener también controladores que funcionen con
más de un modelo. En CakePHP, un controlador se nombra después del modelo primario
que maneja.

Sus controladores de aplicación extienden la clase AppController, que extiende
la clase Controller núcleo. La clase AppController puede definirse en  
/app/Controller/AppController.php y este debería contener métodos que son 
compartidos entre todos los controladores de su aplicación.

Los controladores proveen un número de métodos que manejan peticiones. Estas son
llamadas acciones. Por defecto, cada método público en un controlador es una
acción, y es accesible desde una URL. Una acción es responsable de interpretar
la petición y crear la respuesta. Usualmente las respuestas están en la forma
de vista renderizada, pero también hay otros modos de crear respuestas.
................................................................................

El App Controller
-----------------
La clase AppController es la clase padre de todos sus controladores de aplicación.
AppController mismo extiende la clase Controller incluída en la librería núcleo
de CakePHP. AppController está definia en /app/Controller/AppController.php como
sigue:  

class AppController extends Controller {
}

Los atributos y métodos Controller creados en su AppController estarán disponibles
para todos sus controladores de la aplicación. 

Mientras que las reglas de herencia orientadas a objeto normales aplican, CakePHP
hace trabajo adicional cuando se vienen atributos controlador especiales. Para los 
componentes y helpers usados por un controlador, los arrays de valor AppController
son mergeados con arreglos de clase controlador hijos. Los valores en la clase
hijo siempre redefinirán aquellos en AppController.  

Nota: CakePHP mergea las siguientes variables desde el AppController en sus controladores
de aplicación:

• $components
• $helpers
• $uses

Hay que agregar los helpers de formulario y Html por defecto si uno define la
propiedad $helpers en su AppController.

También llamar a los callbacks de AppController dentro de los callbacks controlador
hijos para mejorar los resultados:

public function beforeFilter() {
  parent::beforeFilter();
}

Parámetros de request
---------------------
Cuando es hecha una petición a una aplicación CakePHP, las clases Router y Dispatcher
de CakePHP usan la configuración de Enrutamiento para hallar y crear el controlador
correcto. Los datos de petición son encapsulados en un objeto request. CakePHP 
pone toda la información de request importante en la propiedad $this->request.

Acciones Controller
-------------------
Las acciones Controller son responsables de convertir los parámetros de petición 
en una respuesta para el usuario / navegador que hace la petición. CakePHP usa
convenciones para automatizar este proceso y quitar algún código repetitivo
que de otro modo necesitaría escribir.

Por convención, CakePHP renderiza una vista con una versión inclinada del nombre
de acción. Volviendo al ej. de la panadería online, nuestro RecipesController 
puede contener las acciones view(), share(), y search(). El controlador 
estaría ubicado en /app/Controller/RecipesController.php y contiene:   

# /app/Controller/RecipesController.php
class RecipesController extends AppController {
  public function view($id) {
    //action logic goes here..
  }
  
  public function share($customerId, $recipeId) {
    //action logic goes here.. 
  }
  
  public function search($query) {
    //action logic goes here..
  }
}

Los archivos de vista para estas acciones serían app/View/Recipes/view.ctp,
app/View/Recipes/share.ctp, y app/View/Recipes/search.ctp. El nombre de archivo
de vista convencional es la versión en minúsculas y subrayada del nombre de 
acción.

Las acciones Controller usan generalmente set() para crear un contexto que usa View
para renderizar la vista. Debido a la convención que usa CakePHP, no necesita
crear y renderizar la vista manualmente. En vez de eso, una vez que la acción 
controlador se ha completado, CakePHP manejará la renderización y entregará la
View. 

Si uno quiere esquivar el comportamiento por defecto la cual es hacer un desvío
de la renderización de vista.

. Si retorna un string, o un objeto que puede ser convertido a un string desde su
acción controlador, este será usado como el cuerpo de respuesta

. Puede retornar un objeto CakeResponse con la respuesta creada completamente

Cuando uno usa métodos controlador con requestAction(), con frecuencia querrá
retornar datos que no son un string. Si tiene métodos controlador que son usados
para peticiones web normales + requestAction, debería chequear el tipo de 
petición antes de retornar:

class RecipesController extends AppController {
  public function popular() {
    $popular = $this->Recipe->popular();
    if (!empty($this->request->params[’requested’])) {
      return $popular;
    }
    $this->set(’popular’, $popular);
  }
}

La acción controlador de arriba es un ej. de como puede usarse un método con
requestAction() y peticiones normales. Retornar datos de array a una petición
no-requestAction causará errores y debería evitarse.
................................................................................
Callbacks de petición Ciclo de vida
-----------------------------------
Clase Controller
................
Los controladores CakePHP vienen ajustados con callbacks que puede usar para 
insertar lógica sobre la petición del ciclo de vida:
 
Controller::beforeFilter()

Esta función es ejecutada antes de cada acción en el controlador. Es bueno 
chequear por una sesión activa ó inspeccionar permisos de usuario.

Note: The beforeFilter() method will be called for missing actions, and scaffolded actions.

Controller::beforeRender()

Llamado después de la lógica acción controlador, pero antes que la vista sea
renderizada. Este callback no se usa con frecuencia, pero pueden ser necesario
si uno llama manualmente a render() antes de finalizar una acción dada.

Controller::afterFilter()

Llamado después de cada acción controlador, y después que se completa la renderización.
Este es el último método controlador a ejecutar.

En adición a callbacks controlador de ciclo de vida, los componentes también
proveen un set similar de callbacks.

Métodos Controlador
-------------------
Interacción con Views
.....................
Los controladores interactúan con vistas en varias formas. Primero, son capaces
de pasar datos a las vistas, usando set(). Puede también decidir que clase de 
vista usar, y que archivo de vista debería ser renderizado desde el controlador.
 
Controller::set(string $var, mixed $value)

El método set() es el modo principal de enviar datos desde su controlador a su
vista. Usado set(), la variable puede ser accedida en su vista:

// Primero pasar datos desde el controlador:
$this->set(’color’, ’pink’);
// Luego, en la vista puede utilizar los datos:
?>
You have selected <?php echo $color; ?> icing for the cake.

El método set() también toma un array asociativo como su primer parámetro. Esto
puede con frecuencia un modo rápido de asignar un set de información a la vista:

$data = array(
  ’color’ => ’pink’,
  ’type’ => ’sugar’,
  ’base_price’ => 23.95
);
// make $color, $type, and $base_price available to the view:

$this->set($data);

El atributo $pageTitle ya no existe. Usar set() para fijar el título:

$this->set(’title_for_layout’, ’This is the page title’);

Controller::render(string $view, string $layout)

El método render() es llamado automáticamente al final de cada acción controlador
peticionada. Este método realiza toda la lógica de vista (usando los datos que ha
enviado usando el método set()), pone la vista dentro de su $layout, y lo sirve
de vuelta al usuario final.  

La archivo vista por defecto usado para renderizar es determinado por convención.
Si es peticionada la acción search() del RecipesController, el archivo de vista
en /app/View/Recipes/search.ctp será renderizado:

class RecipesController extends AppController {
  // ...
  public function search() {
    // Render the view in /View/Recipes/search.ctp
    $this->render();
  }
  // ...
}

Aunque CakePHP lo llamará automáticamente después de cada lógica de la acción
(a menos que haya seteado $this->autoRender a false), puede usarlo para especificar
un archivo de vista alternativo especificando un nombre de acción en el controlador
usando $action.

Si $view comienza con ‘/’, se asume ser una archivo elemento ó vista relativo a 
la carpeta /app/View. Esto permite renderización directa de elementos, muy útil
en llamadas AJAX.

// Renderiza el elemento en /View/Elements/ajaxreturn.ctp
$this->render(’/Elements/ajaxreturn’);

El parámetro $layout le permite especificar el layout con el cual se renderiza
la vista.

Renderizar una vista específica
...............................
En su controlador, puede querer renderizar una vista diferente que la convencional.
Puede hacer esto llamando directamente a render(). Una vez que ha llamado a 
render(), CakePHP no intentará re-renderizar la vista:

class PostsController extends AppController {
  public function my_action() {
    $this->render(’custom_file’);
  }
}

Esto renderizaría app/View/Posts/custom_file.ctp en vez de 
app/View/Posts/my_action.ctp

Puede también renderizar vistas dentro de plugins usando la sintaxis:
$this->render(’PluginName.PluginController/custom_file’). Ej.:

class PostsController extends AppController {
  public function my_action() {
    $this->render(’Users.UserDetails/custom_file’);
  }
}

Esto renderizaría app/Plugin/Users/View/UserDetails/custom_file.ctp

Control de flujo
----------------
Controller::redirect(mixed $url, integer $status, boolean $exit)
################################################################
El método control de flujo que usará con mayor frecuencia es redirect(). Este 
método toma su primer parámetro en la forma de una URL relativa de CakePHP. 
Cuando un usuario ha hecho una orden exitosamente, puede desear redireccionarlas
a una pantalla de recepción:

public function place_order() {
  // La lógica para finalizar la orden va aquí
  if ($success) {
    return $this->redirect(
      array(’controller’ => ’orders’, ’action’ => ’thanks’)
    );
  }
  return $this->redirect(
    array(’controller’ => ’orders’, ’action’ => ’confirm’)
  );
}

Puede también usar una URL absoluta ó relativa como el argumento $url:

$this->redirect(’/orders/thanks’);
$this->redirect(’http://www.example.com’);

Puede también pasar datos a la acción:

$this->redirect(array(’action’ => ’edit’, $id));

El segundo parámetro de redirect() le permite definir un código de estado HTTP 
para acompañar la redirección. Puede querer usar 301 (movido permanentemente) ó
303 (ver otro), dependiendo de la naturaleza de la redirección.

El método expedirá un exit() después del redirect a menos que uno setee el 3er
parámetro a false.

Si uno necesita redireccionar a la página de referencia puede usar:

$this->redirect($this->referer());

El método también soporta parámetros basados en nombre. Si quiere redireccionar
a una URL como: 

http://www.example.com/orders/confirm/product:pizza/quantity:5

Puede usar:

$this->redirect(array(
  ’controller’ => ’orders’,
  ’action’ => ’confirm’,
  ’product’ => ’pizza’,
  ’quantity’ => 5)
);

Un ejemplo de usar query strings y hash luciría:

$this->redirect(array(
  ’controller’ => ’orders’,
  ’action’ => ’confirm’,
  ’?’ => array(
    ’product’ => ’pizza’,
    ’quantity’ => 5
  ),
  ’#’ => ’top’)
);

La URL generada sería:

http://www.example.com/orders/confirm?product=pizza&quantity=5#top

Controller::flash(string $message, string|array $url, integer $pause, string $layout)
#####################################################################################
Como redirect(), el método flash() se usa para redireccionar un usuario a una 
página nueva después de una operación. El método flash() es diferente en que
muestra un mensaje antes de pasar a otra URL.

El 1er parámetro debería contener el mensaje a exhibirse, y el 2do parámetro
es una URL relativa de CakePHP. CakePHP exhibirá el $message por $pause segundos
antes de hacer un forward al usuario.

Si hay una plantilla particular en que querría que use su mensaje flasheado,
puede especificar el nombre de ese layout en el parámetro $layout.

Para mensajes de flash en página, fijarse en el método SessionComponent::setFlash().

Callbacks
---------
Además de los callback de Request de ciclo de vida, CakePHP también soporta callbacks
relacionados a scaffolding (andamio).

Controller::beforeScaffold($method)
  $method es el nombre del método llamado por ej. index, edit, etc.
  
Controller::afterScaffoldSave($method)
  $method es el nombre del método llamado ya sea edit ó update.

Controller::afterScaffoldSaveError($method)
  $method es el nombre del método llamado ya sea edit ó update.

Controller::scaffoldError($method)
  $method es el nombre del método llamado por ej. index, edit, etc.

Otros métodos útiles
--------------------

Controller::constructClasses()
##############################
Este método carga los modelos requeridos por un controlador. Este proceso de 
carga es normalmente hecho por CakePHP, pero este método es útil tener cuando
se accede a controladores desde una perspectiva diferente. Si necesita CakePHP
en un script de línea de comandos ó algún otro uso externo, puede usar
constructClasses().

Controller::referer(mixed $default = null, boolean $local = false)
##################################################################
Retorna la URL de referencia para la petición actual. Puede usarse el parámetro
$default para suministrar una URL por defecto a usar si HTTP_REFERER no puede 
ser leído desde headers. Así, en vez de hacer esto:

class UserController extends AppController {
  public function delete($id) {
    // delete code goes here, and then...
    if ($this->referer() != ’/’) {
      return $this->redirect($this->referer());
    }
    return $this->redirect(array(’action’ => ’index’));
  }
}

puede hacer lo siguiente:

class UserController extends AppController {
  public function delete($id) {
    // delete code goes here, and then...
    return $this->redirect(
      $this->referer(array(’action’ => ’index’))
    );
  }
}

Si no se setea $default, la función va por defecto a la raíz de su dominio - ‘/’.

Si el parámetro $local se fija a true, restringe las URLs referentes al servidor
local.  

Controller::disableCache()
##########################
Usado para decirle al navegador del usuario no cachear los resultados de la
petición actual. Esto es diferente que el cacheo de vista.

Los headers enviados a este efecto son:

Expires: Mon, 26 Jul 1997 05:00:00 GMT
Last-Modified: [current datetime] GMT
Cache-Control: no-store, no-cache, must-revalidate
Cache-Control: post-check=0, pre-check=0
Pragma: no-cache

Controller::postConditions(array $data, mixed $op, string $bool, boolean $exclusive)
####################################################################################
Usar este método para convertir un set de datos de modelo POSTed (de entradas 
HtmlHelper-compatible) en un set de de condiciones de find para un modelo.
Esta función ofrece un atajo al construir lógica de búsqueda. Ej.: un usuario
administrativo puede querer ser capaz de buscar órdenes en orden para saber que
items necesitan empaquetarse. Puede usar FormHelper y HtmlHelper de CakePHP
para crear un formulario rápido basado en el modelo Order. Luego una acción 
controlador puede usar los datos posteados desde aquel formulario para las 
condiciones de escenario de find:  

public function index() {
  $conditions = $this->postConditions($this->request->data);
  $orders = $this->Order->find(’all’, compact(’conditions’));
  $this->set(’orders’, $orders);
}

Si $this->request->data[’Order’][’destination’] equivale a “Old Towne Bakery”,
postConditions convierte esa condición a un array compatible para usar en un 
método Model->find(). En este caso, array(’Order.destination’ => ’Old Towne Bakery’).

Si quiere usar un operador SQL diferente entre condiciones, suministrarla usando
el 2do parámetro:

/*
Contents of $this->request->data
array(
  ’Order’ => array(
    ’num_items’ => ’4’,
    ’referrer’ => ’Ye Olde’
  )
)
*/

// Se obtienen órdenes que tienen al menos 4 items y contienen ’Ye Olde’
$conditions = $this->postConditions(
  $this->request->data,
  array(
    ’num_items’ => ’>=’,
    ’referrer’ => ’LIKE’
  )
);
$orders = $this->Order->find(’all’, compact(’conditions’));

El 3er parámetro le permite decirle a CakePHP que operador boolean SQL usar entre
las condiciones de find. Los strings como  ‘AND’, ‘OR’ and ‘XOR’ son todos 
valores válidos.

Si el último parámetro se fija a true, y el parámetro $op es un array, los campos
no incluidos en $op no serán incluidos en las condiciones retornadas.

Controller::paginate()
......................
Método usado para resultados de paginación extraidos por sus modelos. Puede 
especificar tamaños de página, condiciones de find del modelo y más. 


Controller::requestAction(string $url, array $options)
......................
Esta función llama a una acción de controlador desde cualquier ubicación y retorna
datos de la acción. El $url pasado es una URL relativa de CakePHP 
(/nombrecontrolador/nombreaccion/parametros). Para pasar datos extra a la acción
controlador de recepción agregarlo al array $options.

Nota: Puede usar requestAction() para recobrar una vista completamente renderizada
pasando 'return' en options: requestAction($url, array(’return’));. Hacer un 
requestAction() usando return desde un método controlador puede causar que las
etiquetas script y CSS no funcionen correctamente.

Advertencia: si se usa requestAction() sin cacheo puede resultar en baja
performance. No suele ser apropiado usarlo en un controlador ó modelo.

requestAction() se usa mejor en conjunción con elementos (cacheados) - como un 
modo de recobrar datos para un elemento antes de renderizar. Usar el ej. de 
poner un elemento "últimos comentarios" en el layout. Primero necesitamos crear
una función controlador que retornará los datos:

// Controller/CommentsController.php
class CommentsController extends AppController {
  public function latest() {
    if (empty($this->request->params[’requested’])) {
      throw new ForbiddenException();
    }
    return $this->Comment->find(
      ’all’,
      array(’order’ => ’Comment.created DESC’, ’limit’ => 10)
    );
  }
}

Uno siempre debería incluir chequeos para asegurarse que sus métodos requestAction()
efectivamente son originados desde requestAction(). Fallar en hacer esto le 
permitirá a los métodos requestAction() ser accesibles directamente desde una
URL, lo que es indeseable.

Si creamos un elemento simple para llamar a esa función:

// View/Elements/latest_comments.ctp
$comments = $this->requestAction(’/comments/latest’);
foreach ($comments as $comment) {
  echo $comment[’Comment’][’title’];
}

Podemos poner ese elemento en cualquier lado para obtener la salida usando:

echo $this->element(’latest_comments’);

Escrito de este modo, siempre y cuando el elemento se renderize, se hará una 
petición al controlador para obtner los datos, los datos serán procesados, y 
retornados. Pero lo mejor es usar el cacheo de elemento para evitar procesamiento
innecesario. Modificar la llamada a element para lucir como:

echo $this->element(’latest_comments’, array(), array(’cache’ => true));

La llamada requestAction() no será hecha mientras el archivo vista elemento 
cacheado exista y sea válido.

Adicionalmente, requestAction() toma URLs de estilo cake basados en array:

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’featured’),
  array(’return’)
);

Esto le permite a la llamada requestAction() saltear el uso de Router::url() que
puede incrementar la performance. Los arrays basados en url son los mismos que
los que usa HtmlHelper::link() con una diferencia - si uno está usando parámetros
nombrados ó pasados, debe ponerlos en un 2do array y envolverlos con la clave 
correcta. Esto es debido a que requestAction() mergea el array de args nombrado
(2do parámetro de requestAction) con el array miembro Controller::params y no
ubica explícitamente el array nombrado args en la clave 'named'; también estarán
disponibles miembros adicionales en el array $option en el array Controller::params
de la acción peticionada:

echo $this->requestAction(’/articles/featured/limit:3’);
echo $this->requestAction(’/articles/view/5’);

Como un array en requestAction() sería:

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’featured’),
  array(’named’ => array(’limit’ => 3))
);

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’view’),
  array(’pass’ => array(5))
);

Note: Unlike other places where array URLs are analogous to string URLs, requestAction()
treats them differently.

When using an array url in conjunction with requestAction() you must specify all
parameters that you will need in the requested action. This includes parameters like
$this->request->data. In addition to passing all required parameters, named and pass parameters
must be done in the second array as seen above.

Controller::loadModel(string $modelClass, mixed $id)
The loadModel() function comes handy when you need to use a model which is not the controller’s
default model or its associated model:
$this->loadModel(’Article’);
$recentArticles = $this->Article->find(
’all’,
array(’limit’ => 5, ’order’ => ’Article.created DESC’)
);
$this->loadModel(’User’, 2);
$user = $this->User->read();

Controller Attributes

For a complete list of controller attributes and their descriptions visit the CakePHP API2.


SEGUIR CAP5 (60)  
    
