CONTROLADORES
=============
Un controlador suele usarse para gestiona la lógica alrededor de un modelo único.
Ej.: si uno construye un sitio para una panadería (bakery) online, uno puede tener
un RecipesController que gestione sus recetas y un IngredientsController que 
gestione sus ingredientes. Se pueden tener también controladores que funcionen con
más de un modelo. En CakePHP, un controlador se nombra después del modelo primario
que maneja.

Sus controladores de aplicación extienden la clase AppController, que extiende
la clase Controller núcleo. La clase AppController puede definirse en  
/app/Controller/AppController.php y este debería contener métodos que son 
compartidos entre todos los controladores de su aplicación.

Los controladores proveen un número de métodos que manejan peticiones. Estas son
llamadas acciones. Por defecto, cada método público en un controlador es una
acción, y es accesible desde una URL. Una acción es responsable de interpretar
la petición y crear la respuesta. Usualmente las respuestas están en la forma
de vista renderizada, pero también hay otros modos de crear respuestas.
................................................................................

El App Controller
-----------------
La clase AppController es la clase padre de todos sus controladores de aplicación.
AppController mismo extiende la clase Controller incluída en la librería núcleo
de CakePHP. AppController está definia en /app/Controller/AppController.php como
sigue:  

class AppController extends Controller {
}

Los atributos y métodos Controller creados en su AppController estarán disponibles
para todos sus controladores de la aplicación. 

Mientras que las reglas de herencia orientadas a objeto normales aplican, CakePHP
hace trabajo adicional cuando se vienen atributos controlador especiales. Para los 
componentes y helpers usados por un controlador, los arrays de valor AppController
son mergeados con arreglos de clase controlador hijos. Los valores en la clase
hijo siempre redefinirán aquellos en AppController.  

Nota: CakePHP mergea las siguientes variables desde el AppController en sus controladores
de aplicación:

• $components
• $helpers
• $uses

Hay que agregar los helpers de formulario y Html por defecto si uno define la
propiedad $helpers en su AppController.

También llamar a los callbacks de AppController dentro de los callbacks controlador
hijos para mejorar los resultados:

public function beforeFilter() {
  parent::beforeFilter();
}

Parámetros de request
---------------------
Cuando es hecha una petición a una aplicación CakePHP, las clases Router y Dispatcher
de CakePHP usan la configuración de Enrutamiento para hallar y crear el controlador
correcto. Los datos de petición son encapsulados en un objeto request. CakePHP 
pone toda la información de request importante en la propiedad $this->request.

Acciones Controller
-------------------
Las acciones Controller son responsables de convertir los parámetros de petición 
en una respuesta para el usuario / navegador que hace la petición. CakePHP usa
convenciones para automatizar este proceso y quitar algún código repetitivo
que de otro modo necesitaría escribir.

Por convención, CakePHP renderiza una vista con una versión inclinada del nombre
de acción. Volviendo al ej. de la panadería online, nuestro RecipesController 
puede contener las acciones view(), share(), y search(). El controlador 
estaría ubicado en /app/Controller/RecipesController.php y contiene:   

# /app/Controller/RecipesController.php
class RecipesController extends AppController {
  public function view($id) {
    //action logic goes here..
  }
  
  public function share($customerId, $recipeId) {
    //action logic goes here.. 
  }
  
  public function search($query) {
    //action logic goes here..
  }
}

Los archivos de vista para estas acciones serían app/View/Recipes/view.ctp,
app/View/Recipes/share.ctp, y app/View/Recipes/search.ctp. El nombre de archivo
de vista convencional es la versión en minúsculas y subrayada del nombre de 
acción.

Las acciones Controller usan generalmente set() para crear un contexto que usa View
para renderizar la vista. Debido a la convención que usa CakePHP, no necesita
crear y renderizar la vista manualmente. En vez de eso, una vez que la acción 
controlador se ha completado, CakePHP manejará la renderización y entregará la
View. 

Si uno quiere esquivar el comportamiento por defecto la cual es hacer un desvío
de la renderización de vista.

. Si retorna un string, o un objeto que puede ser convertido a un string desde su
acción controlador, este será usado como el cuerpo de respuesta

. Puede retornar un objeto CakeResponse con la respuesta creada completamente

Cuando uno usa métodos controlador con requestAction(), con frecuencia querrá
retornar datos que no son un string. Si tiene métodos controlador que son usados
para peticiones web normales + requestAction, debería chequear el tipo de 
petición antes de retornar:

class RecipesController extends AppController {
  public function popular() {
    $popular = $this->Recipe->popular();
    if (!empty($this->request->params[’requested’])) {
      return $popular;
    }
    $this->set(’popular’, $popular);
  }
}

La acción controlador de arriba es un ej. de como puede usarse un método con
requestAction() y peticiones normales. Retornar datos de array a una petición
no-requestAction causará errores y debería evitarse.
................................................................................
Callbacks de petición Ciclo de vida
-----------------------------------
Clase Controller
................
Los controladores CakePHP vienen ajustados con callbacks que puede usar para 
insertar lógica sobre la petición del ciclo de vida:
 
Controller::beforeFilter()

Esta función es ejecutada antes de cada acción en el controlador. Es bueno 
chequear por una sesión activa ó inspeccionar permisos de usuario.

Note: The beforeFilter() method will be called for missing actions, and scaffolded actions.

Controller::beforeRender()

Llamado después de la lógica acción controlador, pero antes que la vista sea
renderizada. Este callback no se usa con frecuencia, pero pueden ser necesario
si uno llama manualmente a render() antes de finalizar una acción dada.

Controller::afterFilter()

Llamado después de cada acción controlador, y después que se completa la renderización.
Este es el último método controlador a ejecutar.

En adición a callbacks controlador de ciclo de vida, los componentes también
proveen un set similar de callbacks.

Métodos Controlador
-------------------
Interacción con Views
.....................
Los controladores interactúan con vistas en varias formas. Primero, son capaces
de pasar datos a las vistas, usando set(). Puede también decidir que clase de 
vista usar, y que archivo de vista debería ser renderizado desde el controlador.
 
Controller::set(string $var, mixed $value)

El método set() es el modo principal de enviar datos desde su controlador a su
vista. Usado set(), la variable puede ser accedida en su vista:

// Primero pasar datos desde el controlador:
$this->set(’color’, ’pink’);
// Luego, en la vista puede utilizar los datos:
?>
You have selected <?php echo $color; ?> icing for the cake.

El método set() también toma un array asociativo como su primer parámetro. Esto
puede con frecuencia un modo rápido de asignar un set de información a la vista:

$data = array(
  ’color’ => ’pink’,
  ’type’ => ’sugar’,
  ’base_price’ => 23.95
);
// make $color, $type, and $base_price available to the view:

$this->set($data);

El atributo $pageTitle ya no existe. Usar set() para fijar el título:

$this->set(’title_for_layout’, ’This is the page title’);

Controller::render(string $view, string $layout)

El método render() es llamado automáticamente al final de cada acción controlador
peticionada. Este método realiza toda la lógica de vista (usando los datos que ha
enviado usando el método set()), pone la vista dentro de su $layout, y lo sirve
de vuelta al usuario final.  

La archivo vista por defecto usado para renderizar es determinado por convención.
Si es peticionada la acción search() del RecipesController, el archivo de vista
en /app/View/Recipes/search.ctp será renderizado:

class RecipesController extends AppController {
  // ...
  public function search() {
    // Render the view in /View/Recipes/search.ctp
    $this->render();
  }
  // ...
}

Aunque CakePHP lo llamará automáticamente después de cada lógica de la acción
(a menos que haya seteado $this->autoRender a false), puede usarlo para especificar
un archivo de vista alternativo especificando un nombre de acción en el controlador
usando $action.

Si $view comienza con ‘/’, se asume ser una archivo elemento ó vista relativo a 
la carpeta /app/View. Esto permite renderización directa de elementos, muy útil
en llamadas AJAX.

// Renderiza el elemento en /View/Elements/ajaxreturn.ctp
$this->render(’/Elements/ajaxreturn’);

El parámetro $layout le permite especificar el layout con el cual se renderiza
la vista.

Renderizar una vista específica
...............................
En su controlador, puede querer renderizar una vista diferente que la convencional.
Puede hacer esto llamando directamente a render(). Una vez que ha llamado a 
render(), CakePHP no intentará re-renderizar la vista:

class PostsController extends AppController {
  public function my_action() {
    $this->render(’custom_file’);
  }
}

Esto renderizaría app/View/Posts/custom_file.ctp en vez de 
app/View/Posts/my_action.ctp

Puede también renderizar vistas dentro de plugins usando la sintaxis:
$this->render(’PluginName.PluginController/custom_file’). Ej.:

class PostsController extends AppController {
  public function my_action() {
    $this->render(’Users.UserDetails/custom_file’);
  }
}

Esto renderizaría app/Plugin/Users/View/UserDetails/custom_file.ctp

Control de flujo
----------------
Controller::redirect(mixed $url, integer $status, boolean $exit)
################################################################
El método control de flujo que usará con mayor frecuencia es redirect(). Este 
método toma su primer parámetro en la forma de una URL relativa de CakePHP. 
Cuando un usuario ha hecho una orden exitosamente, puede desear redireccionarlas
a una pantalla de recepción:

public function place_order() {
  // La lógica para finalizar la orden va aquí
  if ($success) {
    return $this->redirect(
      array(’controller’ => ’orders’, ’action’ => ’thanks’)
    );
  }
  return $this->redirect(
    array(’controller’ => ’orders’, ’action’ => ’confirm’)
  );
}

Puede también usar una URL absoluta ó relativa como el argumento $url:

$this->redirect(’/orders/thanks’);
$this->redirect(’http://www.example.com’);

Puede también pasar datos a la acción:

$this->redirect(array(’action’ => ’edit’, $id));

El segundo parámetro de redirect() le permite definir un código de estado HTTP 
para acompañar la redirección. Puede querer usar 301 (movido permanentemente) ó
303 (ver otro), dependiendo de la naturaleza de la redirección.

El método expedirá un exit() después del redirect a menos que uno setee el 3er
parámetro a false.

Si uno necesita redireccionar a la página de referencia puede usar:

$this->redirect($this->referer());

El método también soporta parámetros basados en nombre. Si quiere redireccionar
a una URL como: 

http://www.example.com/orders/confirm/product:pizza/quantity:5

Puede usar:

$this->redirect(array(
  ’controller’ => ’orders’,
  ’action’ => ’confirm’,
  ’product’ => ’pizza’,
  ’quantity’ => 5)
);

Un ejemplo de usar query strings y hash luciría:

$this->redirect(array(
  ’controller’ => ’orders’,
  ’action’ => ’confirm’,
  ’?’ => array(
    ’product’ => ’pizza’,
    ’quantity’ => 5
  ),
  ’#’ => ’top’)
);

La URL generada sería:

http://www.example.com/orders/confirm?product=pizza&quantity=5#top

Controller::flash(string $message, string|array $url, integer $pause, string $layout)
#####################################################################################
Como redirect(), el método flash() se usa para redireccionar un usuario a una 
página nueva después de una operación. El método flash() es diferente en que
muestra un mensaje antes de pasar a otra URL.

El 1er parámetro debería contener el mensaje a exhibirse, y el 2do parámetro
es una URL relativa de CakePHP. CakePHP exhibirá el $message por $pause segundos
antes de hacer un forward al usuario.

Si hay una plantilla particular en que querría que use su mensaje flasheado,
puede especificar el nombre de ese layout en el parámetro $layout.

Para mensajes de flash en página, fijarse en el método SessionComponent::setFlash().

Callbacks
---------
Además de los callback de Request de ciclo de vida, CakePHP también soporta callbacks
relacionados a scaffolding (andamio).

Controller::beforeScaffold($method)
  $method es el nombre del método llamado por ej. index, edit, etc.
  
Controller::afterScaffoldSave($method)
  $method es el nombre del método llamado ya sea edit ó update.

Controller::afterScaffoldSaveError($method)
  $method es el nombre del método llamado ya sea edit ó update.

Controller::scaffoldError($method)
  $method es el nombre del método llamado por ej. index, edit, etc.

Otros métodos útiles
--------------------

Controller::constructClasses()
##############################
Este método carga los modelos requeridos por un controlador. Este proceso de 
carga es normalmente hecho por CakePHP, pero este método es útil tener cuando
se accede a controladores desde una perspectiva diferente. Si necesita CakePHP
en un script de línea de comandos ó algún otro uso externo, puede usar
constructClasses().

Controller::referer(mixed $default = null, boolean $local = false)
##################################################################
Retorna la URL de referencia para la petición actual. Puede usarse el parámetro
$default para suministrar una URL por defecto a usar si HTTP_REFERER no puede 
ser leído desde headers. Así, en vez de hacer esto:

class UserController extends AppController {
  public function delete($id) {
    // delete code goes here, and then...
    if ($this->referer() != ’/’) {
      return $this->redirect($this->referer());
    }
    return $this->redirect(array(’action’ => ’index’));
  }
}

puede hacer lo siguiente:

class UserController extends AppController {
  public function delete($id) {
    // delete code goes here, and then...
    return $this->redirect(
      $this->referer(array(’action’ => ’index’))
    );
  }
}

Si no se setea $default, la función va por defecto a la raíz de su dominio - ‘/’.

Si el parámetro $local se fija a true, restringe las URLs referentes al servidor
local.  

Controller::disableCache()
##########################
Usado para decirle al navegador del usuario no cachear los resultados de la
petición actual. Esto es diferente que el cacheo de vista.

Los headers enviados a este efecto son:

Expires: Mon, 26 Jul 1997 05:00:00 GMT
Last-Modified: [current datetime] GMT
Cache-Control: no-store, no-cache, must-revalidate
Cache-Control: post-check=0, pre-check=0
Pragma: no-cache

Controller::postConditions(array $data, mixed $op, string $bool, boolean $exclusive)
####################################################################################
Usar este método para convertir un set de datos de modelo POSTed (de entradas 
HtmlHelper-compatible) en un set de de condiciones de find para un modelo.
Esta función ofrece un atajo al construir lógica de búsqueda. Ej.: un usuario
administrativo puede querer ser capaz de buscar órdenes en orden para saber que
items necesitan empaquetarse. Puede usar FormHelper y HtmlHelper de CakePHP
para crear un formulario rápido basado en el modelo Order. Luego una acción 
controlador puede usar los datos posteados desde aquel formulario para las 
condiciones de escenario de find:  

public function index() {
  $conditions = $this->postConditions($this->request->data);
  $orders = $this->Order->find(’all’, compact(’conditions’));
  $this->set(’orders’, $orders);
}

Si $this->request->data[’Order’][’destination’] equivale a “Old Towne Bakery”,
postConditions convierte esa condición a un array compatible para usar en un 
método Model->find(). En este caso, array(’Order.destination’ => ’Old Towne Bakery’).

Si quiere usar un operador SQL diferente entre condiciones, suministrarla usando
el 2do parámetro:

/*
Contents of $this->request->data
array(
  ’Order’ => array(
    ’num_items’ => ’4’,
    ’referrer’ => ’Ye Olde’
  )
)
*/

// Se obtienen órdenes que tienen al menos 4 items y contienen ’Ye Olde’
$conditions = $this->postConditions(
  $this->request->data,
  array(
    ’num_items’ => ’>=’,
    ’referrer’ => ’LIKE’
  )
);
$orders = $this->Order->find(’all’, compact(’conditions’));

El 3er parámetro le permite decirle a CakePHP que operador boolean SQL usar entre
las condiciones de find. Los strings como  ‘AND’, ‘OR’ and ‘XOR’ son todos 
valores válidos.

Si el último parámetro se fija a true, y el parámetro $op es un array, los campos
no incluidos en $op no serán incluidos en las condiciones retornadas.

Controller::paginate()
......................
Método usado para resultados de paginación extraidos por sus modelos. Puede 
especificar tamaños de página, condiciones de find del modelo y más. 


Controller::requestAction(string $url, array $options)
......................................................
Esta función llama a una acción de controlador desde cualquier ubicación y retorna
datos de la acción. El $url pasado es una URL relativa de CakePHP 
(/nombrecontrolador/nombreaccion/parametros). Para pasar datos extra a la acción
controlador de recepción agregarlo al array $options.

Nota: Puede usar requestAction() para recobrar una vista completamente renderizada
pasando 'return' en options: requestAction($url, array(’return’));. Hacer un 
requestAction() usando return desde un método controlador puede causar que las
etiquetas script y CSS no funcionen correctamente.

Advertencia: si se usa requestAction() sin cacheo puede resultar en baja
performance. No suele ser apropiado usarlo en un controlador ó modelo.

requestAction() se usa mejor en conjunción con elementos (cacheados) - como un 
modo de recobrar datos para un elemento antes de renderizar. Usar el ej. de 
poner un elemento "últimos comentarios" en el layout. Primero necesitamos crear
una función controlador que retornará los datos:

// Controller/CommentsController.php
class CommentsController extends AppController {
  public function latest() {
    if (empty($this->request->params[’requested’])) {
      throw new ForbiddenException();
    }
    return $this->Comment->find(
      ’all’,
      array(’order’ => ’Comment.created DESC’, ’limit’ => 10)
    );
  }
}

Uno siempre debería incluir chequeos para asegurarse que sus métodos requestAction()
efectivamente son originados desde requestAction(). Fallar en hacer esto le 
permitirá a los métodos requestAction() ser accesibles directamente desde una
URL, lo que es indeseable.

Si creamos un elemento simple para llamar a esa función:

// View/Elements/latest_comments.ctp
$comments = $this->requestAction(’/comments/latest’);
foreach ($comments as $comment) {
  echo $comment[’Comment’][’title’];
}

Podemos poner ese elemento en cualquier lado para obtener la salida usando:

echo $this->element(’latest_comments’);

Escrito de este modo, siempre y cuando el elemento se renderize, se hará una 
petición al controlador para obtner los datos, los datos serán procesados, y 
retornados. Pero lo mejor es usar el cacheo de elemento para evitar procesamiento
innecesario. Modificar la llamada a element para lucir como:

echo $this->element(’latest_comments’, array(), array(’cache’ => true));

La llamada requestAction() no será hecha mientras el archivo vista elemento 
cacheado exista y sea válido.

Adicionalmente, requestAction() toma URLs de estilo cake basados en array:

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’featured’),
  array(’return’)
);

Esto le permite a la llamada requestAction() saltear el uso de Router::url() que
puede incrementar la performance. Los arrays basados en url son los mismos que
los que usa HtmlHelper::link() con una diferencia - si uno está usando parámetros
nombrados ó pasados, debe ponerlos en un 2do array y envolverlos con la clave 
correcta. Esto es debido a que requestAction() mergea el array de args nombrado
(2do parámetro de requestAction) con el array miembro Controller::params y no
ubica explícitamente el array nombrado args en la clave 'named'; también estarán
disponibles miembros adicionales en el array $option en el array Controller::params
de la acción peticionada:

echo $this->requestAction(’/articles/featured/limit:3’);
echo $this->requestAction(’/articles/view/5’);

Como un array en requestAction() sería:

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’featured’),
  array(’named’ => array(’limit’ => 3))
);

echo $this->requestAction(
  array(’controller’ => ’articles’, ’action’ => ’view’),
  array(’pass’ => array(5))
);

Nota: A diferencia de otros lugares donde URLs de array son análogos a URLs de 
string, requestAction() los trata de forma diferente.

Al usar una url array en conjunción con requestAction() debe especificar todos
los parámetros que necesitará en la acción peticionada. Esto incluye parámetros
como $this->request->data. En adición a pasar todos los parámetros requeridos
los parámetros nombrados y de paso deben ser hechos en el 2do array.

Controller::loadModel(string $modelClass, mixed $id)
....................................................
La función loadModel() es provechosa cuando necesita usar un modelo que no es
el modelo por defecto del controlador ó su modelo asociado:

$this->loadModel(’Article’);
$recentArticles = 
  $this->Article->find(
    ’all’,
    array(
      ’limit’ => 5, 
      ’order’ => ’Article.created DESC’
    )
  );
$this->loadModel(’User’, 2);
$user = $this->User->read();

Atributos de Controlador
------------------------

propiedad Controller::$name
...........................
El atributo $name debería fijarse a el nombre del controlador. Esta es la forma
plural del modelo primario que usa el controlador. Esta propiedad puede omitirse,
pero salvaguarda a CakePHP de declinarla (inflecting):

// $name controller attribute usage example
class RecipesController extends AppController {
  public $name = ’Recipes’;
}

$components, $helpers y $uses
-----------------------------
Los próximos atributos controlador usados con más frecuencia le dicen a CakePHP
que  $helpers, $components, y modelos uno estará usando en conjunción con el
controlador actual. Usar estos atributos hace a las clases MVC dadas por $components
y $uses disponibles al controlador como variables de clase ($this->ModelName, 
por ej.) y aquellos dados por $helpers a la vista como una variable de referencia
a objeto ($this->{$helpername}).

Nota: cada controlador tiene alguna de estas clases disponibles por defecto, 
así uno puede no necesitar configurar su controlador para nada.

Propiedad Controller::$uses
...........................
Los controladores tienen acceso a su modelo primario disponible por defecto. 
Nuestro RecipesController tendrá la clase modelo Recipe disponible en $this->Recipe, 
y nuestro ProductsController ofrece también el modelo Product en $this->Product.
Pero, al permitir a un controlador acceder a modelos adicionales a través de
la variable $uses, el nombre del modelo controlador actual también debe ser 
incluído. Esto se ilustra en el ej. de abajo.

Si no desea usar un Model en su controlador, establecer public $uses = array().
Esto le permitirá usar un controlador sin necesidad de un archivo Model
correspondiente. Pero, los modelos definidos en el AppController aún serán 
cargados. Puede también usar false para no cargar ningún modelo. Aún aquellos
definidos en el AppController.

Cambiado en v.2.1: $uses tiene ahora un nuevo valor por defecto, este también 
maneja false de forma diferente.

Propiedad Controller::$helpers
..............................
El HtmlHelper, FormHelper, y SessionHelper están disponibles por defecto, 
ya que es el SessionComponent. Pero si uno elige definir su propio array $helpers
en AppController, asegurarse de incluir HtmlHelper y FormHelper si uno quiere
que ellos estén aún disponibles por defecto en sus Controllers. 

Se ve como decirle a un Controller CakePHP que uno planea usar clases MVC 
adicionales:

class RecipesController extends AppController {
  public $uses = array(’Recipe’, ’User’);
  public $helpers = array(’Js’);
  public $components = array(’RequestHandler’);
}

Cada una de estas variables son mergeadas con sus valores heredados, así no es
necesario (por ej.) redeclarar el FormHelper, ó cualquier cosa que está declarada
en su AppController.

Propiedad Controller::$components
.................................
El array components le permite fijar que Components usará un controlador. Como
los componentes $helpers y $uses en sus controladores son mergeados con aquellos
en AppController. Como con $helpers uno puede pasar ajustes (settings) en
$components.  

Otros atributos
---------------

property Controller::$cacheAction
.................................
El atributo cacheAction se usa para definir la duración y otra información sobre
el caching de página completa. 

property Controller::$paginate
..............................
El atributo paginate es un propiedad de compatibilidad deprecada. Usar esta 
carga y configura el PaginatorComponent. Se recomienda que actualice su código
para usar ajustes de componente normales:

class ArticlesController extends AppController {
  public $components = array(
    ’Paginator’ => array(
      ’Article’ => array(
        ’conditions’ => array(’published’ => 1)
      )
    )
  );
}

Mas sobre controladores
-----------------------

Objetos de petición y respuesta
...............................
Es nuevo en CakePHP 2.0. En versiones anteriores, estos objetos fueron representados
a través de arrays, y los métodos relacionados fueron expandidos a través de 
RequestHandlerComponent, Router, Dispatcher y Controller. No hubo objeto
autoritativo sobre que información contuvo la petición. Para 2.0, se usaron para
esto CakeRequest y CakeResponse.

CakeRequest
...........
Es el objeto de petición por defecto usado en CakePHP. Centraliza un número de
características para interrogar e interactuar con datos de petición. En cada
petición, es creado un CakeRequest y luego pasado por referencia a las capas 
varias de una aplicación que usa datos de petición. Por defecto, CakeRequest
es asignada a $this->request, y está disponible en Controllers, Views y Helpers.
Puede también acceder a este en Components usando la referencia controlador. 
Algunos deberes que realiza CakeRequest:

• Procesa arrays GET, POST, y FILES dentro de estructuras de datos con los que
  es familiar

• Provee introspección de ambiente perteneciente a la petición. Cosas como 
  los headers enviados, la dirección IP del cliente, y la información de
  subdominio / dominio sobre la aplicación que el servidor está corriendo

• Provee acceso a parámetros de request ambos como índices de array y propiedades
  de objeto

Acceder parámetros de request
.............................
CakeRequest expone varias interfaces para acceso de parámetros de request. El 
1ro usa propiedades de objeto, el 2do usa índices de array, y el 3ro usa 
$this->request->params:

$this->request->controller;
$this->request[’controller’];
$this->request->params[’controller’];

Todo lo de arriba accederá al mismo valor. Todos los elementos Route son accedidos
a través de esta interfaz.

Adicionalmente a los elementos Route, uno con frecuencia necesita acceso a 
'argumentos pasados' y 'parámetros Nombrados'.

// Passed arguments
$this->request->pass;
$this->request[’pass’];
$this->request->params[’pass’];

// named parameters
$this->request->named;
$this->request[’named’];
$this->request->params[’named’];

Todos estos le proveerán de acceso a los argumentos pasados y parámetros nombrados.
Hay varios parámetros que CakePHP usa internamente. Todos estos se encuentran
en los parámetros de request:

• plugin      El plugin que maneja la petición. Será null cuando no hay plugin
• controller  El controlador que maneja la petición actual
• action      La acción que maneja la petición actual
• prefix      El prefijo para la acción actual
• bare        Presente cuando la petición vino del requestAction() e incluyó la
              opción bare. Las peticiones bare no tienen layouts renderizados
• requested   Presente y puesto a true cuando la acción vino de requestAction()               

Acceder a parámetros Querystring
................................

Querystring parameters can be read using CakeRequest::$query:

// URL is /posts/index?page=1&sort=title
$this->request->query[’page’];
// You can also access it via an array
// Note: BC accessor, will be deprecated in future versions
$this->request[’url’][’page’];

You can either directly access the $query property, or you can use CakeRequest::query() to read
the URL query array in an error-free manner. Any keys that do not exist will return null:

$foo = $this->request->query(’value_that_does_not_exist’);
// $foo === null

Accessing POST data

All POST data can be accessed using CakeRequest::$data. Any form data that contains a data prefix
will have that data prefix removed. For example:

// An input with a name attribute equal to ’data[MyModel][title]’
// is accessible at
$this->request->data[’MyModel’][’title’];

You can either directly access the $data property, or you can use CakeRequest::data() to read the
data array in an error-free manner. Any keys that do not exist will return null:

$foo = $this->request->data(’Value.that.does.not.exist’);
// $foo == null

Accessing PUT or POST data

New in version 2.2.

When building REST services, you often accept request data on PUT and DELETE requests. As of 2.2, any
application/x-www-form-urlencoded request body data will automatically be parsed and set to
$this->data for PUT and DELETE requests. If you are accepting JSON or XML data, see below for
how you can access those request bodies.

Accessing XML or JSON data

Applications employing REST often exchange data in non-URL-encoded post bodies. You can read input
data in any format using CakeRequest::input(). By providing a decoding function, you can receive
the content in a deserialized format:

// Get JSON encoded data submitted to a PUT/POST action
$data = $this->request->input(’json_decode’);

SEGUIR CAP5 (66/84)  
    
